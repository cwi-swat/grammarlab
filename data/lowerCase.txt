--------------------ada::kellogg.bgf--------------------
range ::= range_dots | range_attrib_ref ;
relation ::= simple_expression ((IN range_or_mark) | (n::NOT IN range_or_mark) | (EQ simple_expression) | (NE simple_expression) | (LT_ simple_expression) | (LE simple_expression) | (GT simple_expression) | (GE simple_expression))? ;
pragma ::= PRAGMA IDENTIFIER pragma_args_opt SEMI ;
condition ::= expression ;
expression ::= relation ((a::AND THEN? relation) | (o::OR ELSE? relation) | (XOR relation))* ;
renames ::= RENAMES name | (dummy::definable_operator_symbol) ;
designator ::= (op::definable_operator_symbol) | (n::IDENTIFIER) ;
prefix ::= IDENTIFIER ((DOT ALL | IDENTIFIER) | (p::LPAREN value_s RPAREN))* ;
value ::= (OTHERS RIGHT_SHAFT expression) | (ranged_expr_s (RIGHT_SHAFT expression)?) ;
factor ::= (NOT primary) | (ABS primary) | (primary (EXPON primary)?) ;
statement ::= def_label_opt null_stmt | exit_stmt | return_stmt | goto_stmt | delay_stmt | abort_stmt | raise_stmt | requeue_stmt | accept_stmt | select_stmt | if_stmt | case_stmt | (loop_stmt SEMI) | (block END SEMI) | (statement_identifier (loop_stmt id_opt SEMI) | (block end_id_opt SEMI)) | call_or_assignment ;
block ::= declare_opt block_body ;
term ::= factor ((STAR factor) | (DIV factor) | (MOD factor) | (REM factor))* ;
allocator ::= n::NEW name_or_qualified ;
name ::= IDENTIFIER ((DOT ALL | IDENTIFIER | CHARACTER_LITERAL | (dummy::is_operator)) | (p::LPAREN value_s RPAREN) | (TIC attribute_id))* ;
variant ::= w::WHEN choice_s RIGHT_SHAFT component_list ;
subunit ::= sep::SEPARATE LPAREN compound_name RPAREN subprogram_body | package_body | task_body | protected_body ;
statements ::= (pragma | statement)+ ;
separate ::= SEPARATE ;
primary ::= name_or_qualified | parenthesized_primary | allocator | NuLL | NUMERIC_LIT | CHARACTER_LITERAL | (cs::CHAR_STRING operator_call_tail?) ;
choice ::= OTHERS | discrete_with_range | expression ;
--------------------ada::kempe.bgf--------------------
comment ::= "-" "-" non_end_of_line_character* ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
numeral ::= digit (underline? digit)* ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
constraint ::= scalar_constraint | composite_constraint ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
pragma ::= "pragma" identifier ("(" pragma_argument_association ("," pragma_argument_association)* ")")? ";" ;
condition ::= boolean_expression ;
expression ::= (relation ("and" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" relation)*) | (relation ("or" "else" relation)*) | (relation ("xor" relation)*) ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
label ::= "<<" label_statement_identifier ">>" ;
prefix ::= name | implicit_dereference ;
slice ::= prefix "(" discrete_range ")" ;
base ::= numeral ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" expression) ;
term ::= factor (multiplying_operator factor)* ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | explicit_dereference | indexed_component | slice | selected_component | attribute_reference | type_conversion | function_call | character_literal ;
position ::= static_expression ;
identifier ::= identifier_letter (underline? letter_or_digit)* ;
character ::= graphic_character | format_effector | other_control_function ;
guard ::= "when" condition "=>" ;
variant ::= "when" discrete_choice_list "=>" component_list ;
subunit ::= "separate" "(" parent_unit_name ")" proper_body ;
compilation ::= compilation_unit* ;
mode ::= ("in"?) | ("in" "out") | "out" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
body ::= proper_body | body_stub ;
--------------------ada::laemmel-verhoef.bgf--------------------
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
constraint ::= scalar_constraint | composite_constraint ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range_definition) | (simple_expression "not"? "in" subtype_mark) ;
pragma ::= "pragma" identifier ("(" pragma_argument_association ("," pragma_argument_association)* ")")? ";" ;
condition ::= boolean_expression ;
expression ::= (relation ("and" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" relation)*) | (relation ("or" "else" relation)*) | (relation ("xor" relation)*) ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
label ::= "<<" label_statement_identifier ">>" ;
prefix ::= name | implicit_dereference ;
slice ::= prefix "(" discrete_range ")" ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" expression) ;
term ::= factor (multiplying_operator factor)* ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | explicit_dereference | indexed_component | slice | selected_component | attribute_reference | type_conversion | function_call | character_literal ;
position ::= static_expression ;
guard ::= "when" condition "=>" ;
variant ::= "when" discrete_choice_list "=>" component_list ;
subunit ::= "separate" "(" parent_unit_name ")" proper_body ;
compilation ::= compilation_unit* ;
mode ::= ("in"?) | ("in" "out") | "out" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
body ::= proper_body | body_stub ;
--------------------ada::lncs-2219.bgf--------------------
comment ::= "-" "-" non_end_of_line_character* ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
numeral ::= digit (underline? digit)* ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
constraint ::= scalar_constraint | composite_constraint ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
pragma ::= "pragma" identifier ("(" pragma_argument_association ("," pragma_argument_association)* ")")? ";" ;
condition ::= boolean_expression ;
expression ::= (relation ("and" relation)*) | (relation ("or" relation)*) | (relation ("xor" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" "else" relation)*) ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
label ::= "<<" label_statement_identifier ">>" ;
prefix ::= name | implicit_dereference ;
slice ::= prefix "(" discrete_range ")" ;
base ::= numeral ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" expression) ;
term ::= factor (multiplying_operator factor)* ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | indexed_component | selected_component | type_conversion | character_literal | explicit_dereference | slice | attribute_reference | function_call ;
position ::= static_expression ;
identifier ::= identifier_letter (underline? letter_or_digit)* ;
character ::= graphic_character | format_effector | other_control_function ;
guard ::= "when" condition "=>" ;
variant ::= "when" discrete_choice_list "=>" component_list ;
subunit ::= "separate" "(" parent_unit_name ")" proper_body ;
compilation ::= compilation_unit* ;
mode ::= ("in"?) | ("in" "out") | "out" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
body ::= proper_body | body_stub ;
--------------------ada::lncs-4348.bgf--------------------
comment ::= "-" "-" non_end_of_line_character* ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
numeral ::= digit (underline? digit)* ;
constraint ::= scalar_constraint | composite_constraint ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
pragma ::= "pragma" identifier ("(" pragma_argument_association ("," pragma_argument_association)* ")")? ";" ;
condition ::= boolean_expression ;
expression ::= (relation ("and" relation)*) | (relation ("or" relation)*) | (relation ("xor" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" "else" relation)*) ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
label ::= "<<" label_statement_identifier ">>" ;
prefix ::= name | implicit_dereference ;
slice ::= prefix "(" discrete_range ")" ;
base ::= numeral ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" restriction_parameter_argument) ;
term ::= factor (multiplying_operator factor)* ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | indexed_component | selected_component | type_conversion | character_literal | explicit_dereference | slice | attribute_reference | function_call ;
position ::= static_expression ;
identifier ::= identifier_start (identifier_start | identifier_extend)* ;
guard ::= "when" condition "=>" ;
variant ::= "when" discrete_choice_list "=>" component_list ;
subunit ::= "separate" "(" parent_unit_name ")" proper_body ;
compilation ::= compilation_unit* ;
mode ::= ("in"?) | ("in" "out") | "out" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
body ::= proper_body | body_stub ;
--------------------ada::cordy-hyaric.bgf--------------------
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
range ::= range_attribute_reference | (simple_expression SP ".." SP simple_expression) ;
relation ::= (simple_expression relational_operator_simple_expression?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
pragma ::= ("pragma" id blocksemi) | ("pragma" id pragma_arguments blocksemi) ;
blocksemi ::= ";" NL ;
label ::= "<<" statement_identifier ">>" ;
unitsemi ::= ";" NL NL ;
statement ::= label* unlabeled_statement ;
semi ::= ";" NL ;
term ::= factor multiplying_operator_factor* ;
position ::= expression ;
identifier ::= id | wide_identifier ;
guard ::= "when" condition arrow ;
mode ::= ("in"?) | ("in" "out") | "out" ;
body ::= proper_body | body_stub ;
colon ::= ":" ;
constraint ::= scalar_constraint | composite_constraint ;
condition ::= expression ;
expression ::= relation and_or_xor_relation* ;
blockeol ::= NL ;
designator ::= (designator_parent_unit_name? identifier) | operator_symbol ;
prefix ::= name ;
slice ::= prefix slice_component ;
orbar ::= "|" | "!" ;
factor ::= (primary starstar_primary?) | ("abs" primary) | ("not" primary) ;
restriction ::= identifier arrow_restriction_parameter_argument? ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= (direct_name name_component*) | character_literal ;
arrow ::= "=>" ;
variant ::= "when" discrete_choice_list arrow component_list ;
subunit ::= "separate" "(" parent_unit_name ")" proper_body ;
program ::= compilation ;
compilation ::= compilation_unit* ;
eol ::= NL ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") | if_expression ;
--------------------c::iso-9899-1999.bgf--------------------
statement ::= labeled-statement | compound-statement | expression-statement | selection-statement | iteration-statement | jump-statement ;
pointer ::= ("*" type-qualifier-list?) | ("*" type-qualifier-list? pointer) ;
declaration ::= declaration-specifiers init-declarator-list? ";" ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
designation ::= designator-list "=" ;
enumerator ::= enumeration-constant | (enumeration-constant "=" constant-expression) ;
designator ::= ("[" constant-expression "]") | ("." identifier) ;
initializer ::= assignment-expression | ("{" initializer-list "}") | ("{" initializer-list "," "}") ;
declarator ::= pointer? direct-declarator ;
--------------------c::iso-9899-tc2.bgf--------------------
statement ::= labeled-statement | compound-statement | expression-statement | selection-statement | iteration-statement | jump-statement ;
pointer ::= ("*" type-qualifier-list?) | ("*" type-qualifier-list? pointer) ;
declaration ::= declaration-specifiers init-declarator-list? ";" ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
designation ::= designator-list "=" ;
enumerator ::= enumeration-constant | (enumeration-constant "=" constant-expression) ;
designator ::= ("[" constant-expression "]") | ("." identifier) ;
initializer ::= assignment-expression | ("{" initializer-list "}") | ("{" initializer-list "," "}") ;
declarator ::= pointer? direct-declarator ;
--------------------c::iso-9899-tc3.bgf--------------------
statement ::= labeled-statement | compound-statement | expression-statement | selection-statement | iteration-statement | jump-statement ;
pointer ::= ("*" type-qualifier-list?) | ("*" type-qualifier-list? pointer) ;
declaration ::= declaration-specifiers init-declarator-list? ";" ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
designation ::= designator-list "=" ;
enumerator ::= enumeration-constant | (enumeration-constant "=" constant-expression) ;
designator ::= ("[" constant-expression "]") | ("." identifier) ;
initializer ::= assignment-expression | ("{" initializer-list "}") | ("{" initializer-list "," "}") ;
declarator ::= pointer? direct-declarator ;
--------------------c::antoniol.bgf--------------------
ifdef ::= "//"? ifdef_line newline line* elsif_part* else_part? "//"? endifdef_line newline ;
line ::= ifdef | ("//"? other_preprocessor_line newline) | ("//"? any_other_line newline) ;
program ::= line* ;
--------------------c::malton-dahn.bgf--------------------
nonreference ::= nonreferential_primary postfix_extension* ;
slash ::= "/" | "\" | "." | ":" ;
declaration ::= (declaration_body semi) | preprocessor ;
 declaration ::= comment_NL ;
 declaration ::= null_declaration | (declaration_body semi) | preprocessor ;
expression ::= assignment_expression+ ;
 expression ::= comment_NL* "..." ;
designator ::= array_designator | struct_or_union_designator ;
label ::= (label_id ":") | (EX SP SP "case" constant_expression ":" IN NL) | (EX SP SP "default" ":" IN NL) ;
 label ::= (label_id ":" attribute_spec*) | (EX SP SP "case" constant_expression ":" IN NL) | (EX SP SP "case" constant_expression SP "..." SP constant_expression ":" IN NL) | (EX SP SP "default" ":" IN NL) ;
declarator ::= ptr_operator* base_declarator SPON declarator_extension* ;
 declarator ::= attribute_spec* ptr_operator* base_declarator declarator_extension* attribute_spec* ;
string ::= stringlit+ ;
preprocessor ::= ("#define" id "(" id+ ")" expression NL) | ("#define" id expression NL) | (EX "#else" IN NL) | (EX "#endif" NL NL) | (NL "#if" expression IN NL) | (NL "#ifdef" id IN NL) | (NL "#ifndef" id IN NL) | ("#ident" stringlit NL) | ("#include" stringlit NL) | ("#include" "<" SPOFF filepath ">" SPON NL) | ("#line" integernumber stringlit? NL) | ("#undef" id NL) | ("#LINK" stringlit NL) ;
 preprocessor ::= (EX "#endif" comment_NL? NL) | "..." ;
 preprocessor ::= "..." comment_NL? ;
 preprocessor ::= ("#" integernumber string integernumber* NL) | ("#pragma" SPON id* "(" {id ","}* ")" NL) ;
statement ::= (label* unlabeled_statement) | preprocessor ;
 statement ::= comment_NL ;
 statement ::= label ;
bitfieldsize ::= ":" constant_expression ;
semi ::= ";" NL ;
reference ::= reference_id | reference_expression ;
program ::= C_compilation_unit ;
enumerator ::= reference_id enumerator_value? ;
constant ::= number | float | hex | long | (SP dotfloat) | charlit | string ;
 constant ::= gnu_long_int | (gnu_long_int_string+) | hexfloat ;
initializer ::= expression | (NL "{" IN {initializer ","}* ","? EX "}") ;
 initializer ::= comment_NL* "..." ;
 initializer ::= assignment_expression | (NL "{" IN {designated_initializer ","}* ","? EX "}") ;
hexfloat ::= extension_specifier hex ;
filepath ::= file_id slash_fileid* ;
initialization ::= ("=" initializer) | ("(" constant_expression ")") ;
 initialization ::= comment_NL* "..." ;
--------------------c::cordy-malton-dahn.bgf--------------------
asm ::= "__asm__" | "asm" | "asm__" | "__asm" ;
initdata ::= "__initdata" | "__devinitdata" | "__cpuinitdata" | "__read_mostly" | "__initmv" | "__initdata_or_module" | "__pminitdata" | "__cpuinit" | "__devinit" | "BDATA" | "compat_init_data" | "in2000__INITDATA" ;
declaration ::= (decl_specifiers {init_declarator ","}* semi) | (decl_specifiers declarator "=" compound_initializer NL) | extern_langauge_declaration | null_declaration | (local_label declarator+) | asm_spec | machinestart_declaration | preprocessor ;
expression ::= assignment_expression ;
label ::= (EX label_id ":" IN NL) | (EX SP SP "case" constant_expression ":" IN NL) | (EX SP SP "default" ":" IN NL) | (EX SP SP "case" constant_expression SP "..." SP constant_expression ":" IN NL) ;
string ::= (stringlit string_unit*) | (pseudo_string stringlit string_unit*) ;
declarator ::= attribute_spec* ptr_operator* base_declarator SPON declarator_extension* attribute_spec* ;
complex ::= "__complex" | "__complex__" | "__Complex" ;
statement ::= (preprocessor* label* unlabeled_statement) | label | preprocessor ;
preprocessor ::= TAB_1 preprocessor_line NL ;
bitfieldsize ::= ":" constant_expression ;
semi ::= ";" NL ;
dotdotdot ::= SP "..." SP ;
constant ::= number | float | hex | long | (SP dotfloat) | charlit | string | gnu_long_int | gnu_long_int_string | hexfloat ;
enumerator ::= preprocessor* reference_id enumerator_value? ;
program ::= compilation_unit ;
primary ::= reference_id | constant | string | ("(" SPON expression_list ","? ")") | ("{" SPON expression_list ","? "}") | (SPON extension_specifier "(" expression_list ")") | (SPON constructor_expression) | (SPON asm_spec) ;
initializer ::= (preprocessor* initializer_unit+) | (ε initializer_unit) ;
hexfloat ::= extension_specifier hex ;
dotdot ::= SP ".." SP ;
initialization ::= (initdata? "=" initializer) | ("(" constant_expression ")") | macro_call ;
--------------------c::cordy-malton.bgf--------------------
nonreference ::= nonreferential_primary postfix_extension* ;
slash ::= "/" | "\" | "." | ":" ;
declaration ::= (declaration_body semi) | preprocessor ;
expression ::= assignment_expression+ ;
label ::= (label_id ":") | (EX SP SP "case" constant_expression ":" IN NL) | (EX SP SP "default" ":" IN NL) ;
declarator ::= ptr_operator* base_declarator SPON declarator_extension* ;
string ::= stringlit+ ;
preprocessor ::= ("#define" id "(" id+ ")" expression NL) | ("#define" id expression NL) | (EX "#else" IN NL) | (EX "#endif" NL NL) | (NL "#if" expression IN NL) | (NL "#ifdef" id IN NL) | (NL "#ifndef" id IN NL) | ("#ident" stringlit NL) | ("#include" stringlit NL) | ("#include" "<" SPOFF filepath ">" SPON NL) | ("#line" integernumber stringlit? NL) | ("#undef" id NL) | ("#LINK" stringlit NL) ;
statement ::= (label* unlabeled_statement) | preprocessor ;
bitfieldsize ::= ":" constant_expression ;
semi ::= ";" NL ;
reference ::= reference_id | reference_expression ;
program ::= C_compilation_unit ;
enumerator ::= reference_id enumerator_value? ;
constant ::= number | float | hex | long | (SP dotfloat) | charlit | string ;
initializer ::= expression | (NL "{" IN {initializer ","}* ","? EX "}") ;
filepath ::= file_id slash_fileid* ;
initialization ::= ("=" initializer) | ("(" constant_expression ")") ;
--------------------cpp::iso-n2723.bgf--------------------
statement ::= labeled-statement | expression-statement | compound-statement | selection-statement | iteration-statement | jump-statement | declaration-statement | try-block ;
condition ::= expression | (type-specifier-seq declarator "=" initializer-clause) | (type-specifier-seq declarator braced-init-list) ;
handler ::= "catch" "(" exception-declaration ")" compound-statement ;
declaration ::= block-declaration | function-definition | template-declaration | explicit-instantiation | explicit-specialization | linkage-specification | namespace-definition ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
capture ::= identifier | ("&" identifier) | "this" ;
enumerator ::= identifier ;
operator ::= "new" | "delete" | ("new" "[" "]") | ("delete" "[" "]") | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "(" | ")" | "[" | "]" ;
initializer ::= ("=" initializer-clause) | ("(" expression-list ")") | braced-init-list ;
declarator ::= direct-declarator | (ptr-operator declarator) ;
--------------------cpp::elges-cordy.bgf--------------------
literal ::= number_constant | character_constant | string_constant ;
preprocessor ::= ("#define" id "(" id+ ")" expression) | ("#define" id expression) | (EX "#else" IN) | (EX "#endif" NL) | (NL "#if" expression IN) | (NL "#ifdef" id IN) | (NL "#ifndef" id IN) | ("#ident" stringlit) | ("#include" stringlit) | ("#include" "<" SPOFF filename ">" SPON) | ("#line" integernumber stringlit?) | ("#undef" id) | ("#LINK" stringlit) ;
statement ::= label* unlabeled_statement ;
name ::= id | template_class_name | qualified_name | operator_function_name | conversion_function_name ;
handler ::= "catch" "(" exception_declaration ")" compound_statement ;
member ::= access_specifier_colon? member_declaration ;
declaration ::= asm_declaration | class_definition | function_definition | namespace_definition | template_declaration | linkage_specification | exception_specification | using_declaration | (decl_specifiers? declarator_list ";" NL) | (decl_specifiers ";" NL) | (";" NL) | (preprocessor NL) ;
expression ::= assignment_expression | (expression "," assignment_expression) ;
filename ::= file_identifier dot_slash_identifier* ;
placement ::= "(" expression_list ")" ;
label ::= (id SPOFF ":" SPON) | (EX "case" constant_expression SPOFF ":" SPON NL IN) | (EX "default" SPOFF ":" SPON NL IN) ;
operator ::= "new" | "delete" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "-+" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | ("(" type_specifier? ")") | ("[" "]") ;
enumerator ::= id equal_constant_expression? ;
program ::= declaration_list ;
initializer ::= ("=" initial_value) | ("(" expression_list? ")") ;
stars ::= "*" | "**" ;
declarator ::= pointer_operator* declared_item declarator_extension* ;
--------------------cpp::iso-14882-1998.bgf--------------------
statement ::= labeled-statement | expression-statement | compound-statement | selection-statement | iteration-statement | jump-statement | declaration-statement | try-block ;
condition ::= expression | (type-specifier-seq declarator "=" assignment-expression) ;
handler ::= "catch" "(" exception-declaration ")" compound-statement ;
declaration ::= block-declaration | function-definition | template-declaration | explicit-instantiation | explicit-specialization | linkage-specification | namespace-definition ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
enumerator ::= identifier ;
operator ::= "new" | "delete" | ("new" "[" "]") | ("delete" "[" "]") | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | ("(" ")") | ("[" "]") ;
initializer ::= ("=" initializer-clause) | ("(" expression-list ")") ;
declarator ::= direct-declarator | (ptr-operator declarator) ;
--------------------cs::csharp-ecma-334-2.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "while" | "assembly" | "remove" | "get" | "set" | "field" | "method" | "module" | "param" | "property" | "add" | "volatile" ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-ecma-334-3.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
commas ::= "," | (commas ",") ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type | type-parameter ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "volatile" | "while" | "get" | "set" | "yield" | "add" | "remove" | "alias" | "partial" | "where" ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-ecma-334-4.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
commas ::= "," | (commas ",") ;
assignment ::= unary-expression assignment-operator expression ;
block ::= "{" statement-list? "}" ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type | type-parameter ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "volatile" | "while" | "get" | "set" | "yield" | "add" | "remove" | "alias" | "partial" | "where" ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-iso-23270-2003.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-iso-23270-2006.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
commas ::= "," | (commas ",") ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type | type-parameter ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "volatile" | "while" | "yield" | "partial" | "add" | "remove" | "get" | "set" | "where" | "alias" ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-msft-ls-1.0.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-msft-ls-1.2.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------cs::csharp-msft-ls-3.0.bgf--------------------
orderings ::= ordering | (orderings "," ordering) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
commas ::= "," | (commas ",") ;
assignment ::= unary-expression assignment-operator expression ;
block ::= "{" statement-list? "}" ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type | type-parameter ;
expression ::= non-assignment-expression | assignment ;
attributes ::= attribute-sections ;
ordering ::= expression ordering-direction? ;
--------------------cs::csharp-msft-ls-4.0.bgf--------------------
orderings ::= ordering | (orderings "," ordering) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
commas ::= "," | (commas ",") ;
assignment ::= unary-expression assignment-operator expression ;
block ::= "{" statement-list? "}" ;
argument ::= argument-name? argument-value ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type | type-parameter ;
expression ::= non-assignment-expression | assignment ;
attributes ::= attribute-sections ;
ordering ::= expression ordering-direction? ;
--------------------cs::csharp-zaytsev.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
block ::= "{" statement* "}" ;
argument ::= ref-or-out? expression ;
attribute ::= attribute-name attribute-arguments? ;
type ::= non-array-type rank-specifier* ;
expression ::= (expression "?" expression ":" expression) | (expression "||" expression) | (expression "&&" expression) | (expression lex-csharp-extra/bar expression) | (expression "^" expression) | (expression lex-csharp-extra/ampersand expression) | (expression expression-equality-operator expression) | (expression expression-relational-operator expression) | (expression "is" built-in-type) | (expression expression-shift-operator expression) | (expression lex-csharp-extra/plus expression) | (expression lex-csharp-extra/minus expression) | (expression "*" expression) | (expression "/" expression) | (expression "%" expression) | unary-expression | (unary-expression assignment-operator expression) ;
attributes ::= attribute-section* ;
--------------------cs::csharp-antoniol.bgf--------------------
ifdef ::= "//"? ifdef_line newline line* elsif_part* else_part? "//"? endifdef_line newline ;
line ::= ifdef | ("//"? other_preprocessor_line newline) | ("//"? any_other_line newline) ;
program ::= line* ;
--------------------cs::csharp-cordy.bgf--------------------
statement ::= labeled_statement | declaration_statement | embedded_statement ;
literal ::= boolean_literal | integer_literal | real_literal | character_literal | string_literal | null_literal ;
block ::= "{" NL IN statement_list? EX "}" ";"? ;
assignment ::= unary_expression assignment_operator expression ;
argument ::= expression | ("ref" variable_reference) | ("out" variable_reference) ;
attribute ::= attribute_name attribute_arguments? ;
type ::= value_type | reference_type | type_parameter ;
 type ::= pointer_type ;
expression ::= conditional_expression | assignment | query_expression | lambda_expression ;
attributes ::= attribute_sections ;
program ::= compilation_unit ;
--------------------cs::csharp-ecma-334-1.bgf--------------------
statement ::= labeled-statement | declaration-statement | embedded-statement ;
block ::= "{" statement-list? "}" ;
assignment ::= unary-expression assignment-operator expression ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
attribute ::= attribute-name attribute-arguments? ;
type ::= value-type | reference-type ;
expression ::= conditional-expression | assignment ;
attributes ::= attribute-sections ;
--------------------dart::spec-0.01.bgf--------------------
selector ::= assignableSelector | arguments ;
superclass ::= "extends" type ;
qualified ::= identifier ("." identifier)? ;
type ::= qualified typeArguments? ;
interfaces ::= "implements" typeList ;
declaration ::= (constantConstructorSignature (redirection | initializers)?) | (constructorSignature (redirection | initializers)?) | (functionSignature redirection) | (namedConstructorSignature redirection) | ("abstract" getterSignature) | ("abstract" setterSignature) | ("abstract" operatorSignature) | ("abstract" functionSignature) | ("static" "final" type? staticFinalDeclarationList) | ("static"? initializedVariableDeclaration) ;
expression ::= (assignableExpression assignmentOperator expression) | conditionalExpression ;
arguments ::= "(" argumentList? ")" ;
superinterfaces ::= "extends" typeList ;
label ::= identifier ":" ;
initializers ::= ":" superCallOrFieldInitializer ("," superCallOrFieldInitializer)* ;
statement ::= label* nonLabelledStatement ;
literal ::= nullLiteral | booleanLiteral | numericLiteral | stringLiteral | mapLiteral | listLiteral ;
resource ::= "#" "resource" "(" stringLiteral ")" ";" ;
block ::= "{" statements "}" ;
redirection ::= ":" "this" ("." identifier)? arguments ;
identifier ::= IDENTIFIER_NO_DOLLAR | IDENTIFIER | BUILT_IN_IDENTIFIER ;
include ::= "#" "source" "(" stringLiteral ")" ";" ;
statements ::= statement* ;
operator ::= unaryOperator | binaryOperator | "[]" | "[]=" | "negate" ;
primary ::= thisExpression | ("super" assignableSelector) | functionExpression | literal | identifier | (newExpression constantObjectExpression) | ("(" expression ")") ;
--------------------dart::google.bgf--------------------
selector ::= assignableSelector | arguments ;
superclass ::= EXTENDS type ;
qualified ::= identifier ("." identifier)? ;
declaration ::= (constantConstructorDeclaration (redirection | initializers)?) | (functionDeclaration redirection) | (namedConstructorDeclaration redirection) | (ABSTRACT specialSignatureDefinition) | (ABSTRACT functionDeclaration) | (STATIC FINAL type? staticFinalDeclarationList) | (STATIC? constInitializedVariableDeclaration) ;
interfaces ::= IMPLEMENTS typeList ;
type ::= qualified typeArguments? ;
expression ::= (assignableExpression assignmentOperator expression) | conditionalExpression ;
arguments ::= "(" argumentList? ")" ;
superinterfaces ::= EXTENDS typeList ;
label ::= identifier ":" ;
initializers ::= ":" superCallOrFieldInitializer ("," superCallOrFieldInitializer)* ;
statement ::= label* nonLabelledStatement ;
literal ::= NULL | TRUE | FALSE | HEX_NUMBER | NUMBER | STRING ;
directive ::= "#" identifier arguments ";" ;
block ::= "{" statements "}" ;
redirection ::= ":" THIS ("." identifier)? arguments ;
identifier ::= IDENTIFIER_NO_DOLLAR | IDENTIFIER | ABSTRACT | ASSERT | CLASS | EXTENDS | FACTORY | GET | IMPLEMENTS | IMPORT | INTERFACE | IS | LIBRARY | NATIVE | NEGATE | OPERATOR | SET | SOURCE | STATIC | TYPEDEF ;
statements ::= statement* ;
primary ::= primaryNoFE | primaryFE ;
--------------------dart::spec-0.05.bgf--------------------
selector ::= assignableSelector | arguments ;
superclass ::= "extends" type ;
qualified ::= identifier ("." identifier)? ;
type ::= qualified typeArguments? ;
interfaces ::= "implements" typeList ;
declaration ::= (constantConstructorSignature (redirection | initializers)?) | (functionSignature redirection) | (namedConstructorSignature redirection) | ("abstract" getterSignature) | ("abstract" setterSignature) | ("abstract" operatorSignature) | ("abstract" functionSignature) | ("static" "final" type? staticFinalDeclarationList) | ("static"? initializedVariableDeclaration) ;
expression ::= (assignableExpression assignmentOperator expression) | conditionalExpression ;
arguments ::= "(" argumentList? ")" ;
superinterfaces ::= "extends" typeList ;
label ::= identifier ":" ;
initializers ::= ":" superCallOrFieldInitializer ("," superCallOrFieldInitializer)* ;
statement ::= label* nonLabelledStatement ;
literal ::= nullLiteral | booleanLiteral | numericLiteral | stringLiteral | mapLiteral | listLiteral ;
resource ::= "#" "resource" "(" stringLiteral ")" ";" ;
block ::= "{" statements "}" ;
redirection ::= ":" "this" ("." identifier)? arguments ;
identifier ::= IDENTIFIER_NO_DOLLAR | IDENTIFIER | BUILT_IN_IDENTIFIER ;
include ::= "#" "source" "(" stringLiteral ")" ";" ;
import ::= "#" "import" "(" stringLiteral ("," "prefix:" stringLiteral)? ")" ";" ;
statements ::= statement* ;
operator ::= unaryOperator | binaryOperator | ("[" "]") | ("[" "]" "=") | "negate" ;
primary ::= thisExpression | ("super" assignableSelector) | functionExpression | literal | identifier | newExpression | constantObjectExpression | ("(" expression ")") ;
--------------------eiffel::cordy.bgf--------------------
program ::= Class_declaration* ;
--------------------fortran::waite-cordy.bgf--------------------
program ::= IN_6 CommentOrNewline* ExecutableProgram CommentOrNewline* EX_6 ;
--------------------java::java-5-habelitz.bgf--------------------
statement ::= block | (ASSERT expr1::expression (COLON expr2::expression SEMI) | SEMI) | (IF parenthesizedExpression ifStat::statement (ELSE elseStat::statement) | ε) | (FOR LPAREN (forInit SEMI forCondition SEMI forUpdater RPAREN statement) | (localModifierList type IDENT COLON expression RPAREN statement)) | (WHILE parenthesizedExpression statement) | (DO statement WHILE parenthesizedExpression SEMI) | (TRY block (catches finallyClause?) | finallyClause) | (SWITCH parenthesizedExpression LCURLY switchBlockLabels RCURLY) | (SYNCHRONIZED parenthesizedExpression block) | (RETURN expression? SEMI) | (THROW expression SEMI) | (BREAK IDENT? SEMI) | (CONTINUE IDENT? SEMI) | (IDENT COLON statement) | (expression SEMI) | SEMI ;
literal ::= HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | FLOATING_POINT_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | TRUE | FALSE | NULL ;
annotation ::= AT qualifiedIdentifier annotationInit? ;
bound ::= EXTENDS type (AND type)* ;
block ::= LCURLY blockStatement* RCURLY ;
type ::= simpleType | objectType ;
catches ::= catchClause+ ;
expression ::= assignmentExpression ;
modifier ::= PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP | localModifier ;
arguments ::= LPAREN expressionList? RPAREN ;
--------------------java::java-5-parr.bgf--------------------
selector ::= ("." Identifier arguments?) | ("." "this") | ("." "super" superSuffix) | ("." "new" innerCreator) | ("[" expression "]") ;
literal ::= integerLiteral | FloatingPointLiteral | CharacterLiteral | StringLiteral | booleanLiteral | "null" ;
statement ::= block | (ASSERT expression (":" expression)? ";") | ("if" parExpression statement ("else" statement)?) | ("for" "(" forControl ")" statement) | ("while" parExpression statement) | ("do" statement "while" parExpression ";") | ("try" block (catches "finally" block) | catches | ("finally" block)) | ("switch" parExpression "{" switchBlockStatementGroups "}") | ("synchronized" parExpression block) | ("return" expression? ";") | ("throw" expression ";") | ("break" Identifier? ";") | ("continue" Identifier? ";") | ";" | (statementExpression ";") | (Identifier ":" statement) ;
annotation ::= "@" annotationName ("(" (elementValuePairs | elementValue)? ")")? ;
block ::= "{" blockStatement* "}" ;
creator ::= (nonWildcardTypeArguments createdName classCreatorRest) | (createdName arrayCreatorRest | classCreatorRest) ;
modifiers ::= modifier* ;
type ::= (classOrInterfaceType ("[" "]")*) | (primitiveType ("[" "]")*) ;
catches ::= catchClause catchClause* ;
expression ::= conditionalExpression (assignmentOperator expression)? ;
modifier ::= annotation | "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "transient" | "volatile" | "strictfp" ;
arguments ::= "(" expressionList? ")" ;
annotations ::= annotation+ ;
primary ::= parExpression | ("this" ("." Identifier)* identifierSuffix?) | ("super" superSuffix) | literal | ("new" creator) | (Identifier ("." Identifier)* identifierSuffix?) | (primitiveType ("[" "]")* "." "class") | ("void" "." "class") ;
--------------------java::java-5-stahl.bgf--------------------
statement ::= compoundStatement | (declaration SEMI) | (expression SEMI) | (m::modifiers enumDefinition | classDefinition) | (IDENT c::COLON statement) | ("if" LPAREN expression RPAREN statement ("else" statement)?) | ("for" LPAREN (parameterDeclaration COLON expression) | (forInit SEMI forCond SEMI forIter) RPAREN statement) | ("while" LPAREN expression RPAREN statement) | ("do" statement "while" LPAREN expression RPAREN SEMI) | ("break" IDENT? SEMI) | ("continue" IDENT? SEMI) | ("return" expression? SEMI) | ("switch" LPAREN expression RPAREN LCURLY casesGroup* RCURLY) | tryBlock | ("throw" expression SEMI) | ("synchronized" LPAREN expression RPAREN compoundStatement) | (ASSERT expression (COLON expression)? SEMI) | (s::SEMI) ;
annotation ::= AT identifier annotationInit ;
modifiers ::= (modifier | annotation)* ;
handler ::= "catch" LPAREN parameterDeclaration RPAREN compoundStatement ;
declaration ::= m::modifiers t::typeSpec v::variableDefinitions ;
type ::= classOrInterfaceType | builtInType ;
identifier ::= IDENT (DOT IDENT)* ;
expression ::= assignmentExpression ;
modifier ::= "private" | "public" | "protected" | "static" | "transient" | "final" | "abstract" | "native" | "threadsafe" | "synchronized" | "volatile" | "strictfp" ;
constant ::= NUM_INT | CHAR_LITERAL | STRING_LITERAL | NUM_FLOAT | NUM_LONG | NUM_DOUBLE ;
annotations ::= annotation* ;
initializer ::= expression | arrayInitializer ;
--------------------java::java-5-studman.bgf--------------------
statement ::= compoundStatement | (declaration SEMI) | (expression SEMI) | (m::modifiers classDefinition) | (IDENT c::COLON statement) | ("if" LPAREN expression RPAREN statement ("else" statement)?) | forStatement | ("while" LPAREN expression RPAREN statement) | ("do" statement "while" LPAREN expression RPAREN SEMI) | ("break" IDENT? SEMI) | ("continue" IDENT? SEMI) | ("return" expression? SEMI) | ("switch" LPAREN expression RPAREN LCURLY casesGroup* RCURLY) | tryBlock | ("throw" expression SEMI) | ("synchronized" LPAREN expression RPAREN compoundStatement) | ("assert" expression (COLON expression)? SEMI) | (s::SEMI) ;
annotation ::= AT i::identifier (LPAREN (args::annotationArguments)? RPAREN)? ;
modifiers ::= (modifier | annotation)* ;
handler ::= "catch" LPAREN parameterDeclaration RPAREN compoundStatement ;
declaration ::= m::modifiers t::typeSpec v::variableDefinitions ;
type ::= classOrInterfaceType | builtInType ;
identifier ::= IDENT (DOT IDENT)* ;
expression ::= assignmentExpression ;
modifier ::= "private" | "public" | "protected" | "static" | "transient" | "final" | "abstract" | "native" | "threadsafe" | "synchronized" | "volatile" | "strictfp" ;
constant ::= NUM_INT | CHAR_LITERAL | STRING_LITERAL | NUM_FLOAT | NUM_LONG | NUM_DOUBLE ;
annotations ::= annotation* ;
initializer ::= expression | arrayInitializer ;
--------------------java::java-1-cordy-guo.bgf--------------------
literal ::= numeric_literal | character_literal | string_literal | boolean_literal | null_literal ;
statement ::= label_statement | empty_statement | expression_statement | if_statement | switch_statement | while_statement | do_statement | for_statement | break_statement | continue_statement | return_statement | throw_statement | synchronized_statement | try_statement | block ;
component ::= dot_id | method_argument | subscript ;
argument ::= expression ;
block ::= "{" NL IN declaration_or_statement* EX "}" ;
throws ::= "throws" qualified_name+ ;
reference ::= id component* ;
subscript ::= "[" expression "]" ;
expression ::= assignment_expression ;
modifier ::= "abstract" | "final" | "public" | "protected" | "private" | "static" | "transient" | "volatile" | "native" | "synchronized" | "strictfp" ;
dimension ::= "[" expression? "]" ;
program ::= package_declaration ;
primary ::= literal | reference | ("(" expression ")" component*) | class_instance_creation_expression | array_creation_expression ;
--------------------java::java-5-cordy-guo-dean.bgf--------------------
literal ::= numeric_literal | character_literal | string_literal | boolean_literal | null_literal ;
statement ::= label_statement | empty_statement | expression_statement | if_statement | switch_statement | while_statement | do_statement | for_statement | (for_in_statement) | break_statement | continue_statement | return_statement | throw_statement | synchronized_statement | try_statement | (assert_statement) | block ;
annotation ::= SPOFF "@" reference "@"? SPON annotation_value_spec? NL ;
component ::= dot_id | method_argument | subscript | (generic_argument) | (class_instance_creation_expression) | (dimension) ;
argument ::= expression | type_specifier ;
block ::= "{" NL IN declaration_or_statement* EX "}" ;
throws ::= "throws" qualified_name+ ;
reference ::= (id component*) | (primitive_type component*) ;
subscript ::= "[" expression "]" ;
declaration ::= local_variable_declaration | class_declaration ;
expression ::= assignment_expression ;
modifier ::= "abstract" | "final" | "public" | "protected" | "private" | "static" | "transient" | "volatile" | "native" | "synchronized" | ("strictfp") | (annotation) ;
dimension ::= "[" expression? "]" ;
program ::= package_declaration ;
primary ::= (literal component*) | reference | ("(" expression ")" component*) | (class_instance_creation_expression component*) | (array_creation_expression component*) ;
--------------------modula::dagenais-cordy.bgf--------------------
program ::= Interface | Module | GInterface | GModule | IInterface | IModule ;
--------------------assembly::delphi.bgf--------------------
asmlabel ::= (SPOFF asmid+ SPON) | label_id ;
asmid ::= ("@"* asmlbl) | ("@+"* id) | ("@+"* anynumber) | ("@+"* key) ;
asmhex ::= number SPOFF id SPON ;
--------------------basic::vb6-cordy.bgf--------------------
statement ::= label_statement | assignment_statement | app_activate_statement | attribute_statement | beep_statement | call_statement | chdir_statement | chdrive_statement | close_statement | date_statement | deletesetting_statement | do_statement | end_statement | erase_statement | error_statement | event_statement | exit_statement | filecopy_statement | for_each_statement | for_next_statement | get_statement | gosub_statement | return_statement | goto_statement | if_statement | input_statement | kill_statement | line_input_statement | load_statement | lock_statement | lset_statement | mid_statement | mkdir_statement | name_statement | on_error_statement | open_statement | option_statement | preprocessor_if_statement | print_statement | property_statement | put_statement | randomize_statement | reset_statement | resume_statement | rmdir_statement | rset_statement | savepicture_statement | savesetting_statement | select_case_statement | set_statement | stop_statement | time_statement | unload_statement | unlock_statement | while_statement | with_statement | width_statement | write_statement ;
charpos ::= expn | ";" ;
lock ::= "shared" | ("lock" "read") | ("lock" "write") | ("lock" "read" "write") ;
subscript ::= "(" {optional_subscript ","}* ")" ;
reference ::= ("."? "!"? id component_selector*) | ("." key component_selector*) ;
drive ::= id ":" ;
declaration ::= variable_declaration | implements_declaration | subprogram_declaration | constant_declaration | class_declaration | declare_subprogram_declaration | defletter_declaration | enum_declaration | type_declaration ;
parens ::= "(" ")" ;
letterrange ::= id SPOFF "-" id SPON ;
filenumber ::= "#" primary ;
program ::= class_file_header? declaration_or_statement* ;
mode ::= "append" | "binary" | "input" | "output" | "random" ;
eol ::= (tab_vbcomment? newline) | ":" ;
primary ::= reference | stringlit | number | hexnumber | octnumber | datelit | returncode | filenumber | (prefix_op primary) | ("(" {expn ","}* ")") ;
filepath ::= (drive? id slash_id*) | stringlit ;
op ::= "^" | "*" | "/" | "\" | "mod" | "+" | "-" | "&" | "=" | "<>" | "<=" | ">=" | ":=" | ">" | "<" | "!" | "is" | "not" | "and" | "or" | "xor" | "eqv" | "imp" | "like" ;
expn ::= primary operator_primary* ;
--------------------html::clark-basic.bgf--------------------
object ::= object::(object.attlist param* Flow.model) ;
tr ::= tr::(tr.attlist (th | td)+) ;
li ::= li::(li.attlist Flow.model) ;
select ::= select::(select.attlist option+) ;
textarea ::= textarea::textarea.attlist ;
link ::= link::link.attlist ;
option ::= option::(Common.attrib (selected::"selected")? (value::string())? string()) ;
address ::= address::(address.attlist Inline.model) ;
th ::= th::(th.attlist Flow.model) ;
label ::= label::(label.attlist Inline.model) ;
samp ::= samp::(samp.attlist Inline.model) ;
q ::= q::(q.attlist Inline.model) ;
abbr ::= abbr::(abbr.attlist Inline.model) ;
p ::= p::(p.attlist Inline.model) ;
td ::= td::(td.attlist Flow.model) ;
kbd ::= kbd::(kbd.attlist Inline.model) ;
code ::= code::(code.attlist Inline.model) ;
dfn ::= dfn::(dfn.attlist Inline.model) ;
html ::= html::(html.attlist head body) ;
em ::= em::(em.attlist Inline.model) ;
var ::= var::(var.attlist Inline.model) ;
caption ::= caption::(caption.attlist Inline.model) ;
pre ::= pre::(pre.attlist Inline.model) ;
body ::= body::(body.attlist Block.model) ;
a ::= a::(a.attlist Inline.model) ;
head ::= head::(head.attlist head.content) ;
ol ::= ol::(ol.attlist li+) ;
title ::= title::(title.attlist string()) ;
strong ::= strong::(strong.attlist Inline.model) ;
cite ::= cite::(cite.attlist Inline.model) ;
ul ::= ul::(ul.attlist li+) ;
div ::= div::(div.attlist Flow.model) ;
base ::= base::base.attlist ;
br ::= br::br.attlist ;
dt ::= dt::(dt.attlist Inline.model) ;
blockquote ::= blockquote::(blockquote.attlist Block.model) ;
table ::= table::(table.attlist caption? tr+) ;
param ::= param::param.attlist ;
span ::= span::(span.attlist Inline.model) ;
input ::= input::input.attlist ;
dl ::= dl::(dl.attlist (dt | dd)+) ;
meta ::= meta::meta.attlist ;
form ::= form::(form.attlist Block.class+) ;
acronym ::= acronym::(acronym.attlist Inline.model) ;
img ::= img::img.attlist ;
dd ::= dd::(dd.attlist Flow.model) ;
--------------------html::clark.bgf--------------------
colgroup ::= colgroup::(colgroup.attlist col*) ;
tr ::= tr::(tr.attlist (th | td)+) ;
li ::= li::(li.attlist Flow.model) ;
select ::= select::(select.attlist (option | optgroup)+) ;
 select ::= select::(select.attlist option+) ;
link ::= link::link.attlist ;
u ::= u::(u.attlist Inline.model) ;
option ::= option::(Common.attrib (selected::"selected")? (value::string())? string()) ;
address ::= address::(address.attlist Inline.model) ;
th ::= th::(th.attlist Flow.model) ;
label ::= label::(label.attlist Inline.model) ;
s ::= s::(s.attlist Inline.model) ;
samp ::= samp::(samp.attlist Inline.model) ;
q ::= q::(q.attlist Inline.model) ;
p ::= p::(p.attlist Inline.model) ;
td ::= td::(td.attlist Flow.model) ;
ins ::= ins::(ins.attlist Inline.model) ;
kbd ::= kbd::(kbd.attlist Inline.model) ;
code ::= code::(code.attlist Inline.model) ;
frame ::= frame::frame.attlist ;
bdo ::= bdo::(bdo.attlist Inline.model) ;
i ::= i::(i.attlist Inline.model) ;
isindex ::= isindex::isindex.attlist ;
caption ::= caption::(caption.attlist Inline.model) ;
tfoot ::= tfoot::(tfoot.attlist tr+) ;
b ::= b::(b.attlist Inline.model) ;
a ::= a::(a.attlist Inline.model) ;
head ::= head::(head.attlist head.content) ;
menu ::= menu::(menu.attlist li.noblock+) ;
ol ::= ol::(ol.attlist li+) ;
map ::= map::(map.attlist (Block.class | area)+) ;
applet ::= applet::(applet.attlist param* Flow.model) ;
title ::= title::(title.attlist string()) ;
cite ::= cite::(cite.attlist Inline.model) ;
frameset ::= frameset::(frameset.attlist (frameset | frame)+ noframes?) ;
 frameset ::= body ;
center ::= center::(center.attlist Flow.model) ;
thead ::= thead::(thead.attlist tr+) ;
base ::= base::base.attlist ;
br ::= br::br.attlist ;
font ::= font::(font.attlist Inline.model) ;
table ::= table::(table.attlist caption? (col*) | (colgroup*) (thead? tfoot? tbody+) | (tr+)) ;
 table ::= table::(table.attlist caption? tr+) ;
sup ::= sup::(sup.attlist Inline.model) ;
noscript ::= noscript::(noscript.attlist Block.model) ;
script ::= script::(script.attlist string()) ;
span ::= span::(span.attlist Inline.model) ;
input ::= input::input.attlist ;
form ::= form::(form.attlist Block.class+) ;
acronym ::= acronym::(acronym.attlist Inline.model) ;
img ::= img::img.attlist ;
sub ::= sub::(sub.attlist Inline.model) ;
object ::= object::(object.attlist param* Flow.model) ;
textarea ::= textarea::textarea.attlist ;
strike ::= strike::(strike.attlist Inline.model) ;
button ::= button::(button.attlist Flow.model) ;
abbr ::= abbr::(abbr.attlist Inline.model) ;
style ::= style::(style.attlist string()) ;
dfn ::= dfn::(dfn.attlist Inline.model) ;
optgroup ::= optgroup::(optgroup.attlist option+) ;
html ::= html::(html.attlist head frameset) ;
 html ::= html::(html.attlist head body) ;
em ::= em::(em.attlist Inline.model) ;
fieldset ::= fieldset::(fieldset.attlist legend Flow.model) ;
var ::= var::(var.attlist Inline.model) ;
noframes ::= noframes::(noframes.attlist body) ;
iframe ::= iframe::(iframe.attlist Flow.model) ;
pre ::= pre::(pre.attlist Inline.model) ;
body ::= body::(body.attlist Block.model) ;
basefont ::= basefont::basefont.attlist ;
strong ::= strong::(strong.attlist Inline.model) ;
ul ::= ul::(ul.attlist li+) ;
tbody ::= tbody::(tbody.attlist tr+) ;
div ::= div::(div.attlist Flow.model) ;
dt ::= dt::(dt.attlist Inline.model) ;
blockquote ::= blockquote::(blockquote.attlist Block.model) ;
param ::= param::param.attlist ;
area ::= area::area.attlist ;
legend ::= legend::(legend.attlist Inline.model) ;
dir ::= dir::(dir.attlist li.noblock+) ;
del ::= del::(del.attlist Inline.model) ;
hr ::= hr::hr.attlist ;
dl ::= dl::(dl.attlist (dt | dd)+) ;
small ::= small::(small.attlist Inline.model) ;
meta ::= meta::meta.attlist ;
tt ::= tt::(tt.attlist Inline.model) ;
col ::= col::col.attlist ;
big ::= big::(big.attlist Inline.model) ;
dd ::= dd::(dd.attlist Flow.model) ;
--------------------html::cordy.bgf--------------------
text ::= text_unit+ NL ;
attribute ::= SP attribute_id equals_attribute_value? ;
element ::= singleton_tag | tag | text | comment_tag | tag_beg | tag_end ;
tag ::= "<" id attributes ">" NL IN tag_elements EX "</" id ">" NL ;
attributes ::= SPOFF attribute* SPON ;
program ::= element* ;
--------------------html::guyard.bgf--------------------
block ::= Heading ;
 block ::= Lists ;
 block ::= Blocktext ;
 block ::= Fieldset ;
inline ::= Special ;
 inline ::= Fontstyle ;
 inline ::= Phrase ;
 inline ::= Inlineforms ;
--------------------html::clark-strict.bgf--------------------
colgroup ::= colgroup::(colgroup.attlist col*) ;
tr ::= tr::(tr.attlist (th | td)+) ;
li ::= li::(li.attlist Flow.model) ;
select ::= select::(select.attlist (option | optgroup)+) ;
 select ::= select::(select.attlist option+) ;
link ::= link::link.attlist ;
option ::= option::(Common.attrib (selected::"selected")? (value::string())? string()) ;
address ::= address::(address.attlist Inline.model) ;
th ::= th::(th.attlist Flow.model) ;
label ::= label::(label.attlist Inline.model) ;
samp ::= samp::(samp.attlist Inline.model) ;
q ::= q::(q.attlist Inline.model) ;
p ::= p::(p.attlist Inline.model) ;
td ::= td::(td.attlist Flow.model) ;
ins ::= ins::(ins.attlist Inline.model) ;
kbd ::= kbd::(kbd.attlist Inline.model) ;
code ::= code::(code.attlist Inline.model) ;
bdo ::= bdo::(bdo.attlist Inline.model) ;
i ::= i::(i.attlist Inline.model) ;
caption ::= caption::(caption.attlist Inline.model) ;
tfoot ::= tfoot::(tfoot.attlist tr+) ;
b ::= b::(b.attlist Inline.model) ;
a ::= a::(a.attlist Inline.model) ;
head ::= head::(head.attlist head.content) ;
ol ::= ol::(ol.attlist li+) ;
map ::= map::(map.attlist (Block.class | area)+) ;
applet ::= applet::(applet.attlist param* Flow.model) ;
title ::= title::(title.attlist string()) ;
cite ::= cite::(cite.attlist Inline.model) ;
thead ::= thead::(thead.attlist tr+) ;
base ::= base::base.attlist ;
br ::= br::br.attlist ;
table ::= table::(table.attlist caption? (col*) | (colgroup*) (thead? tfoot? tbody+) | (tr+)) ;
 table ::= table::(table.attlist caption? tr+) ;
sup ::= sup::(sup.attlist Inline.model) ;
noscript ::= noscript::(noscript.attlist Block.model) ;
script ::= script::(script.attlist string()) ;
span ::= span::(span.attlist Inline.model) ;
input ::= input::input.attlist ;
form ::= form::(form.attlist Block.class+) ;
acronym ::= acronym::(acronym.attlist Inline.model) ;
img ::= img::img.attlist ;
sub ::= sub::(sub.attlist Inline.model) ;
object ::= object::(object.attlist param* Flow.model) ;
textarea ::= textarea::textarea.attlist ;
button ::= button::(button.attlist Flow.model) ;
abbr ::= abbr::(abbr.attlist Inline.model) ;
style ::= style::(style.attlist string()) ;
dfn ::= dfn::(dfn.attlist Inline.model) ;
optgroup ::= optgroup::(optgroup.attlist option+) ;
html ::= html::(html.attlist head body) ;
em ::= em::(em.attlist Inline.model) ;
fieldset ::= fieldset::(fieldset.attlist legend Flow.model) ;
var ::= var::(var.attlist Inline.model) ;
iframe ::= iframe::(iframe.attlist Flow.model) ;
pre ::= pre::(pre.attlist Inline.model) ;
body ::= body::(body.attlist Block.model) ;
strong ::= strong::(strong.attlist Inline.model) ;
ul ::= ul::(ul.attlist li+) ;
tbody ::= tbody::(tbody.attlist tr+) ;
div ::= div::(div.attlist Flow.model) ;
dt ::= dt::(dt.attlist Inline.model) ;
blockquote ::= blockquote::(blockquote.attlist Block.model) ;
area ::= area::area.attlist ;
legend ::= legend::(legend.attlist Inline.model) ;
param ::= param::param.attlist ;
del ::= del::(del.attlist Inline.model) ;
hr ::= hr::hr.attlist ;
dl ::= dl::(dl.attlist (dt | dd)+) ;
small ::= small::(small.attlist Inline.model) ;
meta ::= meta::meta.attlist ;
tt ::= tt::(tt.attlist Inline.model) ;
col ::= col::col.attlist ;
big ::= big::(big.attlist Inline.model) ;
dd ::= dd::(dd.attlist Flow.model) ;
--------------------javascript::synytskyy-cordy.bgf--------------------
program ::= js_program ;
--------------------occam::mu-mitchell.bgf--------------------
statement ::= labeled-statement expression-statement compound-statement selection-statement iteration-statement jump-statement declaration-statement try-block ;
condition ::= expression type-specifier-seq declarator "=" assignment-expression ;
handler ::= "catch" "(" exception-declaration ")" compound-statement ;
declaration ::= block-declaration function-definition template-declaration explicit-instantiation explicit-specialization linkage-specification namespace-definition ;
expression ::= assignment-expression expression "," assignment-expression ;
operator ::= "new" | "delete" | ("new" "[]") | ("delete" "[]") | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "()" | "[]" ;
enumerator ::= identifier ;
initializer ::= "=" initializer-clause "(" expression-list ")" ;
declarator ::= direct-declarator ptr-operator declarator ;
--------------------odf::opendoc-1.0-manifest.bgf--------------------
algorithm ::= manifest:algorithm::algorithm-attlist ;
manifest ::= manifest:manifest::(file-entry+) ;
--------------------odf::opendoc-1.0-strict.bgf--------------------
integer ::= integer() ;
selected ::= (form:selected::boolean)? ;
types ::= "submit" | "reset" | "push" | "url" ;
coordinate ::= length ;
language ::= string() ;
controls ::= column-controls ;
 controls ::= form:password::(form-password-attlist common-form-control-content) ;
 controls ::= form:file::(form-file-attlist common-form-control-content) ;
 controls ::= form:time::(form-time-attlist common-numeric-control-attlist common-form-control-content) ;
 controls ::= form:fixed-text::(form-fixed-text-attlist common-form-control-content) ;
 controls ::= form:button::(form-button-attlist common-form-control-content) ;
 controls ::= form:image::(form-image-attlist common-form-control-content) ;
 controls ::= form:radio::(form-radio-attlist common-form-control-content) ;
 controls ::= form:frame::(form-frame-attlist common-form-control-content) ;
 controls ::= form:image-frame::(form-image-frame-attlist common-form-control-content) ;
 controls ::= form:hidden::(form-hidden-attlist common-form-control-content) ;
 controls ::= form:grid::(form-grid-attlist common-form-control-content form-column*) ;
 controls ::= form:value-range::(form-value-range-attlist common-form-control-content) ;
 controls ::= form:generic-control::(form-generic-control-attlist common-form-control-content) ;
distance ::= length ;
duration ::= string() ;
label ::= (form:label::string)? ;
navigation ::= "none" | "current" | "parent" ;
dropdown ::= (form:dropdown::boolean)? ;
string ::= string() ;
double ::= string() ;
date ::= string() ;
time ::= string() ;
character ::= string() ;
for ::= (form:for::string)? ;
boolean ::= "true" | "false" ;
formula ::= string() ;
length ::= string() ;
percent ::= string() ;
points ::= string() ;
color ::= string() ;
states ::= "unchecked" | "checked" | "unknown" ;
styles ::= style-style* text-list-style* number-number-style* number-currency-style* number-percentage-style* number-date-style* number-time-style* number-boolean-style* number-text-style* ;
size ::= (form:size::nonNegativeInteger)? ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
--------------------odf::opendoc-1.0.bgf--------------------
integer ::= integer() ;
selected ::= (form:selected::boolean)? ;
types ::= "submit" | "reset" | "push" | "url" ;
coordinate ::= length ;
language ::= string() ;
controls ::= column-controls ;
 controls ::= form:password::(form-password-attlist common-form-control-content) ;
 controls ::= form:file::(form-file-attlist common-form-control-content) ;
 controls ::= form:time::(form-time-attlist common-numeric-control-attlist common-form-control-content) ;
 controls ::= form:fixed-text::(form-fixed-text-attlist common-form-control-content) ;
 controls ::= form:button::(form-button-attlist common-form-control-content) ;
 controls ::= form:image::(form-image-attlist common-form-control-content) ;
 controls ::= form:radio::(form-radio-attlist common-form-control-content) ;
 controls ::= form:frame::(form-frame-attlist common-form-control-content) ;
 controls ::= form:image-frame::(form-image-frame-attlist common-form-control-content) ;
 controls ::= form:hidden::(form-hidden-attlist common-form-control-content) ;
 controls ::= form:grid::(form-grid-attlist common-form-control-content form-column*) ;
 controls ::= form:value-range::(form-value-range-attlist common-form-control-content) ;
 controls ::= form:generic-control::(form-generic-control-attlist common-form-control-content) ;
distance ::= length ;
duration ::= string() ;
label ::= (form:label::string)? ;
navigation ::= "none" | "current" | "parent" ;
dropdown ::= (form:dropdown::boolean)? ;
string ::= string() ;
double ::= string() ;
date ::= string() ;
time ::= string() ;
character ::= string() ;
for ::= (form:for::string)? ;
boolean ::= "true" | "false" ;
formula ::= string() ;
length ::= string() ;
percent ::= string() ;
points ::= string() ;
color ::= string() ;
states ::= "unchecked" | "checked" | "unknown" ;
styles ::= style-style* text-list-style* number-number-style* number-currency-style* number-percentage-style* number-date-style* number-time-style* number-boolean-style* number-text-style* ;
size ::= (form:size::nonNegativeInteger)? ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
--------------------odf::opendoc-1.1-manifest.bgf--------------------
algorithm ::= manifest:algorithm::algorithm-attlist ;
manifest ::= manifest:manifest::(file-entry+) ;
--------------------odf::opendoc-1.1-strict.bgf--------------------
integer ::= integer() ;
selected ::= (form:selected::boolean)? ;
types ::= "submit" | "reset" | "push" | "url" ;
coordinate ::= length ;
language ::= string() ;
controls ::= column-controls ;
 controls ::= form:password::(form-password-attlist common-form-control-content) ;
 controls ::= form:file::(form-file-attlist common-form-control-content) ;
 controls ::= form:time::(form-time-attlist common-numeric-control-attlist common-form-control-content) ;
 controls ::= form:fixed-text::(form-fixed-text-attlist common-form-control-content) ;
 controls ::= form:button::(form-button-attlist common-form-control-content) ;
 controls ::= form:image::(form-image-attlist common-form-control-content) ;
 controls ::= form:radio::(form-radio-attlist common-form-control-content) ;
 controls ::= form:frame::(form-frame-attlist common-form-control-content) ;
 controls ::= form:image-frame::(form-image-frame-attlist common-form-control-content) ;
 controls ::= form:hidden::(form-hidden-attlist common-form-control-content) ;
 controls ::= form:grid::(form-grid-attlist common-form-control-content form-column*) ;
 controls ::= form:value-range::(form-value-range-attlist common-form-control-content) ;
 controls ::= form:generic-control::(form-generic-control-attlist common-form-control-content) ;
distance ::= length ;
duration ::= string() ;
label ::= (form:label::string)? ;
navigation ::= "none" | "current" | "parent" ;
dropdown ::= (form:dropdown::boolean)? ;
string ::= string() ;
double ::= string() ;
date ::= string() ;
time ::= string() ;
character ::= string() ;
for ::= (form:for::string)? ;
boolean ::= "true" | "false" ;
formula ::= string() ;
length ::= string() ;
percent ::= string() ;
points ::= string() ;
color ::= string() ;
states ::= "unchecked" | "checked" | "unknown" ;
styles ::= style-style* text-list-style* number-number-style* number-currency-style* number-percentage-style* number-date-style* number-time-style* number-boolean-style* number-text-style* ;
size ::= (form:size::nonNegativeInteger)? ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
--------------------odf::opendoc-1.1.bgf--------------------
integer ::= integer() ;
selected ::= (form:selected::boolean)? ;
types ::= "submit" | "reset" | "push" | "url" ;
coordinate ::= length ;
language ::= string() ;
controls ::= column-controls ;
 controls ::= form:password::(form-password-attlist common-form-control-content) ;
 controls ::= form:file::(form-file-attlist common-form-control-content) ;
 controls ::= form:time::(form-time-attlist common-numeric-control-attlist common-form-control-content) ;
 controls ::= form:fixed-text::(form-fixed-text-attlist common-form-control-content) ;
 controls ::= form:button::(form-button-attlist common-form-control-content) ;
 controls ::= form:image::(form-image-attlist common-form-control-content) ;
 controls ::= form:radio::(form-radio-attlist common-form-control-content) ;
 controls ::= form:frame::(form-frame-attlist common-form-control-content) ;
 controls ::= form:image-frame::(form-image-frame-attlist common-form-control-content) ;
 controls ::= form:hidden::(form-hidden-attlist common-form-control-content) ;
 controls ::= form:grid::(form-grid-attlist common-form-control-content form-column*) ;
 controls ::= form:value-range::(form-value-range-attlist common-form-control-content) ;
 controls ::= form:generic-control::(form-generic-control-attlist common-form-control-content) ;
distance ::= length ;
duration ::= string() ;
label ::= (form:label::string)? ;
navigation ::= "none" | "current" | "parent" ;
dropdown ::= (form:dropdown::boolean)? ;
string ::= string() ;
double ::= string() ;
date ::= string() ;
time ::= string() ;
character ::= string() ;
for ::= (form:for::string)? ;
boolean ::= "true" | "false" ;
formula ::= string() ;
length ::= string() ;
percent ::= string() ;
points ::= string() ;
color ::= string() ;
states ::= "unchecked" | "checked" | "unknown" ;
styles ::= style-style* text-list-style* number-number-style* number-currency-style* number-percentage-style* number-date-style* number-time-style* number-boolean-style* number-text-style* ;
size ::= (form:size::nonNegativeInteger)? ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
--------------------odf::opendoc-1.2-manifest.bgf--------------------
algorithm ::= manifest:algorithm::(algorithm-attlist anyElements) ;
manifest ::= manifest:manifest::(manifest-attlist file-entry+) ;
string ::= string() ;
--------------------odf::opendoc-1.2.bgf--------------------
integer ::= integer() ;
selected ::= (form:selected::boolean)? ;
types ::= "submit" | "reset" | "push" | "url" ;
coordinate ::= length ;
language ::= string() ;
controls ::= column-controls | (form:password::(form-password-attlist common-form-control-content)) | (form:file::(form-file-attlist common-form-control-content)) | (form:fixed-text::(form-fixed-text-attlist common-form-control-content)) | (form:button::(form-button-attlist common-form-control-content)) | (form:image::(form-image-attlist common-form-control-content)) | (form:radio::(form-radio-attlist common-form-control-content)) | (form:frame::(form-frame-attlist common-form-control-content)) | (form:image-frame::(form-image-frame-attlist common-form-control-content)) | (form:hidden::(form-hidden-attlist common-form-control-content)) | (form:grid::(form-grid-attlist common-form-control-content form-column*)) | (form:value-range::(form-value-range-attlist common-form-control-content)) | (form:generic-control::(form-generic-control-attlist common-form-control-content)) ;
distance ::= length ;
duration ::= string() ;
label ::= (form:label::string)? ;
navigation ::= "none" | "current" | "parent" ;
angle ::= string() ;
dropdown ::= (form:dropdown::boolean)? ;
string ::= string() ;
double ::= string() ;
date ::= string() ;
time ::= string() ;
character ::= string() ;
for ::= (form:for::string)? ;
boolean ::= "true" | "false" ;
length ::= string() ;
percent ::= string() ;
points ::= string() ;
color ::= string() ;
states ::= "unchecked" | "checked" | "unknown" ;
styles ::= style-style* text-list-style* number-number-style* number-currency-style* number-percentage-style* number-date-style* number-time-style* number-boolean-style* number-text-style* ;
size ::= (form:size::nonNegativeInteger)? ;
shape ::= shape-instance | draw-a ;
--------------------pascal::delphi.bgf--------------------
colon ::= SPOFF ":" SPON ;
builtinid ::= "string" | "file" | "set" ;
sign ::= "+" | "-" ;
namespace ::= id "." ;
expression ::= term infix_expr* ;
argm ::= expression argmfmt? argmfmt? ;
argmfmt ::= ":" anynumber ;
arguments ::= "(" argm? semi_argm* ")" ;
anynumber ::= hexnumber | number ;
expr ::= SP SPOFF expression SPON ;
equal ::= "=" ;
visibility ::= "public" | "protected" | ("strict"? "private") | "published" | "automated" ;
filenamelit ::= charlit | stringlit | qualified_id ;
statement ::= labelid_colon? unlabeled_stm ;
directive ::= "dynamic" | "virtual" | "abstract" | ("message" qualified_id?) | ("dispid" sign? anynumber) | "override" | "overload" | "reintroduce" | "static" | "assembler" | "far" | "export" | hint_directive | calling_spec ;
identlist ::= id colon_id* ;
term ::= prefix_opr* atom_expr postfix_opr* ;
name ::= builtinid | id ;
parameter ::= {id ","}* parameter_type? ;
ctrlchar ::= "^'A" | "^'B" | "^'C" | "^'D" | "^'E" | "^'F" | "^'G" | "^'H" | "^'I" | "^'J" | "^'K" | "^'L" | "^'M" | "^'N" | "^'O" | "^'P" | "^'Q" | "^'R" | "^'S" | "^'T" | "^'U" | "^'V" | "^'W" | "^'X" | "^'Y" | "^'Z" ;
--------------------pascal::delphipp.bgf--------------------
booleanlit ::= "FALSE" | "TRUE" ;
cmbracketblock ::= "{" bracketbody* "}" ;
boolfunc ::= "DEFINED" | "DECLARED" | "OPTION" ;
cmline ::= "//" cmlinebody* EOL ;
codetoken ::= "(" | ")" | "." | ";" | ":" | "," | "[" | "]" | "+" | "-" | "*" | "/" | "^" | "=" | "@" | ">" | "<" | "<>" | ">=" | "<=" | ":=" | "//" | id | anynumber | charlit | space ;
namespace ::= id "." ;
bracketbody ::= pp_any ;
anynumber ::= number | hexnumber ;
starbody ::= pp_any ;
cmstarblock ::= "(*" starbody* "*)" ;
cmlinebody ::= pp_any ;
filenamelit ::= charlit | stringlit | nested_id ;
ident ::= id | (key) ;
--------------------pascal::object.bgf--------------------
object ::= (id object_modifier*) | ("(" ref_name ")" object_modifier*) ;
if ::= "if" | "If" ;
type ::= typeId | simpleType | structType | pointerType | stringType | procedureType | variantType | class_referenceType ;
except ::= "except" | "Except" ;
expression ::= (factor op_factor*) | (op_factor+) ;
arguments ::= "(" {expression ","}* ")" ;
procedure ::= "procedure" | "Procedure" ;
as ::= "As" | "as" ;
directive ::= "cdecl" | "register" | "dynamic" | "virtual" | "export" | "external" | "far" | "forward" | ("message" ref_name?) | "override" | "overload" | "pascal" | "reintroduce" | "safecall" | "stdcall" | "Override" ;
factor ::= ref_name | charlit | (pond_number+) | ("@" "@"? ref_name) | "nil" | ("(" expression ")") | (not_word factor) | set_constructor | (predefinedType "(" expression ")") | bool_value | ("-"? number) ;
statement ::= (labelId_colon? unlabeled_statement) | ε ;
block ::= declaration_section* compound_statement ;
term ::= factor mul_op_factor* ;
do ::= "do" | "Do" | "DO" ;
for ::= "for" | "For" ;
begin ::= "begin" | "Begin" ;
parameter ::= {decl_name ","}* parameter_type? ;
var ::= "var" | "Var" ;
program ::= program_definition | package_definition | library_definition | unit_definition ;
op ::= ">" | "<" | "<=" | ">=" | "<>" | "=" | "in" | "is" | "+" | "-" | "or" | "xor" | "*" | "/" | "div" | "mod" | "and" | "shl" | "shr" | "DIV" | "AND" ;
--------------------xml::zhang-cordy.bgf--------------------
children ::= children_body repetition? ;
element ::= (empty_elem_tag spaces) | (tag_content spaces) ;
notationtype ::= "NOTATION" spaces "(" spaces name more_names* spaces ")" ;
mixed ::= pcdata_or_name | pcdata ;
enumeratedtype ::= notationtype | enumeration ;
content ::= spaces chardata* spaces sub1_content* spaces ;
pi ::= "<?" pitarget sub1_pi? "?>" ;
prolog ::= dtd_body ;
fixed ::= "#FIXED" spaces ;
contentspec ::= "EMPTY" | "ANY" | mixed | children ;
repetition ::= "?" | "*" | "+" ;
pedef ::= entityvalue | external_id ;
attvalue ::= stringlit | charlit | longstringlit | longcharlit ;
literal ::= charlit | stringlit ;
entityvalue ::= charlit | stringlit | longstringlit | longcharlit ;
spaces ::= space_or_newline* ;
cp ::= cp_body repetition? ;
notationdecl ::= "<!NOTATION" spaces name spaces exid_or_pubid spaces ">" spaces ;
misc ::= comment | pi | space | newline ;
defaultdecl ::= "#REQUIRED" | "#IMPLIED" | (fixed? attvalue) ;
decl ::= markupdecl | ("%" name ";") | spaces ;
longstringlit ::= """ not_dquote* """ ;
attlistdecl ::= "<!ATTLIST" spaces name attdef* spaces ">" spaces ;
elementdecl ::= "<!ELEMENT" spaces name spaces contentspec spaces ">" spaces ;
cdsect ::= "<![CDATA[" cdata* cdend ;
choice ::= "(" spaces cp choice_item choice_item* spaces ")" ;
pedecl ::= "<!ENTITY" spaces "%" spaces name spaces pedef spaces ">" spaces ;
seq ::= "(" spaces cp more_cps* spaces ")" ;
pcdata ::= "(" spaces "#PCDATA" spaces ")" ;
attribute ::= spaces name "=" attvalue spaces ;
doctypedecl ::= "<!DOCTYPE" spaces name spaces sp_external_id? spaces declbody? spaces ">" spaces ;
atttype ::= stringtype | tokenizedtype | enumeratedtype ;
cdend ::= "]]>" ;
nmtoken ::= name | dname ;
etag ::= "</" name spaces ">" ;
markupdecl ::= elementdecl | attlistdecl | entitydecl | notationdecl | pi | comment ;
cdata ::= token | comment ;
entitydecl ::= gedecl | pedecl ;
declbody ::= "[" decl* "]" ;
reference ::= ("&" name ";") | charref ;
stringtype ::= "CDATA" ;
pitarget ::= name ;
gedecl ::= "<!ENTITY" spaces name spaces entitydef spaces ">" spaces ;
stag ::= "<" name spaces attribute* ">" ;
enumeration ::= "(" spaces nmtoken more_nmtokens* spaces ")" ;
longcharlit ::= "'" not_quote* "'" ;
attdef ::= spaces name spaces atttype spaces defaultdecl ;
program ::= prolog element ;
tokenizedtype ::= "ID" | "IDREF" | "IDREFS" | "ENTITY" | "ENTITIES" | "NMTOKEN" | "NMTOKENS" ;
ndatadecl ::= spaces "NDATA" spaces name ;
entitydef ::= entityvalue | (external_id ndatadecl?) ;
chardata ::= token ;
--------------------xslt::clark.bgf--------------------
any ::= (α | string() | any)* ;
version ::= "1.0" ;
--------------------php::cordy.bgf--------------------
popid ::= id ;
tag ::= ("<" SPOFF bigtag_id tag_attribute* ">" SPON IN NL) | (EX FL "<" SPOFF "/" bigtag_id ">" SPON FL) | ("<" SPOFF "!"? id_or_key tag_attribute* ">" SPON NL) | ("<" SPOFF "/" id_or_key ">" SPON NL) | ("<" SPOFF id_or_key tag_attribute* "/>" SPON NL) ;
program ::= Document ;
--------------------python::indent-cordy.bgf--------------------
compoundtoken ::= linetoken | newline | comment ;
indent ::= SP "INDENT" ;
compoundtokensquare ::= linetoken | newline | comment ;
compound ::= ("{" compoundtoken* "}") | ("[" compoundtokensquare* "]") | ("(" compoundtokenround* ")") ;
dedent ::= "DEDENT" SP ;
endofline ::= tab_space* comment? newline ;
linetoken ::= tab_space | nonblank_token ;
line ::= tab_space* linetoken* indent? endofline+ dedent* ;
program ::= line* ;
compoundtokenround ::= linetoken | newline | comment ;
--------------------python::sorochan-cordy.bgf--------------------
integer ::= integernumber | hexinteger | octinteger ;
stringliteral ::= (stringprefix SPOFF string SPON) | string ;
argument ::= endofline* test argument_value? endofline* ;
long ::= (SPOFF "l" SPON) | (SPOFF "L" SPON) ;
lambdef ::= "lambda" varargslist? ":" test ;
fpdef ::= (id endofline?) | (SPOFF "(" SPON fplist endofline* ")" endofline?) ;
decorator ::= "@" dotted_name decorator_arglist? endofline endofline* ;
suite ::= (indent endofline stmt_or_newline+ dedent) | (simple_stmt endofline) ;
decorated ::= (decorators classdef) | (decorators funcdef) ;
expr ::= xor_expr orop_expr? ;
arglist ::= star_test? {argument ","}* comma_opt_star_test? ;
sliceop ::= ":" test? ;
trailer ::= (SPOFF "(" SPON IN arglist endofline* ")" EX) | ("[" IN subscriptlist "]" EX) | (endofline* "." endofline* id) ;
integerliteral ::= integer long? imag? ;
testlist ::= test+ endofline* ","? ;
literal ::= (stringliteral more_stringliteral*) | integerliteral | floatliteral ;
term ::= factor op_term* ;
indent ::= "INDENT" IN ;
parameters ::= SPOFF "(" SPON varargslist? endofline* ")" ;
subscriptlist ::= subscript+ "," endofline* ;
fplist ::= fpdef+ ","? ;
listmaker ::= (endofline* test endofline* plist_for endofline*) | (endofline* {test ","}* ","? endofline*) ;
endofline ::= comment? newline ;
stringprefix ::= "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR" | "b" ;
augassign ::= "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "**=" | "//=" ;
varargslist ::= (fpdef_test_comma* endofline* "*" id) | (fpdef_test_comma* endofline* "*" id endofline? "," endofline* "**" id) | (fpdef_test_comma* endofline* "**" id) | (fpdef_test+ ","?) ;
decorators ::= decorator+ ;
floatliteral ::= (number imag?) | (pointfloat imag?) ;
exprlist ::= expr+ endofline* ","? ;
test ::= (endofline* or_test if_test? endofline?) | (endofline* lambdef endofline?) ;
string ::= stringlit | charlit | longstringlit | longcharlit ;
atom ::= id | literal | ("(" IN endofline* yield_expr? endofline* ")" EX) | ("(" IN endofline* testplist_gexp endofline* ")" EX) | ("[" IN endofline* listmaker? "]" EX) | ("{" IN endofline* dictmaker? endofline* "}" EX) | ("`" testlist1 "`") ;
factor ::= unary_op* power ;
dictmaker ::= {dict_entry ","}* endofline* ","? endofline* ;
classdef ::= ("class" id? ":" suite) | ("class" id? SPOFF "(" SPON testlist? endofline* ")" ":" suite) ;
subscript ::= (endofline* "." "." "." endofline?) | (endofline* test endofline?) | (endofline* test? ":" test? sliceop? endofline?) ;
imag ::= (SPOFF "j" SPON) | (SPOFF "J" SPON) ;
comparison ::= expr comp_op_comparison? ;
stmt ::= (simple_stmt endofline) | compound_stmt ;
dedent ::= "DEDENT" EX ;
power ::= atom trailer* exp_factor? ;
program ::= file_input ;
funcdef ::= "def" id parameters ":" suite ;
--------------------markup::docbook-walsh.bgf--------------------
publisher ::= publisher::(publisher.attlist publishername address*) ;
link ::= link::(link.attlist para.char.mix*) ;
productname ::= productname::(productname.attlist para.char.mix*) ;
synopfragmentref ::= synopfragmentref::(synopfragmentref.attlist string()) ;
refentrytitle ::= refentrytitle::(refentrytitle.attlist para.char.mix*) ;
token ::= token::(token.attlist smallcptr.char.mix*) ;
synopfragment ::= synopfragment::(synopfragment.attlist (arg | group)+) ;
qandaentry ::= qandaentry::(qandaentry.attlist blockinfo? revhistory? question answer*) ;
appendixinfo ::= appendixinfo::(appendixinfo.attlist info.class+) ;
errorcode ::= errorcode::(errorcode.attlist smallcptr.char.mix*) ;
address ::= address::(address.attlist (string() | personname | person.ident.mix | street | pob | postcode | city | state | country | phone | fax | email | otheraddr)*) ;
part ::= part::(part.attlist beginpage? partinfo? bookcomponent.title.content partintro? partcontent.mix+) ;
note ::= note::(note.attlist title? admon.mix+) ;
ulink ::= ulink::(ulink.attlist para.char.mix*) ;
itermset ::= itermset::(itermset.attlist indexterm+) ;
programlistingco ::= programlistingco::(programlistingco.attlist areaspec programlisting calloutlist*) ;
inlinemediaobject ::= inlinemediaobject::(inlinemediaobject.attlist objectinfo? mediaobject.mix+) ;
keyword ::= keyword::(keyword.attlist string()) ;
hardware ::= hardware::(hardware.attlist cptr.char.mix*) ;
caption ::= caption::(caption.attlist textobject.mix*) ;
question ::= question::(question.attlist label? qandaset.mix+) ;
revremark ::= revremark::(revremark.attlist docinfo.char.mix*) ;
confnum ::= confnum::(confnum.attlist docinfo.char.mix*) ;
confdates ::= confdates::(confdates.attlist docinfo.char.mix*) ;
tocfront ::= tocfront::(tocfront.attlist para.char.mix*) ;
structname ::= structname::(structname.attlist smallcptr.char.mix*) ;
para ::= para::(para.attlist (para.char.mix | para.mix)*) ;
pubsnumber ::= pubsnumber::(pubsnumber.attlist docinfo.char.mix*) ;
envar ::= envar::(envar.attlist smallcptr.char.mix*) ;
modespec ::= modespec::(modespec.attlist docinfo.char.mix*) ;
computeroutput ::= computeroutput::(computeroutput.attlist (cptr.char.mix | co)*) ;
revision ::= revision::(revision.attlist revnumber date authorinitials* (revremark | revdescription)?) ;
confgroup ::= confgroup::(confgroup.attlist (confdates | conftitle | confnum | address | confsponsor)*) ;
row ::= row::(row.attlist tbl.row.mdl) ;
keywordset ::= keywordset::(keywordset.attlist keyword+) ;
function ::= function::(function.attlist cptr.char.mix*) ;
screenco ::= screenco::(screenco.attlist areaspec screen calloutlist*) ;
property ::= property::(property.attlist cptr.char.mix*) ;
authorgroup ::= authorgroup::(authorgroup.attlist (author | editor | collab | corpauthor | othercredit)+) ;
mediaobjectco ::= mediaobjectco::(mediaobjectco.attlist objectinfo? imageobjectco (imageobjectco | textobject)*) ;
table ::= table::(table.attlist tbl.table.mdl) ;
glossaryinfo ::= glossaryinfo::(glossaryinfo.attlist info.class+) ;
appendix ::= appendix::(appendix.attlist beginpage? appendixinfo? bookcomponent.title.content nav.class* tocchap? bookcomponent.content nav.class*) ;
contractsponsor ::= contractsponsor::(contractsponsor.attlist docinfo.char.mix*) ;
areaspec ::= areaspec::(areaspec.attlist (area | areaset)+) ;
sgmltag ::= sgmltag::(sgmltag.attlist smallcptr.char.mix*) ;
copyright ::= copyright::(copyright.attlist year+ holder*) ;
wordasword ::= wordasword::(wordasword.attlist word.char.mix*) ;
acronym ::= acronym::(acronym.attlist word.char.mix*) ;
systemitem ::= systemitem::(systemitem.attlist (cptr.char.mix | acronym | co)*) ;
lotentry ::= lotentry::(lotentry.attlist para.char.mix*) ;
menuchoice ::= menuchoice::(menuchoice.attlist shortcut? (guibutton | guiicon | guilabel | guimenu | guimenuitem | guisubmenu | interface)+) ;
bodyatt ::= label.attrib ;
refentry ::= refentry::(refentry.attlist beginpage? ndxterm.class* refentryinfo? refmeta? (remark | link.char.class)* refnamediv refsynopsisdiv? (refsect1+) | (refsection+)) ;
edition ::= edition::(edition.attlist docinfo.char.mix*) ;
answer ::= answer::(answer.attlist label? qandaset.mix* qandaentry*) ;
glossdef ::= glossdef::(glossdef.attlist glossdef.mix+ glossseealso*) ;
classsynopsisinfo ::= classsynopsisinfo::(classsynopsisinfo.attlist (cptr.char.mix | textobject | lineannotation)*) ;
refsynopsisdivinfo ::= refsynopsisdivinfo::(refsynopsisdivinfo.attlist info.class+) ;
subjectset ::= subjectset::(subjectset.attlist subject+) ;
corpauthor ::= corpauthor::(corpauthor.attlist docinfo.char.mix*) ;
conftitle ::= conftitle::(conftitle.attlist docinfo.char.mix*) ;
setindex ::= setindex::(setindex.attlist setindexinfo? bookcomponent.title.content? component.mix* (indexdiv*) | (indexentry*)) ;
msginfo ::= msginfo::(msginfo.attlist (msglevel | msgorig | msgaud)*) ;
date ::= date::(date.attlist docinfo.char.mix*) ;
manvolnum ::= manvolnum::(manvolnum.attlist word.char.mix*) ;
invpartnumber ::= invpartnumber::(invpartnumber.attlist docinfo.char.mix*) ;
revnumber ::= revnumber::(revnumber.attlist docinfo.char.mix*) ;
holder ::= holder::(holder.attlist docinfo.char.mix*) ;
parameter ::= parameter::(parameter.attlist cptr.char.mix*) ;
alt ::= alt::(alt.attlist string()) ;
glosslist ::= glosslist::(glosslist.attlist glossentry+) ;
constant ::= constant::(constant.attlist smallcptr.char.mix*) ;
refname ::= refname::(refname.attlist refname.char.mix*) ;
email ::= email::(email.attlist docinfo.char.mix*) ;
warning ::= warning::(warning.attlist title? admon.mix+) ;
othername ::= othername::(othername.attlist docinfo.char.mix*) ;
symbol ::= symbol::(symbol.attlist smallcptr.char.mix*) ;
ooclass ::= ooclass::(ooclass.attlist modifier* classname) ;
subjectterm ::= subjectterm::(subjectterm.attlist string()) ;
country ::= country::(country.attlist docinfo.char.mix*) ;
informalexample ::= informalexample::(informalexample.attlist blockinfo? example.mix+) ;
void ::= void::(void.attlist ε) ;
synopsis ::= synopsis::(synopsis.attlist (para.char.mix | graphic | mediaobject | co | coref | textobject | lineannotation)*) ;
msgentry ::= msgentry::(msgentry.attlist msg+ msginfo? msgexplan*) ;
medialabel ::= medialabel::(medialabel.attlist smallcptr.char.mix*) ;
secondaryie ::= secondaryie::(secondaryie.attlist ndxterm.char.mix*) ;
msgaud ::= msgaud::(msgaud.attlist para.char.mix*) ;
constructorsynopsis ::= constructorsynopsis::(constructorsynopsis.attlist modifier* methodname? (methodparam+) | void exceptionname*) ;
author ::= author::(author.attlist personname | (person.ident.mix+) (personblurb | email | address)*) ;
imagedata ::= imagedata::(imagedata.attlist ε) ;
msg ::= msg::(msg.attlist title? msgmain (msgsub | msgrel)*) ;
remark ::= remark::(remark.attlist para.char.mix*) ;
programlisting ::= programlisting::(programlisting.attlist (para.char.mix | co | coref | lineannotation | textobject)*) ;
preface ::= preface::(preface.attlist beginpage? prefaceinfo? bookcomponent.title.content nav.class* tocchap? bookcomponent.content nav.class*) ;
emphasis ::= emphasis::(emphasis.attlist para.char.mix*) ;
database ::= database::(database.attlist cptr.char.mix*) ;
videoobject ::= videoobject::(videoobject.attlist objectinfo? videodata) ;
bibliodiv ::= bibliodiv::(bibliodiv.attlist sect.title.content? component.mix* (biblioentry | bibliomixed)+) ;
revdescription ::= revdescription::(revdescription.attlist revdescription.mix+) ;
msgrel ::= msgrel::(msgrel.attlist title? msgtext) ;
glossterm ::= glossterm::(glossterm.attlist para.char.mix*) ;
confsponsor ::= confsponsor::(confsponsor.attlist docinfo.char.mix*) ;
methodsynopsis ::= methodsynopsis::(methodsynopsis.attlist modifier* (type | void)? methodname (methodparam+) | void exceptionname* modifier*) ;
secondary ::= secondary::(secondary.attlist ndxterm.char.mix*) ;
orgname ::= orgname::(orgname.attlist docinfo.char.mix*) ;
phone ::= phone::(phone.attlist docinfo.char.mix*) ;
editor ::= editor::(editor.attlist personname | (person.ident.mix+) (personblurb | email | address)*) ;
city ::= city::(city.attlist docinfo.char.mix*) ;
caution ::= caution::(caution.attlist title? admon.mix+) ;
example ::= example::(example.attlist blockinfo? formalobject.title.content example.mix+) ;
citebiblioid ::= citebiblioid::(citebiblioid.attlist docinfo.char.mix*) ;
screenshot ::= screenshot::(screenshot.attlist screeninfo? graphic | graphicco | mediaobject | mediaobjectco) ;
prompt ::= prompt::(prompt.attlist (smallcptr.char.mix | co)*) ;
bibliography ::= bibliography::(bibliography.attlist bibliographyinfo? bookcomponent.title.content? component.mix* (bibliodiv+) | ((biblioentry | bibliomixed)+)) ;
citetitle ::= citetitle::(citetitle.attlist para.char.mix*) ;
optional ::= optional::(optional.attlist cptr.char.mix*) ;
personname ::= personname::(personname.attlist (honorific | firstname | surname | lineage | othername)+) ;
footnote ::= footnote::(footnote.attlist footnote.mix+) ;
sidebar ::= sidebar::(sidebar.attlist sidebarinfo? formalobject.title.content? sidebar.mix+) ;
exceptionname ::= exceptionname::(exceptionname.attlist smallcptr.char.mix*) ;
oointerface ::= oointerface::(oointerface.attlist modifier* interfacename) ;
qandadiv ::= qandadiv::(qandadiv.attlist blockinfo? formalobject.title.content? qandaset.mix* (qandadiv+) | (qandaentry+)) ;
graphicco ::= graphicco::(graphicco.attlist areaspec graphic calloutlist*) ;
lot ::= lot::(lot.attlist beginpage? bookcomponent.title.content? lotentry*) ;
application ::= application::(application.attlist para.char.mix*) ;
simplelist ::= simplelist::(simplelist.attlist member+) ;
glossseealso ::= glossseealso::(glossseealso.attlist para.char.mix*) ;
varlistentry ::= varlistentry::(varlistentry.attlist term+ listitem) ;
equation ::= equation::(equation.attlist blockinfo? formalobject.title.content? informalequation | equation.content) ;
command ::= command::(command.attlist cptr.char.mix*) ;
reference ::= reference::(reference.attlist beginpage? referenceinfo? bookcomponent.title.content partintro? refentry.class+) ;
biblioset ::= biblioset::(biblioset.attlist bibliocomponent.mix+) ;
funcparams ::= funcparams::(funcparams.attlist cptr.char.mix*) ;
toc ::= toc::(toc.attlist beginpage? bookcomponent.title.content? tocfront* (tocpart | tocchap)* tocback*) ;
printhistory ::= printhistory::(printhistory.attlist para.class+) ;
colophon ::= colophon::(colophon.attlist sect.title.content? textobject.mix+) ;
interfacename ::= interfacename::(interfacename.attlist cptr.char.mix*) ;
simplemsgentry ::= simplemsgentry::(simplemsgentry.attlist msgtext msgexplan+) ;
errortype ::= errortype::(errortype.attlist smallcptr.char.mix*) ;
msgorig ::= msgorig::(msgorig.attlist smallcptr.char.mix*) ;
msgset ::= msgset::(msgset.attlist blockinfo? formalobject.title.content? (msgentry+) | (simplemsgentry+)) ;
firstname ::= firstname::(firstname.attlist docinfo.char.mix*) ;
tocpart ::= tocpart::(tocpart.attlist tocentry+ tocchap*) ;
colspec ::= colspec::(colspec.attlist ε) ;
type ::= type::(type.attlist smallcptr.char.mix*) ;
interface ::= interface::(interface.attlist (smallcptr.char.mix | accel)*) ;
informalfigure ::= informalfigure::(informalfigure.attlist blockinfo? (figure.mix | link.char.class)+) ;
simpara ::= simpara::(simpara.attlist para.char.mix*) ;
seealsoie ::= seealsoie::(seealsoie.attlist ndxterm.char.mix*) ;
errortext ::= errortext::(errortext.attlist smallcptr.char.mix*) ;
releaseinfo ::= releaseinfo::(releaseinfo.attlist docinfo.char.mix*) ;
corpname ::= corpname::(corpname.attlist docinfo.char.mix*) ;
contractnum ::= contractnum::(contractnum.attlist docinfo.char.mix*) ;
footnoteref ::= footnoteref::(footnoteref.attlist ε) ;
guimenuitem ::= guimenuitem::(guimenuitem.attlist (smallcptr.char.mix | accel)*) ;
orgdiv ::= orgdiv::(orgdiv.attlist docinfo.char.mix*) ;
refmiscinfo ::= refmiscinfo::(refmiscinfo.attlist docinfo.char.mix*) ;
subject ::= subject::(subject.attlist subjectterm+) ;
refpurpose ::= refpurpose::(refpurpose.attlist refinline.char.mix*) ;
qandaset ::= qandaset::(qandaset.attlist blockinfo? formalobject.title.content? qandaset.mix* (qandadiv+) | (qandaentry+)) ;
segtitle ::= segtitle::(segtitle.attlist title.char.mix*) ;
bibliomisc ::= bibliomisc::(bibliomisc.attlist para.char.mix*) ;
partinfo ::= partinfo::(partinfo.attlist info.class+) ;
msgsub ::= msgsub::(msgsub.attlist title? msgtext) ;
fax ::= fax::(fax.attlist docinfo.char.mix*) ;
msgexplan ::= msgexplan::(msgexplan.attlist title? component.mix+) ;
firstterm ::= firstterm::(firstterm.attlist word.char.mix*) ;
xref ::= xref::(xref.attlist ε) ;
biblioentry ::= biblioentry::(biblioentry.attlist (articleinfo | bibliocomponent.mix)+) ;
titles ::= title? ;
guimenu ::= guimenu::(guimenu.attlist (smallcptr.char.mix | accel)*) ;
screeninfo ::= screeninfo::(screeninfo.attlist para.char.mix*) ;
variablelist ::= variablelist::(variablelist.attlist blockinfo? formalobject.title.content? listpreamble.mix* varlistentry+) ;
refmeta ::= refmeta::(refmeta.attlist ndxterm.class* refentrytitle manvolnum? refmiscinfo* ndxterm.class*) ;
bookinfo ::= bookinfo::(bookinfo.attlist info.class+) ;
keycap ::= keycap::(keycap.attlist cptr.char.mix*) ;
sectioninfo ::= sectioninfo::(sectioninfo.attlist info.class+) ;
biblioid ::= biblioid::(biblioid.attlist docinfo.char.mix*) ;
bibliographyinfo ::= bibliographyinfo::(bibliographyinfo.attlist info.class+) ;
bibliomset ::= bibliomset::(bibliomset.attlist (string() | bibliocomponent.mix | bibliomset)*) ;
classsynopsis ::= classsynopsis::(classsynopsis.attlist (ooclass | oointerface | ooexception)+ (classsynopsisinfo | fieldsynopsis | method.synop.class)*) ;
subscript ::= subscript::(subscript.attlist (string() | link.char.class | emphasis | replaceable | symbol | inlinegraphic | inlinemediaobject | base.char.class | other.char.class)*) ;
funcsynopsisinfo ::= funcsynopsisinfo::(funcsynopsisinfo.attlist (cptr.char.mix | textobject | lineannotation)*) ;
issn ::= issn::(issn.attlist docinfo.char.mix*) ;
otheraddr ::= otheraddr::(otheraddr.attlist docinfo.char.mix*) ;
informaltable ::= informaltable::(informaltable.attlist blockinfo? textobject* (graphic+) | (mediaobject+) | (tgroup+)) ;
titleabbrev ::= titleabbrev::(titleabbrev.attlist title.char.mix*) ;
productnumber ::= productnumber::(productnumber.attlist docinfo.char.mix*) ;
isbn ::= isbn::(isbn.attlist docinfo.char.mix*) ;
article ::= article::(article.attlist div.title.content? articleinfo? tocchap? lot* bookcomponent.content (nav.class | appendix.class | ackno)*) ;
simplesect ::= simplesect::(simplesect.attlist sect.title.content divcomponent.mix+) ;
label ::= label::(label.attlist word.char.mix*) ;
refsection ::= refsection::(refsection.attlist refsectioninfo? refsect.title.content (refcomponent.mix+ refsection*) | (refsection+)) ;
affiliation ::= affiliation::(affiliation.attlist shortaffil? jobtitle* orgname? orgdiv* address*) ;
epigraph ::= epigraph::(epigraph.attlist attribution? (para.class | literallayout)+) ;
tertiaryie ::= tertiaryie::(tertiaryie.attlist ndxterm.char.mix*) ;
refentryinfo ::= refentryinfo::(refentryinfo.attlist info.class+) ;
methodname ::= methodname::(methodname.attlist smallcptr.char.mix*) ;
olink ::= olink::(olink.attlist para.char.mix*) ;
bridgehead ::= bridgehead::(bridgehead.attlist title.char.mix*) ;
book ::= book::(book.attlist div.title.content? bookinfo? (dedication | toc | lot | glossary | bibliography | preface | chapter.class | reference | part | article.class | appendix.class | index.class | colophon)*) ;
accel ::= accel::(accel.attlist smallcptr.char.mix*) ;
graphic ::= graphic::(graphic.attlist ε) ;
citation ::= citation::(citation.attlist para.char.mix*) ;
substeps ::= substeps::(substeps.attlist step+) ;
inlineequation ::= inlineequation::(inlineequation.attlist inlineequation.content) ;
section ::= section::(section.attlist sectioninfo? sect.title.content nav.class* (divcomponent.mix+ (refentry.class*) | (section.class*) | (simplesect*)) | (refentry.class+) | (section.class+) | (simplesect+) nav.class*) ;
figure ::= figure::(figure.attlist blockinfo? formalobject.title.content (figure.mix | link.char.class)+) ;
initializer ::= initializer::(initializer.attlist smallcptr.char.mix*) ;
tfoot ::= tfoot::(tfoot.attlist tbl.hdft.mdl) ;
indexentry ::= indexentry::(indexentry.attlist primaryie (seeie | seealsoie)* (secondaryie (seeie | seealsoie | tertiaryie)*)*) ;
userinput ::= userinput::(userinput.attlist (cptr.char.mix | co)*) ;
funcprototype ::= funcprototype::(funcprototype.attlist funcdef void | varargs | (paramdef+)) ;
surname ::= surname::(surname.attlist docinfo.char.mix*) ;
modifier ::= modifier::(modifier.attlist smallcptr.char.mix*) ;
procedure ::= procedure::(procedure.attlist blockinfo? formalobject.title.content? component.mix* step+) ;
index ::= index::(index.attlist indexinfo? bookcomponent.title.content? component.mix* (indexdiv*) | (indexentry*)) ;
legalnotice ::= legalnotice::(legalnotice.attlist blockinfo? title? legalnotice.mix+) ;
calloutlist ::= calloutlist::(calloutlist.attlist formalobject.title.content? callout+) ;
cmdsynopsis ::= cmdsynopsis::(cmdsynopsis.attlist (command | arg | group | sbr)+ synopfragment*) ;
keycode ::= keycode::(keycode.attlist smallcptr.char.mix*) ;
step ::= step::(step.attlist title? (component.mix+ (substeps component.mix*)?) | (substeps component.mix*)) ;
shortaffil ::= shortaffil::(shortaffil.attlist docinfo.char.mix*) ;
refclass ::= refclass::(refclass.attlist refclass.char.mix*) ;
funcdef ::= funcdef::(funcdef.attlist (string() | type | replaceable | function)*) ;
pagenums ::= pagenums::(pagenums.attlist docinfo.char.mix*) ;
jobtitle ::= jobtitle::(jobtitle.attlist docinfo.char.mix*) ;
blockinfo ::= blockinfo::(blockinfo.attlist info.class+) ;
msgmain ::= msgmain::(msgmain.attlist title? msgtext) ;
phrase ::= phrase::(phrase.attlist para.char.mix*) ;
beginpage ::= beginpage::(beginpage.attlist ε) ;
dedication ::= dedication::(dedication.attlist sect.title.content? legalnotice.mix+) ;
anchor ::= anchor::(anchor.attlist ε) ;
areaset ::= areaset::(areaset.attlist area+) ;
bibliorelation ::= bibliorelation::(bibliorelation.attlist docinfo.char.mix*) ;
listitem ::= listitem::(listitem.attlist component.mix+) ;
segmentedlist ::= segmentedlist::(segmentedlist.attlist formalobject.title.content? segtitle+ seglistitem+) ;
literal ::= literal::(literal.attlist cptr.char.mix*) ;
seeie ::= seeie::(seeie.attlist ndxterm.char.mix*) ;
secur ::= common.attrib tables.role.attrib ;
textobject ::= textobject::(textobject.attlist objectinfo? phrase | textdata | (textobject.mix+)) ;
seriesvolnums ::= seriesvolnums::(seriesvolnums.attlist docinfo.char.mix*) ;
glossentry ::= glossentry::(glossentry.attlist glossterm acronym? abbrev? ndxterm.class* revhistory? glosssee | (glossdef+)) ;
coref ::= coref::(coref.attlist ε) ;
personblurb ::= personblurb::(personblurb.attlist title? para.class+) ;
videodata ::= videodata::(videodata.attlist ε) ;
articleinfo ::= articleinfo::(articleinfo.attlist info.class+) ;
bibliomixed ::= bibliomixed::(bibliomixed.attlist (string() | bibliocomponent.mix | bibliomset)*) ;
msglevel ::= msglevel::(msglevel.attlist smallcptr.char.mix*) ;
abbrev ::= abbrev::(abbrev.attlist word.char.mix*) ;
informalequation ::= informalequation::(informalequation.attlist blockinfo? equation.content) ;
refsectioninfo ::= refsectioninfo::(refsectioninfo.attlist info.class+) ;
bibliocoverage ::= bibliocoverage::(bibliocoverage.attlist docinfo.char.mix*) ;
primaryie ::= primaryie::(primaryie.attlist ndxterm.char.mix*) ;
tocchap ::= tocchap::(tocchap.attlist tocentry+ toclevel1*) ;
tip ::= tip::(tip.attlist title? admon.mix+) ;
seealso ::= seealso::(seealso.attlist ndxterm.char.mix*) ;
member ::= member::(member.attlist para.char.mix*) ;
guilabel ::= guilabel::(guilabel.attlist (smallcptr.char.mix | accel)*) ;
contrib ::= contrib::(contrib.attlist docinfo.char.mix*) ;
literallayout ::= literallayout::(literallayout.attlist (para.char.mix | co | coref | textobject | lineannotation)*) ;
audioobject ::= audioobject::(audioobject.attlist objectinfo? audiodata) ;
errorname ::= errorname::(errorname.attlist smallcptr.char.mix*) ;
bibliosource ::= bibliosource::(bibliosource.attlist docinfo.char.mix*) ;
revhistory ::= revhistory::(revhistory.attlist revision+) ;
state ::= state::(state.attlist docinfo.char.mix*) ;
keycombo ::= keycombo::(keycombo.attlist (keycap | keycombo | keysym | mousebutton)+) ;
fieldsynopsis ::= fieldsynopsis::(fieldsynopsis.attlist modifier* type? varname initializer?) ;
foreignphrase ::= foreignphrase::(foreignphrase.attlist para.char.mix*) ;
postcode ::= postcode::(postcode.attlist docinfo.char.mix*) ;
destructorsynopsis ::= destructorsynopsis::(destructorsynopsis.attlist modifier* methodname? (methodparam+) | void exceptionname*) ;
area ::= area::(area.attlist ε) ;
lineage ::= lineage::(lineage.attlist docinfo.char.mix*) ;
orderedlist ::= orderedlist::(orderedlist.attlist blockinfo? formalobject.title.content? listpreamble.mix* listitem+) ;
tgroup ::= tgroup::(tgroup.attlist tbl.tgroup.mdl) ;
publishername ::= publishername::(publishername.attlist docinfo.char.mix*) ;
varargs ::= varargs::(varargs.attlist ε) ;
indexinfo ::= indexinfo::(indexinfo.attlist info.class+) ;
audiodata ::= audiodata::(audiodata.attlist ε) ;
group ::= group::(group.attlist (arg | group | option | synopfragmentref | replaceable | sbr)+) ;
attribution ::= attribution::(attribution.attlist para.char.mix*) ;
indexdiv ::= indexdiv::(indexdiv.attlist sect.title.content? indexdivcomponent.mix* (indexentry+) | segmentedlist) ;
quote ::= quote::(quote.attlist para.char.mix*) ;
chapterinfo ::= chapterinfo::(chapterinfo.attlist info.class+) ;
referenceinfo ::= referenceinfo::(referenceinfo.attlist info.class+) ;
option ::= option::(option.attlist cptr.char.mix*) ;
entry ::= entry::(entry.attlist tbl.entry.mdl*) ;
ooexception ::= ooexception::(ooexception.attlist modifier* exceptionname) ;
objectinfo ::= objectinfo::(objectinfo.attlist info.class+) ;
co ::= co::(co.attlist ε) ;
screen ::= screen::(screen.attlist (para.char.mix | co | coref | textobject | lineannotation)*) ;
term ::= term::(term.attlist para.char.mix*) ;
set ::= set::(set.attlist div.title.content? setinfo? toc? book.class+ setindex?) ;
honorific ::= honorific::(honorific.attlist docinfo.char.mix*) ;
setindexinfo ::= setindexinfo::(setindexinfo.attlist info.class+) ;
imageobject ::= imageobject::(imageobject.attlist objectinfo? imagedata) ;
partintro ::= partintro::(partintro.attlist div.title.content? bookcomponent.content) ;
paramdef ::= paramdef::(paramdef.attlist (string() | type | replaceable | parameter | funcparams)*) ;
funcsynopsis ::= funcsynopsis::(funcsynopsis.attlist (funcsynopsisinfo | funcprototype)+) ;
title ::= title::(title.attlist title.char.mix*) ;
textdata ::= textdata::(textdata.attlist ε) ;
arg ::= arg::(arg.attlist (string() | arg | group | option | synopfragmentref | replaceable | sbr)*) ;
seg ::= seg::(seg.attlist para.char.mix*) ;
thead ::= thead::(thead.attlist tbl.hdft.mdl) ;
see ::= see::(see.attlist ndxterm.char.mix*) ;
tertiary ::= tertiary::(tertiary.attlist ndxterm.char.mix*) ;
formalpara ::= formalpara::(formalpara.attlist title ndxterm.class* para) ;
chapter ::= chapter::(chapter.attlist beginpage? chapterinfo? bookcomponent.title.content nav.class* tocchap? bookcomponent.content nav.class*) ;
methodparam ::= methodparam::(methodparam.attlist modifier* type? (parameter initializer?) | funcparams modifier*) ;
yesorno ::= string() ;
glossdiv ::= glossdiv::(glossdiv.attlist sect.title.content component.mix* glossentry+) ;
shortcut ::= shortcut::(shortcut.attlist (keycap | keycombo | keysym | mousebutton)+) ;
imageobjectco ::= imageobjectco::(imageobjectco.attlist areaspec imageobject calloutlist*) ;
structfield ::= structfield::(structfield.attlist smallcptr.char.mix*) ;
pob ::= pob::(pob.attlist docinfo.char.mix*) ;
refdescriptor ::= refdescriptor::(refdescriptor.attlist refname.char.mix*) ;
returnvalue ::= returnvalue::(returnvalue.attlist smallcptr.char.mix*) ;
itemizedlist ::= itemizedlist::(itemizedlist.attlist blockinfo? formalobject.title.content? listpreamble.mix* listitem+) ;
highlights ::= highlights::(highlights.attlist highlights.mix+) ;
indexterm ::= indexterm::(indexterm.attlist primary? ((secondary ((tertiary (see | (seealso+))?) | see | (seealso+))?) | see | (seealso+))?) ;
year ::= year::(year.attlist docinfo.char.mix*) ;
authorinitials ::= authorinitials::(authorinitials.attlist docinfo.char.mix*) ;
action ::= action::(action.attlist cptr.char.mix*) ;
guiicon ::= guiicon::(guiicon.attlist (smallcptr.char.mix | accel)*) ;
refnamediv ::= refnamediv::(refnamediv.attlist refdescriptor? refname+ refpurpose refclass* (remark | link.char.class)*) ;
varname ::= varname::(varname.attlist smallcptr.char.mix*) ;
trademark ::= trademark::(trademark.attlist (string() | link.char.class | tech.char.class | base.char.class | other.char.class | inlinegraphic | inlinemediaobject | emphasis)*) ;
callout ::= callout::(callout.attlist component.mix+) ;
authorblurb ::= authorblurb::(authorblurb.attlist title? para.class+) ;
inlinegraphic ::= inlinegraphic::(inlinegraphic.attlist ε) ;
tocback ::= tocback::(tocback.attlist para.char.mix*) ;
msgtext ::= msgtext::(msgtext.attlist component.mix+) ;
prefaceinfo ::= prefaceinfo::(prefaceinfo.attlist info.class+) ;
guibutton ::= guibutton::(guibutton.attlist (smallcptr.char.mix | accel)*) ;
volumenum ::= volumenum::(volumenum.attlist docinfo.char.mix*) ;
pubdate ::= pubdate::(pubdate.attlist docinfo.char.mix*) ;
tocentry ::= tocentry::(tocentry.attlist para.char.mix*) ;
markup ::= markup::(markup.attlist smallcptr.char.mix*) ;
lineannotation ::= lineannotation::(lineannotation.attlist para.char.mix*) ;
mediaobject ::= mediaobject::(mediaobject.attlist objectinfo? mediaobject.mix+ caption?) ;
important ::= important::(important.attlist title? admon.mix+) ;
abstract ::= abstract::(abstract.attlist title? para.class+) ;
artpagenums ::= artpagenums::(artpagenums.attlist docinfo.char.mix*) ;
glossary ::= glossary::(glossary.attlist glossaryinfo? bookcomponent.title.content? component.mix* (glossdiv+) | (glossentry+) bibliography?) ;
subtitle ::= subtitle::(subtitle.attlist title.char.mix*) ;
collabname ::= collabname::(collabname.attlist docinfo.char.mix*) ;
mousebutton ::= mousebutton::(mousebutton.attlist smallcptr.char.mix*) ;
citerefentry ::= citerefentry::(citerefentry.attlist refentrytitle manvolnum?) ;
tbody ::= tbody::(tbody.attlist row+) ;
setinfo ::= setinfo::(setinfo.attlist info.class+) ;
blockquote ::= blockquote::(blockquote.attlist title? attribution? component.mix+) ;
replaceable ::= replaceable::(replaceable.attlist (string() | link.char.class | optional | base.char.class | other.char.class | inlinegraphic | inlinemediaobject | co)*) ;
issuenum ::= issuenum::(issuenum.attlist docinfo.char.mix*) ;
collab ::= collab::(collab.attlist collabname affiliation*) ;
entrytbl ::= entrytbl::(entrytbl.attlist tbl.entrytbl.mdl) ;
ackno ::= ackno::(ackno.attlist docinfo.char.mix*) ;
sidebarinfo ::= sidebarinfo::(sidebarinfo.attlist info.class+) ;
refsynopsisdiv ::= refsynopsisdiv::(refsynopsisdiv.attlist refsynopsisdivinfo? refsect.title.content? (refcomponent.mix+ refsect2*) | (refsect2+)) ;
othercredit ::= othercredit::(othercredit.attlist personname | (person.ident.mix+) (personblurb | email | address)*) ;
glosssee ::= glosssee::(glosssee.attlist para.char.mix*) ;
keysym ::= keysym::(keysym.attlist smallcptr.char.mix*) ;
filename ::= filename::(filename.attlist cptr.char.mix*) ;
superscript ::= superscript::(superscript.attlist (string() | link.char.class | emphasis | replaceable | symbol | inlinegraphic | inlinemediaobject | base.char.class | other.char.class)*) ;
seglistitem ::= seglistitem::(seglistitem.attlist seg+) ;
spanspec ::= spanspec::(spanspec.attlist ε) ;
guisubmenu ::= guisubmenu::(guisubmenu.attlist (smallcptr.char.mix | accel)*) ;
classname ::= classname::(classname.attlist smallcptr.char.mix*) ;
street ::= street::(street.attlist docinfo.char.mix*) ;
sbr ::= sbr::(sbr.attlist ε) ;
primary ::= primary::(primary.attlist ndxterm.char.mix*) ;
--------------------markup::pnml-ext-inhibitor.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-ext-reset.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-ext-resetinhibitor.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-highlevelnet.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-hlpng.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-pnmlcoremodel.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-ptnet.bgf--------------------
reference ::= ref::string() ;
--------------------markup::pnml-symmetricnet.bgf--------------------
reference ::= ref::string() ;
--------------------markup::wiki-mediawiki-bnf.bgf--------------------
whitespace ::= (whitespace-char whitespace?) | EOF ;
redirect ::= redirect-tag characters internal-link-start article-link internal-link-end | pipe | EOL ;
namespace ::= string() ;
underscore ::= "_" ;
link ::= internal-link | external-link ;
protocol ::= "http://" | "https://" | "ftp://" | "ftps://" | "mailto:" ;
symbol ::= html-unsafe-symbol | underscore | "." | "," ;
isbn ::= "ISBN" spaces isbn-number ;
article ::= special-block-and-more | paragraph-and-more ;
line ::= plain-text+ (spaces plain-text+)* ;
newline ::= (CR LF) | (LF CR) | CR | LF ;
definition ::= ":" inline-text ;
url ::= protocol url-path ;
page ::= page-first-char page-char* ;
paragraph ::= (newline lines-of-text?) | lines-of-text ;
table ::= "{|" (space table-parameters)? newline table-first-row "|}" ;
pipe ::= "|" ;
text ::= line+ (newline+ line+)* ;
 text ::= harmless-character+ ;
spaces ::= space+ ;
interwiki ::= "Wikipedia" ;
characters ::= character+ ;
character ::= whitespace-char | non-whitespace-char | html-entity ;
caption ::= inline-text ;
digits ::= decimal-digit+ ;
letter ::= ucase-letter | lcase-letter ;
space ::= " " ;
formatting ::= bold-italic-toggle | bold-toggle | italic-toggle ;
heading ::= level-6-heading | level-5-heading | level-4-heading | level-3-heading | level-2-heading | level-1-heading ;
dashes ::= "-"+ ;
--------------------markup::wiki-mediawiki-ebnf.bgf--------------------
comment ::= "<!--" Text? "-->" ;
table ::= table_start table_header? table_row? table_body table_end ;
header ::= header1 | header2 | header3 | header4 | header5 | header6 ;
text ::= Unicode_char* ;
digit ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "0" ;
redirect ::= "#REDIRECT" internal_link ;
name ::= balanced_text ;
namespace ::= Unicode_char Unicode_char* ;
template ::= "{{" title ("|" part)* "}}" ;
pagename ::= Unicode_char Unicode_char* ;
title ::= balanced_text ;
include ::= template | tplarg ;
tplarg ::= "{{{" title ("|" part)* "}}}" ;
part ::= (name "=")? value ;
value ::= balanced_text ;
nowiki ::= "<nowiki>" text "</nowiki>" ;
--------------------fl::antlr.bgf--------------------
apply ::= i::ID (a::atom)+ ;
function ::= n::ID (a::ID)+ "=" e::expr NEWLINE+ ;
expr ::= (b::binary) | (a::apply) | (i::ifThenElse) ;
program ::= (f::function)+ ;
ops ::= "==" | "+" | "-" ;
atom ::= ID | INT | ("(" e::expr ")") ;
binary ::= l::atom (o::ops r::atom)* ;
--------------------fl::dcg.bgf--------------------
function ::= name name+ "=" expr newline+ ;
expr ::= [binary] atom (ops atom)* ;
 expr ::= [apply] name atom+ ;
 expr ::= [ifThenElse] "if" expr "then" expr "else" expr ;
program ::= function+ ;
ops ::= [equal] "==" ;
 ops ::= [plus] "+" ;
 ops ::= [minus] "-" ;
atom ::= [literal] int ;
 atom ::= [argument] name ;
 atom ::= "(" expr ")" ;
--------------------fl::python.bgf--------------------
operators ::= "==" | "+" | "-" ;
literal ::= "-"? integer() ;
apply ::= name atom+ ;
name ::= string() ;
function ::= name name+ "=" expr ;
expr ::= binary | apply | ifThenElse ;
program ::= function+ StringEnd ;
binary ::= atom (operators atom)* ;
atom ::= name | literal | ("(" expr ")") ;
--------------------fl::txl.bgf--------------------
fun ::= id id+ "=" expression newline ;
expression ::= (expression op expression) | (id expression+) | ("if" expression "then" expression "else" expression) | ("(" expression ")") | id | number ;
program ::= fun+ ;
op ::= "+" | "-" | "==" ;
--------------------metasyntax::txl.bgf--------------------
literal ::= quotedLiteral | unquotedLiteral | (SP comment NEWoptNL?) ;
statement ::= includeStatement | keysStatement | compoundsStatement | commentsStatement | tokensStatement | defineStatement | redefineStatement | ruleStatement | functionStatement | externalStatement | (comment NL) ;
condition ::= (EX "where" "not"? "all"? NL IN commentNL* expression NL) | (EX "assert" "not"? "all"? NL IN commentNL* expression NL) ;
compound ::= literal SP ;
constructor ::= EX "construct" varid SP type NL IN replacement ;
type ::= formatCues | ("[" typeSpec "]") ;
deconstructor ::= EX skippingType? "deconstruct" "not"? "*"? type? varid NL IN pattern ;
keyword ::= (literal SP) | (key SP) ;
expression ::= varid ruleApplications? ;
ruleid ::= id | special | "#" | key ;
typeid ::= id | (SP literal) ;
program ::= statement* ;
varid ::= id ;
replacement ::= literalOrExpression* NL ;
importer ::= EX "import" varid type? NL IN pattern? ;
exporter ::= EX "export" varid type? NL IN replacement? ;
pattern ::= literalOrVariable* NL ;
--------------------metasyntax::ebnf-bgf.bgf--------------------
empty ::= "EMPTY" ;
terminal ::= start-terminal-metasymbol string() end-terminal-metasymbol ;
any ::= "ANY" ;
epsilon ::= "EPSILON" ;
nonterminal ::= start-nonterminal-metasymbol string() end-nonterminal-metasymbol ;
production ::= label? string() defining-metasymbol right-hand-side terminator-metasymbol ;
expression ::= empty | epsilon | any | value | selectable-expression | marked-expression | repetition-expression | optional-expression | terminal | nonterminal | group-expression ;
grammar ::= production+ ;
label ::= "[" string() "]" ;
definition ::= expression (" " expression)* ;
value ::= "INT" | "STR" ;
--------------------metasyntax::ebnf-iso-1.bgf--------------------
integer ::= decimal_digit+ ;
letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
syntax ::= gap_separator* (gap_free_symbol gap_separator*)+ ;
 syntax ::= bracketed_textual_comment* commentless_symbol bracketed_textual_comment* (commentless_symbol bracketed_textual_comment*)* ;
 syntax ::= syntax_rule+ ;
--------------------metasyntax::ebnf-iso-2.bgf--------------------
comment ::= "(*" comment_symbol* "*)" ;
factor ::= (integer "*")? primary ;
exception ::= factor ;
integer ::= decimal_digit+ ;
empty ::= ε ;
term ::= factor ("-" exception)? ;
syntax ::= syntax_rule+ ;
primary ::= optional_sequence | repeated_sequence | special_sequence | grouped_sequence | meta_identifier | terminal_string | empty ;
--------------------metasyntax::relaxng.bgf--------------------
any ::= (α | string() | any)* ;
other ::= ((α | string() | any)*)* ;
pattern ::= (element::((name::string()) | open-name-class common-atts open-patterns)) | (attribute::(common-atts (name::string()) | open-name-class other pattern?)) | (group::(common-atts open-patterns)) | (interleave::(common-atts open-patterns)) | (choice::(common-atts open-patterns)) | (optional::(common-atts open-patterns)) | (zeroOrMore::(common-atts open-patterns)) | (oneOrMore::(common-atts open-patterns)) | (list::(common-atts open-patterns)) | (mixed::(common-atts open-patterns)) | (ref::(name::string() common-atts other)) | (parentRef::(name::string() common-atts other)) | (empty::(common-atts other)) | (text::(common-atts other)) | (value::((type::string())? common-atts string())) | (data::(type::string() common-atts other (param::(name::string() common-atts string()))* (except::(common-atts open-patterns))?)) | (notAllowed::(common-atts other)) | (externalRef::(href::string() common-atts other)) | (grammar::(common-atts grammar-content)) ;
--------------------metasyntax::lll-kort.bgf--------------------
group ::= "(" disjunction ")" ;
basis ::= ident | literal | "%epsilon" | alternation | group ;
alternation ::= "{" basis basis "}" repetition ;
term ::= basis repetition? ;
rule ::= ident ":" disjunction ";" ;
conjunction ::= term+ ;
specification ::= rule+ ;
disjunction ::= {conjunction "|"}+ ;
repetition ::= "+" | "*" | "?" ;
--------------------metasyntax::lll-ldta.bgf--------------------
basis ::= literal | sort ;
term ::= basis repetition? ;
rule ::= sort ":" alts ";" ;
alts ::= alt alts-tail* ;
alt ::= term* ;
grammar ::= rule+ ;
repetition ::= "*" | "+" | "?" ;
--------------------metasyntax::yacc-txl.bgf--------------------
literal ::= quotedLiteral | unquotedLiteral ;
type ::= (SP "[" yac_id "]") | (SP "[" "opt" yac_idOrQuotedLiteral "]") | (SP "[" "repeat" yac_idOrQuotedLiteral plusOrStar? "]") | (SP "[" "list" yac_idOrQuotedLiteral plusOrStar? "]") ;
program ::= Yacc_Txl_Grammar ;
prec ::= yac_keyword yac_id ;
--------------------metasyntax::xsd-tennison.bgf--------------------
key ::= key::keybase ;
selector ::= selector::(annotated xpath::string()) ;
list ::= list::(annotated localSimpleType | (itemType::string())) ;
element ::= annotated fixedOrDefault ((nillable::("true" | "false")) | (block::blockSet))* ε | (type::string()) | localSimpleType | localComplexType identityConstraint* ;
documentation ::= documentation::(((source::string()) | (xml:lang::string()))* documentationContent) ;
field ::= field::(annotated xpath::string()) ;
wildcard ::= annotated ((namespace::("##any" | "##other" | ((string() | "##targetNamespace" | "##local")*))) | (processContents::("lax" | "skip" | "strict")))* ;
annotated ::= openAttrs (id::string())? annotation? ;
facet ::= annotated (fixed::("true" | "false"))? ;
keyref ::= keyref::(keybase refer::string()) ;
unique ::= unique::keybase ;
redefinable ::= topLevelSimpleType | topLevelComplexType | namedGroup | namedAttributeGroup ;
pattern ::= pattern::noFixedFacet ;
keybase ::= annotated name::string() selector field+ ;
union ::= union::(annotated (memberTypes::(string()+) localSimpleType*) | ((memberTypes::ε)? localSimpleType+)) ;
annotation ::= annotation::(openAttrs (id::string())? (documentation | appinfo)*) ;
appinfo ::= appinfo::((source::string())? appinfoContent) ;
redefine ::= redefine::(openAttrs (id::string())? schemaLocation::string() (annotation | redefinable)*) ;
any ::= any::(wildcard occurs) ;
include ::= include::(annotated schemaLocation::string()) ;
enumeration ::= enumeration::noFixedFacet ;
occurs ::= ((minOccurs::integer()) | (maxOccurs::allNNI))* ;
length ::= length::numFacet ;
import ::= annotated (schemaLocation::string())? ;
notation ::= notation::(annotated name::string() public::string() (system::string())?) ;
all ::= all::(allModel ((minOccurs::("0" | "1")) | (maxOccurs::"1"))*) ;
choice ::= choice::explicitGroup ;
sequence ::= sequence::explicitGroup ;
--------------------tescol::00000.bgf--------------------
constantid ::= CONSTID ;
constdec ::= CONST id1::CONSTID COLON t1::type ASSIGN a1::arithexp SEMI ;
addsubexp ::= multidivexp (ADD | SUB multidivexp)* ;
paralist ::= (parameter COMMA)* parameter ;
operatorsymbol ::= ADD | SUB | DIV | MULTI | EXPO ;
parexp ::= literal | (id2::CONSTID) | (id1::ID) | (LPAR arithexp RPAR) ;
syntaxsymbol ::= SEMI | COLON | COMMA | LPAR | RPAR | ASSIGN | QMARK | LBRACE | RBRACE ;
negateexp ::= (SUB negateexp) | parexp ;
vardec ::= VAR id1::ID COLON t1::type SEMI ;
type ::= INTWORD | DOUWORD ;
declaration ::= constdec | vardec | procdec ;
token ::= keyword | WS | identifier | symbol | COMMENT | literal | constantid ;
symbol ::= syntaxsymbol | operatorsymbol | comparisonsymbol ;
compoperator ::= CONJUNCT | DISJUNCT ;
connexp ::= c1::compexp (co1::compoperator c2::compexp)* ;
arithexp ::= connexp (QMARK connexp COLON connexp)? ;
literal ::= INT | DOUBLE ;
substatement ::= (SKIP SEMI) | assignment | cond | loop ;
statement ::= (LBRACE substatement* RBRACE SEMI) | substatement ;
compexp ::= addsubexp (comparisonsymbol addsubexp)* ;
assignment ::= id1::ID ASSIGN a1::arithexp SEMI ;
procdec ::= PROC id1::ID LPAR p1::paralist RPAR COLON t1::type ASSIGN s1::statement ;
expoexp ::= negateexp (EXPO negateexp)? ;
identifier ::= ID ;
keyword ::= DONE | TROLLEY | CONTAINS | CHECKOUT | SKIP | CONST | PROC | VAR | IF | THEN | ELSE | WHILE | DO | INTWORD | DOUWORD ;
parameter ::= id1::ID COLON type ;
multidivexp ::= expoexp (MULTI | DIV expoexp)* ;
loop ::= WHILE a1::arithexp DO s1::statement ;
program ::= TROLLEY n1::CONSTID CONTAINS d1::(declaration*) CHECKOUT s1::statement DONE SEMI ;
cond ::= IF a1::arithexp THEN s1::statement ELSE s2::statement ;
comparisonsymbol ::= EQUALS | NOTEQ | LT | LTE | GT | GTE ;
--------------------tescol::00001.bgf--------------------
comment ::= COMMENT ;
plusexpr ::= multExpr (PLUS | MINUS multExpr)* ;
loops ::= WHILE boolExpr DO statement ;
statement ::= assignment | conditional | loops | grstatement | SKIP ;
assignment ::= id ASSI expr ;
id ::= ID | CID ;
paramlist ::= (ID COLON types)? (COM ID COLON types)* ;
types ::= TYPEI | TYPED ;
declarations ::= constDec | varDec | procDec ;
conditional ::= IF boolExpr THEN statement ELSE statement ;
expr ::= boolExpr (MIXFIX expr COLON expr)? ;
arglist ::= OPAR (expr (COM expr)*)? CPAR ;
grstatement ::= OCB statement (SEMI statement)* CCB ;
statements ::= CHECKOUT statement SEMI ;
program ::= TROLLEY CID CONTAINS (declarations SEMI)* statements DONE SEMI ;
atom ::= INTG | DOUBLE | (ID arglist?) | (CID arglist?) | (OPAR expr CPAR) ;
--------------------tescol::00010.bgf--------------------
assign ::= VAR_ID DEFINED_AS arithmeticExpr SEMI ;
skip ::= SKIP SEMI ;
args ::= arithmeticExpr (COMMA arithmeticExpr)* ;
header ::= TROLLEY CONST_ID CONTAINS ;
type ::= INT_TYPE | DOUBLE_TYPE ;
decl ::= (constDecl | varDecl | procDecl)* ;
prog ::= header decl mainStat ;
parameter ::= i::VAR_ID COLON t::type (COMMA parameter)* ;
loop ::= WHILE LPAR b::booleanExpr RPAR DO s::stat ;
stat ::= skip | assign | cond | loop | (LCURLYPAR stat* RCURLYPAR SEMI) ;
cond ::= IF LPAR b::booleanExpr RPAR THEN ts::stat (ELSE es::stat)? ;
atom ::= INT | DOUBLE | CONST_ID | VAR_ID | (LPAR bracketedExpr RPAR) | procApply ;
--------------------tescol::00011.bgf--------------------
whilestatement ::= WHILE expression DO statement ;
type ::= INTTYPE | DOUBLETYPE ;
declarations ::= (constdeclaration | vardeclaration | procdeclaration)* ;
expression ::= atom (operator expression) | (MIXFIX l::expression COLON r::expression) | (OPARAN functionparamlist CPARAN) | ε ;
constdeclaration ::= CONST CONSTID COLON type ASSIGN expression SEMI ;
functionparamlist ::= expression (COMMA expression)* ;
vardeclaration ::= VAR identifier COLON type SEMI ;
ifstatement ::= IF expression THEN s1::statement (ELSE s2::statement) | ε ;
atom ::= literal | identifier | (OPARAN expression CPARAN) ;
literal ::= INT | DOUBLE ;
statement ::= (SKIP SEMI) | (assignmentstatement SEMI) | whilestatement | ifstatement | (OBRACE statement+ CBRACE) ;
arithmeticoperator ::= ADDITION | SUBTRACT | DIVISION | MULTIPLY | EXP ;
param ::= ID COLON type ;
booleanoperator ::= EQUAL | NONEQUAL | LESS | LESSEQUAL | MORE | MOREEQUAL | CONJUNCTION | DISJUNCTION ;
paramlist ::= param (COMMA param)* ;
identifier ::= ID | CONSTID ;
operator ::= arithmeticoperator | booleanoperator ;
procdeclaration ::= PROC ID OPARAN paramlist? CPARAN COLON type ASSIGN statement SEMI ;
program ::= TROLLEY CONSTID CONTAINS declarations CHECKOUT statement? SEMI? DONE SEMI ;
assignmentstatement ::= identifier ASSIGN expression ;
--------------------tescol::00100.bgf--------------------
skip ::= SKIP SEMI ;
sign ::= ("+" | negation)? atom ;
variable ::= VAR ID COLON type SEMI ;
type ::= INT | DOUBLE ;
declarations ::= (constant | variable | procedure)* ;
expression ::= condExpr ;
procedure ::= PROC ID LPAREN parameters RPAREN COLON type COLON_EQUALS statements ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | ID | CID | procedureApp | (LPAREN expression RPAREN) ;
statement ::= skip | assignment | ifStat | loop ;
assignment ::= ID COLON_EQUALS expression SEMI ;
parameters ::= parameter (COMMA parameter)* ;
parameter ::= (ID COLON type)* ;
relational ::= EQUALITY | NON_EQUALITY | LESS | LESS_EQUAL | GREATER_EQUAL | GREATER ;
negation ::= "-" ;
statements ::= statement | groupStatement ;
loop ::= WHILE expression DO statements ;
constant ::= CONST CID COLON type COLON_EQUALS expression SEMI ;
program ::= TROLLEY CID CONTAINS declarations CHECKOUT statements DONE SEMI EOF ;
--------------------tescol::00101.bgf--------------------
statement ::= statement_main | (OPENCURL statement_main (SEMICOLON statement_main)* CLOSECURL) ;
assignment ::= id DEFINEDAS expr ;
header ::= TROLLEY CONSTID CONTAINS header_declaration* ;
relationals ::= EQUALITY | NON_EQUALITY | L_THAN | LE_THAN | G_THAN | GE_THAN ;
id ::= ID | CONSTID ;
number ::= INT_VAL | DOUBLE_VAL ;
types ::= INTEGER | DOUBLE ;
logical ::= AND | OR ;
expr ::= a::boolean_expr (MIXFIX b::expr COLON c::expr)? ;
stat ::= header CHECKOUT body done ;
program ::= stat ;
done ::= DONE SEMICOLON ;
body ::= statement SEMICOLON ;
--------------------tescol::00110.bgf--------------------
statement ::= assignmentStatement | whileStatement | ifStatement | skipStatement | (LEFT_BRACKET (assignmentStatement | whileStatement | ifStatement | skipStatement)+ RIGHT_BRACKET) ;
unary ::= (PLUS | MINUS)* term ;
term ::= (LEFT_PAREN expression RIGHT_PAREN) | procedureApplication | (v2::VAR_ID) | CONST_ID | INTEGER | DOUBLE ;
parameters ::= parameter (COMMA parameter)* ;
parameter ::= VAR_ID COLON TYPE ;
declarations ::= constantDeclaration | variableDeclaration | procedureDeclaration ;
expression ::= conjunction (DISJUNCT conjunction)* ;
relational ::= condExpr (EQUALITY | NOT_EQUAL | LESS_THAN | LESS_THAN_OR_EQUAL | GREATER_THAN | GREATER_THAN_OR_EQUAL condExpr)* ;
conjunction ::= relational (CONJ relational)* ;
program ::= TROLLEY CONST_ID CONTAINS declarations* CHECKOUT statement* SEMI DONE SEMI ;
add ::= mult (PLUS | MINUS mult)* ;
mult ::= unary (MULT | DIV | EXPON unary)* ;
--------------------tescol::00111.bgf--------------------
statement ::= SKIP | assignment | conditional | loop ;
unary ::= (ADDITION | SUBTRACTION)? atom ;
alternative ::= compoundStatement ;
assignment ::= identifier COLON_EQUALS conditionalExpr ;
type ::= INT | DOUBLE ;
declaration ::= constDeclaration | varDeclaration | procDeclaration SEMI ;
prog ::= TROLLEY CID CONTAINS declaration* CHECKOUT compoundStatement SEMI DONE SEMI ;
identifier ::= ID | CID ;
conditional ::= IF conditionalExpr THEN consequent ELSE alternative ;
expr ::= prodExpr (ADDITION | SUBTRACTION prodExpr)* ;
loop ::= WHILE booleanExpr DO compoundStatement ;
consequent ::= compoundStatement ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | identifier | (LPAREN conditionalExpr RPAREN) ;
--------------------tescol::01000.bgf--------------------
assign ::= id DEF arith ;
statement ::= SKIP | statements | (LCBRACK statement (SEMI statement)* RCBRACK) ;
constdec ::= CONST CONSTID COL type DEF arith SEMI ;
nums ::= VARID | CONSTID | INTNUM | DOUBNUM ;
param ::= (l::id COL ltype::type (COMMA r::id COL rtype::type)*)? ;
condstatement ::= IF orExpr THEN statement ELSE statement ;
arith ::= orExpr (QUES arith COL arith)? ;
procdec ::= PROC id LBRACK param RBRACK COL type DEF statement SEMI ;
id ::= CONSTID | VARID ;
procapp ::= id LBRACK arith (COMMA arith)* RBRACK ;
vardec ::= VAR id COL type SEMI ;
type ::= INT | DOUBLE ;
declarations ::= (constdec | vardec | procdec)+ ;
loop ::= WHILE orExpr DO statement ;
statements ::= assign | condstatement | loop ;
program ::= TROLLEY CONSTID CONTAINS declarations CHECKOUT statement SEMI DONE SEMI ;
atom ::= INTNUM | DOUBNUM | id | procapp | (LBRACK arith RBRACK) ;
--------------------tescol::01001.bgf--------------------
statement ::= grouped | SKIP | assignment | conditional | loop ;
grouped ::= STST (statement SEMI)+ STED ;
assignment ::= variable DEF arith_exp ;
variable ::= VAR_ID ;
type ::= INT_T | DOUBLE_T ;
declaration ::= const_dec | var_dec | proc_dec ;
conditional ::= IF bool_exp THEN statement ELSE statement ;
typename ::= INT | DOUBLE ;
constant ::= CONST_ID ;
loop ::= WHILE bool_exp DO statement ;
program ::= TROLLEY CONST_ID CONTAINS declaration* CHECKOUT statement SEMI DONE SEMI ;
procedure ::= VAR_ID OPEN params_given CLOSE ;
atom ::= type | constant | variable | procedure | (OPEN arith_exp CLOSE) ;
minus ::= atom | (MINUS minus) ;
--------------------tescol::01010.bgf--------------------
logicop ::= AND | OR ;
addsub ::= ADDITION | POSITIVE | SUBTRACTION | NEGATIVE ;
constdec ::= CONST CONSTID COLON type ASSIGN expr SEMI ;
paramdecs ::= (paramdec (COMMA paramdec)* COMMA?)? ;
sign ::= POSITIVE | NEGATIVE ;
whiledo ::= WHILE cond DO statement ;
vardec ::= VAR id COLON type SEMI ;
argslist ::= LPARA (expr (COMMA expr)* COMMA?)? RPARA ;
type ::= INT | DOUBLE ;
declaration ::= procdec | constdec | vardec ;
positive ::= POSITIVE | ADDITION ;
andcond ::= pred (AND pred)* ;
expr ::= cond (QUEST expr COLON expr)? ;
negative ::= NEGATIVE | SUBTRACTION ;
comments ::= COMMENT* ;
ifthenelse ::= IF cond thenclause elseclause ;
statement ::= SKIP | (LCURL statement (SEMI statement)* RCURL) | assignment | ifthenelse | whiledo ;
arithop ::= POSITIVE | NEGATIVE | ADDITION | SUBTRACTION | MUL | DIV | EXP ;
procdec ::= PROC procdescribe COLON type ASSIGN statement SEMI ;
elseclause ::= ELSE statement ;
cond ::= andcond (OR andcond)* ;
vartype ::= CONST | VAR | PROC ;
pred ::= sub_add_expr (comparator sub_add_expr)? ;
procdescribe ::= id LPARA paramdecs RPARA ;
bracketexpr ::= LPARA expr RPARA ;
id ::= ID | CONSTID ;
comparator ::= EQL | NEQL | GRT | GRTE | LST | LSTE ;
paramdec ::= id COLON type ;
expexpr ::= atom (EXP expexpr)? ;
atom ::= (negative unsignedatom) | unsignedatom ;
assignment ::= id ASSIGN expr ;
thenclause ::= THEN statement ;
number ::= INUM | NUM ;
unsignedatom ::= bracketexpr | (id argslist?) | (sign number) | number ;
program ::= TROLLEY CONSTID CONTAINS declaration* CHECKOUT statement SEMI DONE SEMI EOF ;
--------------------tescol::01011.bgf--------------------
skip ::= "skip" SEMI ;
proceduredecl ::= "proc" ID LBRACK parameter (COMMA parameter)* RBRACK COLON INT | DOUBLE ASSIGN statement ;
addition ::= mult (PLUS | MINUS mult)* ;
relation ::= addition (EQUALITY | LTHAN | MTHAN | NOTEQUAL | LEQUAL | MEQUAL addition)* ;
disj ::= conj (DISJ relation)* ;
variable ::= "var" ID COLON INT | DOUBLE SEMI ;
expression ::= disj ("\?" disj COLON disj)? ;
mult ::= unary (MULTI | DIVIS | EXPO unary)* ;
statement ::= (LBRACE statement+ RBRACE SEMI) | skip | assignment | conditional | loop | procedureapp | ret ;
unary ::= (PLUS | negation)* term ;
procedureapp ::= ID "(" (expression (COMMA expression)*)? ")" SEMI? ;
assignment ::= ID ASSIGN expression SEMI ;
term ::= procedureapp | ID | ("(" expression ")") | INUMB | DNUMB ;
parameter ::= ID COLON INT | DOUBLE ;
conj ::= relation (CONJ relation)* ;
conditional ::= IF expression THEN statement+ (ELSE statement+)? ;
negation ::= "-" ;
loop ::= WHILE expression DO statement+ ;
constant ::= "const" ID COLON INT | DOUBLE ASSIGN expression SEMI ;
program ::= TROLLEY ID CONTAINS (constant | variable | proceduredecl)+ CHECKOUT statement+ DONE SEMI EOF ;
ret ::= "currentProc" ASSIGN expression SEMI ;
--------------------tescol::01100.bgf--------------------
skip ::= SKIPTOKEN SEMICOLON ;
constdec ::= CONST constidentifier COLON type DEFINE expression SEMICOLON ;
addition ::= substract ((ADDITION substract)+) | ε ;
vardec ::= VAR identifier COLON type SEMICOLON ;
type ::= TYPEINT | TYPEDOUBLE ;
declaration ::= dec+ ;
divide ::= exponent ((DIVISION exponent)+) | ε ;
expression ::= condExp ;
multipli ::= divide ((MULTIPLICATION divide)+) | ε ;
stat ::= skip | assign | cond | loop ;
procedure ::= identifier LEFTPARENTHESIS ε | (expression (COMA expression)*) RIGHTPARENTHESIS ;
conjunct ::= comparison ((CONJUNCTION comparison)+) | ε ;
atom ::= number | procedure | identifier | (LEFTPARENTHESIS condExp RIGHTPARENTHESIS) | (SUBSTRACTION condExp) ;
exponent ::= atom (EXPONENT atom) | ε ;
assign ::= identifier DEFINE expression SEMICOLON ;
constidentifier ::= CONSTID ;
procdec ::= PROCEDURE id::identifier LEFTPARENTHESIS (RIGHTPARENTHESIS COLON type DEFINE statements) | (ids::identifier COLON type (COMA ids::identifier COLON type)* RIGHTPARENTHESIS COLON type DEFINE statements) ;
number ::= (ADDITION? INT) | (ADDITION? DOUBLE) | (SUBSTRACTION INT) | (SUBSTRACTION DOUBLE) ;
identifier ::= ID | constidentifier ;
comparison ::= (a2::addition booleanSymbols a1::addition) | addition ;
disjunct ::= conjunct ((DISJUNCTION conjunct)+) | ε ;
statements ::= stat | (LEFTCURLY stat+ RIGHTCURLY SEMICOLON) ;
loop ::= WHILE expression DO statements ;
program ::= (TROLLEY constidentifier CONTAINS declaration CHECKOUT statements DONE SEMICOLON) | (TROLLEY constidentifier CONTAINS CHECKOUT statements DONE SEMICOLON) ;
cond ::= IF expression THEN dothen::statements ELSE doelse::statements ;
dec ::= constdec | vardec | procdec ;
substract ::= multipli ((SUBSTRACTION multipli)+) | ε ;
--------------------tescol::01101.bgf--------------------
skip ::= SKIP SEMI ;
statement ::= conditional | loop | assignment | skip | procedure_call ;
decleration ::= (const_dec | var_dec | proc_dec)* ;
assignment ::= varIDs BECOMES mix_fix SEMI ;
parameters ::= mix_fix (COMMA mix_fix)* ;
parameter ::= varIDs COLON TYPE ;
conditional ::= IF OPENPARENTHESIS bool_disjunction CLOSEDPARENTHESIS then_statement else_statement ;
checkout ::= CHECKOUT OPENBRACKET statement* CLOSEDBRACKET SEMI DONE SEMI ;
exponential ::= negation (EXP negation)* ;
negation ::= (SUB atom) | atom ;
trolley ::= TROLLEY varIDs CONTAINS decleration ;
loop ::= WHILE bool_disjunction do_statement ;
program ::= trolley checkout ;
atom ::= procedure_call | CID | ID | (OPENPARENTHESIS mix_fix CLOSEDPARENTHESIS) | INT | DOUBLE ;
--------------------tescol::01110.bgf--------------------
unary ::= ("+" | negation)* atom ;
statement ::= assignment | ifStat | loopStat | skipStat | (LBRACE statement+ RBRACE SEMI) ;
assignment ::= CID | ID COLON_EQUALS mixFix SEMI ;
relation ::= addSubExpr (EQUALITY | NON_EQUALITY | LESS | LESS_EQUAL | GREATER_EQUAL | GREATER addSubExpr)* ;
type ::= (INT | DOUBLE)? ;
declaration ::= constDec | varDec | procDec ;
prog ::= TROLLEY CID CONTAINS declaration* checkoutStat ;
negation ::= "-" ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | ID | CID | procCall | (LPAREN mixFix RPAREN) ;
--------------------tescol::01111.bgf--------------------
comment ::= COMMENT ;
operations ::= EQUALITY | NONEQUALITY | LESSTHAN | LESSTHANOREQUAL | GREATERTHAN | GREATERTHANOREQUAL ;
number ::= INTKEYWORD | DOUBLEKEYWORD ;
declarations ::= (CONST constDec SEMI) | (VAR varDec SEMI) | (PROC procDec) ;
stat ::= conditionalStat | loopStat | (assignStat SEMI) | (SKIP SEMI) | (LPAR stat+ RPAR SEMI) ;
program ::= progTree+ ;
atom ::= CONSTID | VARANDPROCID | (("+" | "-")? INTVALUE) | (("+" | "-")? DOUBLEVALUE) | applyProc | (OPAR arithmeticExpression CPAR) ;
--------------------tescol::10000.bgf--------------------
assign ::= a::(CID | ID) COLON_EQUALS condExpr ;
decl ::= (VAR ID COLON INT | DOUBLE SEMI NEWLINE*) | (CONST CID COLON INT | DOUBLE COLON_EQUALS condExpr SEMI NEWLINE*) | (PROC a::ID LPAREN (decl (COMMA decl)*)? RPAREN COLON_EQUALS stat SEMI NEWLINE*) ;
prog ::= TROLLEY CID CONTAINS NEWLINE* decl* CHECKOUT NEWLINE* stat DONE SEMI ;
expr ::= multExpr (ADDITION | SUBTRACTION multExpr)* ;
whileloop ::= WHILE LPAREN boolExpr RPAREN DO stat ;
stat ::= condExpr | SKIP | assign | multStat | ifthenelse | whileloop ;
ifthenelse ::= IF LPAREN boolExpr RPAREN THEN stat (SEMI ELSE stat)? ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | (a::(CID | ID) (LPAREN (expr (COMMA expr)*)? RPAREN)?) | (LPAREN condExpr RPAREN) ;
--------------------tescol::10001.bgf--------------------
cid ::= i::CIDENT ;
assignment ::= id COLON_EQUALS condExpr SEMI ;
id ::= i::IDENT ;
type ::= INT | DOUBLE ;
prog ::= stat+ ;
checkout ::= CHECKOUT stat SEMI? DONE SEMI ;
whilestat ::= WHILE e::condExpr DO s::stat ;
trolley ::= TROLLEY cid CONTAINS def* ;
expr ::= multExpr (ADDITION | SUBTRACTION multExpr)* ;
def ::= (CONST n::cid COLON t::type COLON_EQUALS e::expr SEMI) | (VAR vartypedef SEMI) | (procedure SEMI) ;
proccall ::= i::id LPAREN (a::atom (COMMA a::atom)*)? RPAREN ;
vartypedef ::= id COLON INT | DOUBLE ;
stat ::= (expr SEMI) | trolley | checkout | assignment | ifstat | whilestat | (SKIP SEMI) | (LBRACE stat+ RBRACE) | SEMI ;
procedure ::= PROC i::id LPAREN (a::vartypedef (COMMA a::vartypedef)*)? RPAREN COLON_EQUALS s::stat ;
ifstat ::= IF e::condExpr THEN ts::stat ELSE es::stat ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | id | cid | (LPAREN condExpr RPAREN) | proccall ;
--------------------tescol::10010.bgf--------------------
statement ::= SKIP | assignment | conditional | loop | statementList ;
assignment ::= ID DEF arithmeticExpression ;
constdecl ::= CONST ID COLON type DEF arithmeticExpression ;
type ::= INTKEYWORD | DOUBLEKEYWORD ;
arithmetic ::= number (arithmeticOperator number)* ;
declaration ::= constdecl | vardecl | procdecl SEMI ;
number ::= INT | DOUBLE | ID | (LPAREN conditionalExpression RPAREN) ;
expression ::= number (arithmeticOperator number)* ;
conditional ::= IF booleanExpression THEN statement ELSE statement ;
operator ::= DEF | QUESTION | CONJUNC | DISJUNC | arithmeticOperator | relationalOperator ;
loop ::= WHILE booleanExpression DO statement ;
program ::= TROLLEY ID CONTAINS declaration+ CHECKOUT statement SEMI DONE SEMI ;
vardecl ::= VAR ID COLON type ;
procdecl ::= PROC ID LPAREN parameterList RPAREN COLON type DEF statement ;
--------------------tescol::10011.bgf--------------------
sign ::= (MINUS | PLUS)? atom ;
expon ::= sign (EXPON sign)* ;
vardec ::= VAR parameter SEMI ;
type ::= INTEGER | DOUBLE ;
declaration ::= consdec | vardec | procdec ;
cexpr ::= bexpr (QM cexpr COLON cexpr)? ;
bexpr ::= con (DISJUN con)* ;
aexpr ::= cexpr ;
expr ::= (multExpr (PLUS | MINUS multExpr)*) | procapp ;
aexprlist ::= aexpr (COMMA aexpr)* ;
rop ::= EQ | NEQ | LESS | MORE | LESSEQ | MOREEQ ;
atom ::= number | VARIABLE | CONSTANT | (LPAR cexpr RPAR) ;
consdec ::= CONST CONSTANT COLON type DEFAS aexpr SEMI ;
statement ::= SKIP | assignment | conditional | loop ;
assignment ::= VARIABLE DEFAS aexpr ;
statementlist ::= statement | (LCPAR statement (SEMI statement)* RCPAR) ;
procdec ::= PROC VARIABLE LPAR paramlist RPAR COLON type DEFAS statementlist SEMI ;
paramlist ::= parameter (COMMA parameter)* ;
procapp ::= VARIABLE LPAR aexprlist RPAR ;
parameter ::= VARIABLE COLON type ;
number ::= INT | DUB ;
ropexpr ::= expr (rop expr)? ;
conditional ::= IF bexpr THEN statementlist ELSE statementlist ;
loop ::= WHILE bexpr DO statementlist ;
program ::= TROLLEY CONSTANT CONTAINS declaration* CHECKOUT statementlist SEMI DONE SEMI ;
con ::= ropexpr (CONJUN ropexpr)* ;
--------------------tescol::10100.bgf--------------------
statement ::= statementList | condStatement | expression | assignment | loop | SKIP ;
assignment ::= ID COLON_EQUALS expression ;
paramlist ::= LPAREN (ID COLON type (COMMA ID COLON type)*)? RPAREN ;
type ::= INT | DOUBLE ;
prog ::= NEWLINE* TROLLEY NEWLINE* CID NEWLINE* CONTAINS NEWLINE* declarations NEWLINE* statement NEWLINE* SEMI NEWLINE* DONE NEWLINE* SEMI ;
declarations ::= (individual_declaration NEWLINE*)* CHECKOUT ;
expression ::= andExpression (QUESTION andExpression COLON andExpression)? ;
loop ::= WHILE expression DO statement ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | ID | CID | (LPAREN expression RPAREN) ;
--------------------tescol::10101.bgf--------------------
statement ::= SKIP | (ID ASSIGN condExpr) | (IF boolExpr THEN statement ELSE statement) | (WHILE boolExpr DO statement) ;
proceduredec ::= PROCEDURE pid1::ID PARENOPEN (pid2::ID COLON type (COMMA pid3::ID COLON type)*)* PARENCLOSE COLON type ASSIGN mainstatement SEMI ;
constantdec ::= CONSTANT CONSTANTID COLON type ASSIGN condExpr SEMI ;
type ::= INT | FLOAT ;
declaration ::= variabledec | constantdec | proceduredec ;
mainstatement ::= ε | statement | (STATEMENTOPEN statement (SEMI statement)* STATEMENTCLOSE) ;
variabledec ::= VARIABLE ID COLON type SEMI ;
expr ::= multExpr (ADDITION | SUBTRACTION multExpr)* ;
program ::= TROLLEY CONSTANTID CONTAINS declaration* CHECKOUT mainstatement SEMI DONE SEMI ;
atom ::= INTEGER | FLOATINGPOINT | CONSTANTID | ID | (PARENOPEN condExpr PARENCLOSE) | procedureList ;
unaryneg ::= SUBTRACTION* atom ;
--------------------tescol::10110.bgf--------------------
comment ::= COMMENT ;
whitespace ::= WS ;
type ::= "int" | "double" ;
proc ::= "proc" identifier "(" identifier COLON type (COMMA identifier COLON type)* ")" COLON type DEFINED_AS statement* SEMI ;
comparator ::= EQUALITY | NON_EQUALITY | LESS_THAN | GREATER_THAN | LESS_THAN_EQ | GREATER_THAN_EQ ;
expr ::= negation? expr2 ;
atom ::= INT | DOUBLE | ID | CID | (LPAR condExpr RPAR) | procedure_expr ;
statement ::= SKIP | conditional | loop | assignment | cond_expr | (CURLY_L SKIP | conditional | loop | assignment | cond_expr (SEMI statement)* CURLY_R) ;
assignment ::= identifier DEFINED_AS expr ;
cidentifier ::= CID ;
identifier ::= ID | CID ;
var ::= "var" identifier COLON type SEMI ;
conditional ::= IF condExpr THEN statement ELSE statement ;
negation ::= "-" ;
loop ::= WHILE boolExpr DO statement ;
constant ::= "const" cidentifier COLON type DEFINED_AS expr SEMI ;
operator ::= ADD | SUBTRACT | MULTIPLY | DIVIDE | EXPONENTIATION | EQUAL ;
program ::= TROLLEY cidentifier CONTAINS dec* CHECKOUT CURLY_L (statement (SEMI statement)*)? CURLY_R SEMI DONE SEMI EOF ;
dec ::= constant | var | proc ;
--------------------tescol::10111.bgf--------------------
statement ::= (KW_SKIP SYM_SEMI) | (a::varproc_id SYM_ASS c::mixfix SYM_SEMI) | (SYM_OPEN_BRACE statement+ SYM_CLOSE_BRACE SYM_SEMI) | (KW_IF mixfix KW_THEN statement KW_ELSE statement) | (KW_WHILE mixfix KW_DO statement) ;
term ::= div_subterm (SYM_MULT div_subterm)* ;
type ::= KW_TYPE_INT | KW_TYPE_DOUBLE ;
decl ::= (const_decl | var_decl SYM_SEMI) | proc_decl ;
prog ::= KW_TROLLEY ID_GENERAL KW_CONTAINS decl* KW_CHECKOUT statement KW_DONE SYM_SEMI ;
mixfix ::= predicate (SYM_QM mixfix SYM_COLON mixfix)? ;
predicate ::= pred_term (SYM_OR pred_term)* ;
comparator ::= SYM_EQ | SYM_INEQ | SYM_GT | SYM_NS_GT | SYM_LT | SYM_NS_LT ;
molecule ::= atom (SYM_EXP molecule)? ;
parenthesised ::= SYM_OPEN_PAREN mixfix SYM_CLOSE_PAREN ;
expr ::= subtraction_subexpr (SYM_ADD subtraction_subexpr)* ;
immediate ::= integerNum | doubleNum ;
atom ::= immediate | (v::varproc_id) | proc_call | parenthesised ;
--------------------tescol::11000.bgf--------------------
skip ::= SKIP ;
whilestatement ::= WHILE expression DO statements ;
addition ::= multiply (ADDITION multiply)* ;
variable ::= VARIABLE ID | CID COLON INTEGER | DOUBLE SEMI ;
relationships ::= EQUALITY | NONEQUALITY | GREATERTHAN | LESSTHAN | GREATEROREQUAL | LESSOREQUAL ;
divide ::= negation (DIVISION negation)? ;
declarations ::= constant | variable | procedure ;
expression ::= runproc ;
conjunction ::= booleanop (AND booleanop)* ;
subtraction ::= addition (SUBTRACTION addition)* ;
procedure ::= PROCEDURE ID | CID LEFTBRACKET parameters RIGHTBRACKET COLON numbervalues DEFINE statements ;
expo ::= atom (EXPONENTIATION atom)? ;
ifstatement ::= IF LEFTBRACKET expression RIGHTBRACKET THEN statements ELSE statements ;
atom ::= INT | DOU | ID | CID | (LEFTBRACKET expression RIGHTBRACKET) ;
statement ::= ifstatement | whilestatement | skip | assignment SEMI ;
assignment ::= ID | CID DEFINE expression ;
numbervalues ::= INTEGER | DOUBLE ;
parameters ::= (parameter (COMMA parameter)*)? ;
booleanop ::= subtraction (relationships subtraction)? ;
parameter ::= ID | CONSTANT COLON numbervalues ;
checkout ::= CHECKOUT statements ;
negation ::= (ADDITION | SUBTRACTION)? expo ;
trolley ::= TROLLEY CID CONTAINS declarations* ;
multiply ::= divide (MULTIPLICATION divide)* ;
statements ::= statement | (CURLYLEFT statement statement* CURLYRIGHT) SEMI ;
constant ::= CONSTANT CID COLON INTEGER | DOUBLE DEFINE expression SEMI ;
program ::= trolley checkout done ;
conditexpr ::= disjunction (QUESTION disjunction COLON disjunction)* ;
disjunction ::= conjunction (OR conjunction)* ;
done ::= DONE SEMI ;
runproc ::= conditexpr | (ID | CID LEFTBRACKET (expression (COMMA expression)*)? RIGHTBRACKET) ;
--------------------tescol::11001.bgf--------------------
contains ::= CONTAINS (procdeclaration | constdeclaration | vardeclaration SEMI)* ;
whilestatement ::= WHILE exp::expression DO statement ;
id ::= name::(CONSTID | VARID) ;
argumentlist ::= (exp::expression (COMMA args::argumentlist)?) | ε ;
type ::= TINT | TDOUBLE ;
mixfix ::= e::conjunction (QUESTION t::mixfix COLON f::mixfix)? ;
expression ::= e::mixfix ;
constdeclaration ::= CONST name::CONSTID COLON t::type DEFINEDAS exp::expression ;
conjunction ::= l::disjunction (AND r::disjunction)* ;
proccall ::= proc::varid LPAREN args::argumentlist RPAREN ;
vardeclaration ::= VAR name::varid COLON t::type ;
ifstatement ::= IF exp::expression THEN statement ELSE statement ;
statement ::= SKIP | (LBRACE statement (SEMI statement)* SEMI? RBRACE) | assignment | ifstatement | whilestatement ;
assignment ::= name::id DEFINEDAS exp::expression ;
number ::= (f::FLOAT) | (i::INT) | (u::UINT) ;
comparison ::= l::addition_exp (c::conditional r::addition_exp)? ;
parameterlist ::= (name::varid COLON t::type (COMMA params::parameterlist)?) | ε ;
conditional ::= (t::EQUALITY) | (t::INEQUALITY) | (t::LANGLE) | (t::RANGLE) | (t::LTEQUALS) | (t::GTEQUALS) ;
checkout ::= CHECKOUT statement SEMI ;
procdeclaration ::= PROC name::varid LPAREN params::parameterlist RPAREN COLON t::type DEFINEDAS content::statement ;
program ::= TROLLEY CONSTID contains checkout done ;
disjunction ::= l::comparison (OR r::comparison)* ;
varid ::= CONSTID | VARID ;
done ::= DONE SEMI ;
--------------------tescol::11010.bgf--------------------
type ::= INTEGER | FLOATDOUBLE ;
declarations ::= (CONST constDec SEMI) | (VAR varDec SEMI) | (PROC procDec SEMI) ;
stat ::= conditionalStat | loopStat | assignStat | (LEFTBRACE stat (SEMI stat)* RIGHTBRACE SEMI) | SKIP ;
program ::= progTree+ ;
atom ::= CONSTID | ID | INT | DOUBLE | (LEFTPAR condExpr RIGHTPAR) | applyProc ;
--------------------tescol::11011.bgf--------------------
assign ::= ids DEFAS expr ;
statement ::= assign | SKIP | conditional | loop | statement_group ;
declarations ::= CONTAINS (dec_const | dec_var | dec_proc)* ;
ids ::= ID | CONST_ID ;
conditional ::= IF exp_bools THEN statement ELSE statement ;
expr ::= exp_bools (QMARK expr COLON expr)? ;
loop ::= WHILE exp_bools DO statement ;
statements ::= CHECKOUT statement SEMI ;
program ::= TROLLEY CONST_ID declarations statements DONE SEMI ;
atom ::= INT | DOUBLE | (ids argument_list?) | (LPAR expr RPAR) ;
--------------------tescol::11100.bgf--------------------
unary ::= (t::MINUS)* atom ;
statement ::= (SKIP SEMI) | (ID ASSIGNMENT expression SEMI) | (IF boolexp THEN statement ELSE statement) | (WHILE boolexp DO statement) | (LEFTBRACE statement+ RIGHTBRACE) ;
addition ::= t::mult (addop mult)* ;
type ::= INTTYPE | DOUBLETYPE ;
parameters ::= parameter (COMMA parameter)* ;
parameter ::= ID COLON type ;
expression ::= boolexp (QMARK t::mult COLON f::mult)? ;
predicate ::= t::addition (COMPARISON u::addition)? ;
arguments ::= expression (COMMA expression)* ;
program ::= TROLLEY CONSTID CONTAINS (definition SEMI?)* CHECKOUT statement SEMI? DONE SEMI ;
boolexp ::= t::predicate (BOOLOPERATOR u::predicate)* ;
definition ::= (CONST CONSTID COLON type ASSIGNMENT expression) | (VAR ID COLON type) | (PROC ID LEFTBRACKET parameters? RIGHTBRACKET COLON type ASSIGNMENT statement) ;
addop ::= PLUS | MINUS ;
value ::= INT | DOUBLE ;
procedurecall ::= ID LEFTBRACKET arguments? RIGHTBRACKET ;
atom ::= procedurecall | ID | CONSTID | (LEFTBRACKET expression RIGHTBRACKET) | value ;
mult ::= t::unary (MULTIPLIER unary)* ;
--------------------tescol::11101.bgf--------------------
procedureapplication ::= varprocidentifier PARENTHESISL arguments PARENTHESISR ;
type ::= INT | DBLE ;
declaration ::= constdeclaration | vardeclaration | procdeclaration ;
prog ::= TROLLEY constantidentifier CONTAINS declaration* CHECKOUT statement DONE SEMI ;
multdivexpression ::= a1::atom (EXPONENTIATION | DIVISION | MULTIPLICATION a2::atom)* ;
expression ::= (p1::procedureapplication) | (b1::booleanexpression (QUESTION expression COLON expression)?) ;
constdeclaration ::= CONST constantidentifier COLON type DEFINED expression SEMI ;
arguments ::= e1::expression (COMMA e2::expression)* ;
vardeclaration ::= VAR varprocidentifier COLON type SEMI ;
atom ::= constantidentifier | varprocidentifier | number | (PARENTHESISL expression PARENTHESISR) ;
groupedstatement ::= BRACKETL statement+ BRACKETR SEMI ;
andexpression ::= c1::compexpression (CONJUNCTION compexpression)* ;
statement ::= (SKIP SEMI) | assignment | conditional | loop | groupedstatement ;
constantidentifier ::= CONSTID ;
assignment ::= varprocidentifier DEFINED ae::expression SEMI ;
number ::= INTEGER | DOUBLE ;
parameter ::= varprocidentifier COLON type ;
parameterlist ::= PARENTHESISL (parameter (COMMA parameter)*)? PARENTHESISR ;
compexpression ::= ar1::arithexpression (ROP arithexpression)? ;
varprocidentifier ::= VARPROCID ;
conditional ::= IF booleanexpression THEN statement ELSE statement ;
arithexpression ::= m1::multdivexpression (ADDITION | SUBTRACTION m2::multdivexpression)* ;
loop ::= WHILE booleanexpression DO statement ;
procdeclaration ::= PROC varprocidentifier parameterlist COLON type DEFINED statement SEMI ;
booleanexpression ::= an1::andexpression (DISJUNCTION andexpression)* ;
--------------------tescol::11110.bgf--------------------
statement ::= (e::singleStatement) | (b::listofStatement) ;
type ::= INT | DOUBLE ;
prog ::= stat+ ;
declarations ::= (constDeclaration | varDeclaration | proDeclaration)+ ;
stat ::= compilationUnit ;
atom ::= INTEGER | FLOAT | CONSTID | ("(" conditionalExpr ")") | applyProcedure | ID ;
--------------------tescol::11111.bgf--------------------
expon ::= unary (EXPONENTIATION unary)* ;
id ::= CONSTID | VARID ;
type ::= INT | DOUBLE ;
declaration ::= constant_declaration | variable_declaration | procedure_declaration ;
expression ::= disjunction (MIXFIX expression COLON expression)? ;
conjunction ::= relational (CONJUNCTION relational)* ;
proc ::= id LPAREN (term (COMMA term)*)? RPAREN ;
mult ::= expon (MULTIPLICATION | DIVISION expon)* ;
statement ::= single_statement | multiple_statement ;
unary ::= negation* term ;
assignment ::= id ASSIGN expression ;
term ::= INT_NUMBER | DOUBLE_NUMBER | (LPAREN expression RPAREN) | id | proc ;
relational ::= add (relational_op add)* ;
conditional ::= IF expression THEN statement ELSE statement ;
negation ::= SUBTRACTION ;
loop ::= WHILE expression DO statement ;
program ::= TROLLEY CONSTID CONTAINS declaration* CHECKOUT statement SEMI DONE SEMI ;
disjunction ::= conjunction (DISJUNCTION conjunction)* ;
add ::= mult (ADDITION | SUBTRACTION mult)* ;
--------------------tescol::reference.bgf--------------------
statement ::= stmtElem | stmtList ;
assign ::= (a::ID) | (a::CONSTID) DEFAS e::expression ;
unary ::= SUB* term ;
exp ::= a::unary (EXP unary)* ;
disj ::= a::equality (DISJUNC b::equality)* ;
relation ::= a::add (RELOP b::add)? ;
term ::= (LPAR expression RPAR) | (CONSTID p::procApp) | (ID p::procApp) ;
type ::= INT | DOUB ;
equality ::= a::relation (EQOP b::relation)? ;
declaration ::= constDecl | varDecl | procDecl ;
number ::= INTEGER | DOUBLE ;
expression ::= a::conj (TE b::expression COLON c::expression)? ;
conj ::= a::disj (CONJUNC b::disj)* ;
loop ::= WHILE e::expression DO statement ;
program ::= TROLLEY CONSTID CONTAINS (declaration SEMI)* CHECKOUT statement SEMI DONE SEMI ;
add ::= a::mult (ADD | SUB b::mult)* ;
mult ::= a::exp (MULTOP b::exp)* ;
--------------------metamodels::Marte.bgf--------------------
rtf ::= base_BehavioralFeature::BehavioralFeature base_Action::Action base_Message::Message base_Signal::Signal utility::MARTE_DataTypes/UtilityType occKind::BasicNFP_Types/ArrivalPattern tRef::MARTE_Foundations/Time/TimedInstantObservation relDl::BasicNFP_Types/NFP_Duration absDl::BasicNFP_Types/NFP_DateTime boundDl::BasicNFP_Types/NFP_BoundedDuration rdTime::BasicNFP_Types/NFP_Duration miss::BasicNFP_Types/NFP_Percentage priority::BasicNFP_Types/NFP_Integer ;
--------------------metamodels::MICRO.owl.bgf--------------------
activity ::= paper_assignment ;
 activity ::= bidding_of_reviewer ;
 activity ::= managing_of_conference_process ;
 activity ::= reviewing_proces ;
 activity ::= notification ;
 activity ::= submission_process ;
 activity ::= is_followed_by::activity is_monitored_by::human has_intensity::intensity has_result::article is_performed_by::human is_supervised_by::human ;
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::activity is_employed_in::institute has_topic_of_interest::Topic supervises::activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::article is_performed_by::human ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= Review ;
 article ::= goes_through::activity is_sent_to::human is_created_in::activity structure_created_by::human has_author::human gives_classification::classification article_written_by::Author has_reviewer::Reviewer has_abstract::Abstract ;
session ::= conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime (eventOnList::Thing)+ partOfEvent::Event hasEvent::Event (organisedBy::Thing)+ heldIn::Location ;
classification ::= ε ;
chair ::= assigns_reviewers_to_article::Reviewer creates_program::program ;
institute ::= ε ;
program ::= program_created_by::chair has_session::session ;
participant ::= submits_to_conference::Conference ;
intensity ::= ε ;
--------------------metamodels::OpenConf.owl.bgf--------------------
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::Activity is_employed_in::institute has_topic_of_interest::Topic supervises::Activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::article is_performed_by::human ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= Review ;
 article ::= goes_through::Activity is_sent_to::human is_created_in::Activity structure_created_by::human has_author::human gives_classification::classification article_written_by::Author has_reviewer::Reviewer has_abstract::Abstract ;
session ::= conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime (eventOnList::Thing)+ partOfEvent::Event hasEvent::Event (organisedBy::Thing)+ heldIn::Location ;
classification ::= ε ;
institute ::= ε ;
program ::= program_created_by::Chair has_session::session ;
participant ::= submits_to_conference::Conference ;
intensity ::= ε ;
--------------------metamodels::PCS.owl.bgf--------------------
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::Activity is_employed_in::institute has_topic_of_interest::Topic supervises::Activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::article is_performed_by::human ;
session ::= starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime (eventOnList::Thing)+ partOfEvent::Event hasEvent::Event (organisedBy::Thing)+ heldIn::Location conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator ;
classification ::= ε ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= article_written_by::Author has_reviewer::Reviewer has_abstract::Abstract goes_through::Activity is_sent_to::human is_created_in::Activity structure_created_by::human has_author::human gives_classification::classification ;
chair ::= was_a_committee_chair_of::Committee assigns_reviewers_to_article::Reviewer creates_program::program ;
institute ::= ε ;
program ::= program_created_by::chair has_session::session ;
intensity ::= ε ;
--------------------metamodels::XUL-Interactorl.bgf--------------------
row ::= (xulInteractors::Interactor)+ ;
column ::= (xulInteractors::Interactor)+ ;
vbox ::= (xulInteractors::Interactor)+ ;
hbox ::= (xulInteractors::Interactor)+ ;
--------------------metamodels::confOf.owl.bgf--------------------
topic ::= ε ;
activity ::= paper_assignment ;
 activity ::= bidding_of_reviewer ;
 activity ::= managing_of_conference_process ;
 activity ::= reviewing_proces ;
 activity ::= notification ;
 activity ::= submission_process ;
 activity ::= is_followed_by::activity is_monitored_by::human has_intensity::intensity has_result::article is_performed_by::human is_supervised_by::human ;
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::activity is_employed_in::institute has_topic_of_interest::topic supervises::activity e-mail::String last_name::String first_name::String ;
conference ::= is_in_phase::phase_of_conference ;
paper ::= Accepted_Paper ;
 paper ::= Rejected_Paper ;
 paper ::= Undecided_Paper ;
 paper ::= full_paper_size::Integer has_author::human ;
notification ::= has_result::article is_performed_by::human ;
review ::= gives_classification::classification is_created_in::activity ;
classification ::= ε ;
article ::= paper ;
 article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= goes_through::activity is_sent_to::human is_created_in::activity structure_created_by::human has_author::human gives_classification::classification ;
institute ::= ε ;
intensity ::= ε ;
--------------------metamodels::confious.owl.bgf--------------------
topic ::= ε ;
activity ::= paper_assignment ;
 activity ::= bidding_of_reviewer ;
 activity ::= managing_of_conference_process ;
 activity ::= reviewing_proces ;
 activity ::= notification ;
 activity ::= submission_process ;
 activity ::= is_followed_by::activity is_monitored_by::human has_intensity::intensity has_result::article is_performed_by::human is_supervised_by::human ;
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::activity is_employed_in::institute has_topic_of_interest::topic supervises::activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::article is_performed_by::human ;
classification ::= ε ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= goes_through::activity is_sent_to::human is_created_in::activity structure_created_by::human has_author::human gives_classification::classification ;
institute ::= ε ;
intensity ::= ε ;
--------------------metamodels::crs_dr.owl.bgf--------------------
conference ::= has_program::program is_in_phase::phase_of_conference ;
document ::= article ;
 document ::= abstract ;
 document ::= review ;
 document ::= article | abstract ;
event ::= pc_meeting ;
 event ::= session ;
 event ::= conference ;
 event ::= has_startdate::dateTime has_enddate::dateTime ;
review ::= gives_classification::classification is_created_in::activity review_written_by::reviewer ;
session ::= has_startdate::dateTime has_enddate::dateTime ;
article ::= paper ;
 article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= review ;
 article ::= article_written_by::author has_reviewer::reviewer has_abstract::abstract goes_through::activity is_sent_to::human is_created_in::activity structure_created_by::human has_author::human gives_classification::classification ;
person ::= author ;
 person ::= chair ;
 person ::= participant ;
 person ::= reviewer ;
 person ::= author | chair | participant | reviewer ;
institute ::= ε ;
participant ::= submits_to_conference::conference ;
intensity ::= ε ;
topic ::= ε ;
activity ::= paper_assignment ;
 activity ::= bidding_of_reviewer ;
 activity ::= managing_of_conference_process ;
 activity ::= reviewing_proces ;
 activity ::= notification ;
 activity ::= submission_process ;
 activity ::= is_followed_by::activity is_monitored_by::human has_intensity::intensity has_result::article is_performed_by::human is_supervised_by::human ;
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::activity is_employed_in::institute has_topic_of_interest::topic supervises::activity e-mail::String last_name::String first_name::String ;
paper ::= Accepted_Paper ;
 paper ::= Rejected_Paper ;
 paper ::= Undecided_Paper ;
 paper ::= full_paper_size::Integer has_author::human ;
author ::= writes_article::article assigns_article_to_conference::article ;
notification ::= has_result::article is_performed_by::human ;
classification ::= ε ;
reviewer ::= writes_review::review ;
chair ::= assigns_reviewers_to_article::reviewer creates_program::program ;
program ::= program_created_by::chair has_session::session ;
abstract ::= part_of_article::article ;
--------------------metamodels::edas.owl.bgf--------------------
topic ::= ε ;
activity ::= paper_assignment ;
 activity ::= bidding_of_reviewer ;
 activity ::= managing_of_conference_process ;
 activity ::= reviewing_proces ;
 activity ::= notification ;
 activity ::= submission_process ;
 activity ::= is_followed_by::activity is_monitored_by::human has_intensity::intensity has_result::article is_performed_by::human is_supervised_by::human ;
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::activity is_employed_in::institute has_topic_of_interest::topic supervises::activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::article is_performed_by::human ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= Review ;
 article ::= goes_through::activity is_sent_to::human is_created_in::activity structure_created_by::human has_author::human gives_classification::classification article_written_by::Author has_reviewer::Reviewer has_abstract::abstract ;
session ::= conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime ;
classification ::= ε ;
chair ::= assigns_reviewers_to_article::Reviewer creates_program::program ;
institute ::= ε ;
program ::= program_created_by::chair has_session::session ;
participant ::= submits_to_conference::Conference ;
intensity ::= ε ;
abstract ::= part_of_article::article ;
--------------------metamodels::ekaw.owl.bgf--------------------
activity ::= paper_assignment ;
 activity ::= bidding_of_reviewer ;
 activity ::= managing_of_conference_process ;
 activity ::= reviewing_proces ;
 activity ::= notification ;
 activity ::= submission_process ;
 activity ::= is_followed_by::activity is_monitored_by::human has_intensity::intensity has_result::article is_performed_by::human is_supervised_by::human ;
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::activity is_employed_in::institute has_topic_of_interest::Topic supervises::activity e-mail::String last_name::String first_name::String ;
conference ::= Conference_volume ;
 conference ::= TwoLevelConference ;
 conference ::= SingleLevelConference ;
 conference ::= is_in_phase::phase_of_conference hasMember::Person hasName::String endDate::dateTime paperDueOn::dateTime registrationDueOn::dateTime manuscriptDueOn::dateTime startDate::dateTime hasCountry::Country hasConferenceMember::ConferenceMember paperAssignmentFinalizedBy::Administrator reviewCriteriaEnteredBy::Administrator paperAssignmentToolsRunBy::Administrator virtualMeetingEnabledBy::Administrator hardcopyMailingManifestsPrintedBy::Administrator detailsEnteredBy::Administrator reviewerBiddingStartedBy::Administrator date::date reviewsPerPaper::Integer logoURL::anyURI acceptsHardcopySubmissions::Boolean siteURL::anyURI has_program::program ;
notification ::= has_result::article is_performed_by::human ;
session ::= (eventOnList::Thing)+ partOfEvent::Event hasEvent::Event (organisedBy::Thing)+ heldIn::Location conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime ;
classification ::= ε ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= Review ;
 article ::= article_written_by::Author has_reviewer::Reviewer has_abstract::Abstract goes_through::activity is_sent_to::human is_created_in::activity structure_created_by::human has_author::human gives_classification::classification ;
chair ::= assigns_reviewers_to_article::Reviewer creates_program::program ;
institute ::= ε ;
program ::= program_created_by::chair has_session::session ;
participant ::= submits_to_conference::conference ;
intensity ::= ε ;
--------------------metamodels::iasted.owl.bgf--------------------
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::article performs_activity::Activity is_employed_in::institute has_topic_of_interest::Topic supervises::Activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::article is_performed_by::human ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= Review ;
 article ::= goes_through::Activity is_sent_to::human is_created_in::Activity structure_created_by::human has_author::human gives_classification::classification article_written_by::Author has_reviewer::Reviewer has_abstract::Abstract ;
session ::= conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime (eventOnList::Thing)+ partOfEvent::Event hasEvent::Event (organisedBy::Thing)+ heldIn::Location ;
classification ::= ε ;
chair ::= assigns_reviewers_to_article::Reviewer creates_program::program ;
institute ::= ε ;
program ::= program_created_by::chair has_session::session ;
participant ::= submits_to_conference::Conference ;
intensity ::= ε ;
--------------------metamodels::paperdyne.owl.bgf--------------------
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Program_Committee_member ;
 human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= is_author_of::Article performs_activity::Activity is_employed_in::institute has_topic_of_interest::Topic supervises::Activity e-mail::String last_name::String first_name::String ;
notification ::= has_result::Article is_performed_by::human ;
classification ::= ε ;
institute ::= ε ;
program ::= program_created_by::Chair has_session::Session ;
participant ::= submits_to_conference::Conference ;
intensity ::= ε ;
--------------------metamodels::sigkdd.owl.bgf--------------------
date ::= camera-ready_submission_date ;
 date ::= date_of_notification ;
 date ::= abstract_submission_date ;
 date ::= date_of_conference ;
 date ::= full_paper_submission_date ;
 date ::= camera-ready_submission_date | date_of_notification | abstract_submission_date | date_of_conference | full_paper_submission_date ;
human ::= Contact_Person ;
 human ::= Program_Committee_Chair ;
 human ::= Program_Committee_member ;
 human ::= is_author_of::article performs_activity::Activity is_employed_in::institute has_topic_of_interest::Topic supervises::Activity e-mail::String last_name::String first_name::String ;
conference ::= is_in_phase::phase_of_conference ;
notification ::= has_result::article is_performed_by::human ;
article ::= group_email ;
 article ::= notification_email ;
 article ::= abstract_of_paper ;
 article ::= review_form ;
 article ::= summary_of_reviews ;
 article ::= goes_through::Activity is_sent_to::human is_created_in::Activity structure_created_by::human has_author::human gives_classification::classification article_written_by::Author has_reviewer::Reviewer has_abstract::Abstract ;
session ::= starts_on::String ends_on::String has_startdate::dateTime has_enddate::dateTime (eventOnList::Thing)+ partOfEvent::Event hasEvent::Event (organisedBy::Thing)+ heldIn::Location conists_of::Event_Tracks confirmed_by::Approval_Email defined_by::Event_Setup approved_by::Administrator ;
classification ::= ε ;
chair ::= assigns_reviewers_to_article::Reviewer creates_program::program ;
institute ::= ε ;
program ::= program_created_by::chair has_session::session ;
participant ::= submits_to_conference::conference ;
intensity ::= ε ;
--------------------slps::bgf-1.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (name::string())? (root::nonterminal)* production* ;
label ::= string() ;
--------------------slps::bgf-2.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-2.1-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::btf.bgf--------------------
selector ::= string() ;
tree ::= (epsilon::ε) | (any::α) | (terminal::terminal) | (nonterminal::(production tree)) | (selectable::(selector::selector tree)) | (value::((int::integer()) | (string::string()))) | (sequence::(tree*)) | (choice::(expression tree)) | (optional::(tree?)) | (plus::(tree+)) | (star::(tree*)) ;
terminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
nonterminal ::= string() ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
root ::= grammar tree ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-3.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::(expression*)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-3.1-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-4.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-5.2-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
nonterminal ::= string() ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v1.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (name::string())? (root::nonterminal)* production* ;
label ::= string() ;
--------------------slps::bgf-v2.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v2.1-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v3.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::(expression*)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v3.1-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v4.0-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v5.2-xsd.bgf--------------------
selector ::= string() ;
terminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
nonterminal ::= string() ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::cbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
terminal ::= string() ;
 terminal ::= string() ;
widen ::= expression expression (in::scope)? ;
unlabel ::= label::label ;
define ::= production+ tag::string() ;
iterate ::= production ;
production ::= (label::label)? nonterminal::nonterminal expression ;
 production ::= (label::label)? nonterminal::nonterminal expression ;
permute ::= production ;
vertical ::= scope ;
downgrade ::= production production ;
dump ::= ε ;
anonymize ::= production ;
replace ::= expression expression (in::scope)? tag::string() ;
concretize ::= production ;
label ::= string() ;
 label ::= string() ;
deyaccify ::= nonterminal::nonterminal ;
abstractize ::= production ;
value ::= (int::ε) | (string::ε) ;
 value ::= (int::ε) | (string::ε) ;
redefine ::= production+ tag::string() ;
atomic ::= transformation+ ;
abridge ::= production ;
equate ::= align::nonterminal with::nonterminal ;
lassoc ::= production ;
bypass ::= ε ;
import ::= production+ ;
horizontal ::= nonterminal::nonterminal ;
disappear ::= production ;
rassoc ::= production ;
eliminate ::= nonterminal::nonterminal ;
unite ::= add::nonterminal to::nonterminal ;
add ::= (vertical::production) | (horizontal::production) ;
distribute ::= scope ;
introduce ::= production+ ;
selector ::= string() ;
 selector ::= string() ;
upgrade ::= production production ;
narrow ::= expression expression (in::scope)? ;
split ::= nonterminal::nonterminal production+ scope* ;
unfold ::= nonterminal::nonterminal (in::scope)? ;
project ::= production tag::string() ;
inline ::= nonterminal ;
detour ::= production ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
 expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
reroot ::= (root::nonterminal)* ;
appear ::= production ;
designate ::= production ;
undefine ::= (nonterminal::nonterminal)+ tag::string() ;
yaccify ::= production+ ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
 scope ::= (label::label) | (nonterminal::nonterminal) ;
deanonymize ::= production ;
roots ::= (root::nonterminal)* ;
inject ::= production tag::string() ;
factor ::= expression expression (in::scope)? ;
massage ::= expression expression (in::scope)? ;
nonterminal ::= string() ;
 nonterminal ::= string() ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename-rename | reroot-reroot ;
 transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
unchain ::= production ;
remove ::= (vertical::production) | (horizontal::production) ;
chain ::= production ;
fold ::= nonterminal::nonterminal (in::scope)? ;
extract ::= production (in::scope)? ;
sequence ::= (transformation | atomic)* ;
--------------------slps::edd.bgf--------------------
config ::= ((start-grammar-symbol::string()) | (end-grammar-symbol::string()) | (line-continuation-symbol::string()) | (tabulation-symbol::string()) | (start-label-symbol::string()) | (end-label-symbol::string()) | (defining-symbol::string()) | (multiple-defining-symbol::string()) | (terminator-symbol::string()) | (definition-separator-symbol::string()) | (concatenate-symbol::string()) | (start-comment-symbol::string()) | (end-comment-symbol::string()) | (start-group-symbol::string()) | (end-group-symbol::string()) | (start-option-symbol::string()) | (end-option-symbol::string()) | (start-terminal-symbol::string()) | (end-terminal-symbol::string()) | (start-nonterminal-symbol::string()) | (end-nonterminal-symbol::string()) | (start-seplist-star-symbol::string()) | (end-seplist-star-symbol::string()) | (start-seplist-plus-symbol::string()) | (end-seplist-plus-symbol::string()) | (start-repetition-star-symbol::string()) | (end-repetition-star-symbol::string()) | (start-repetition-plus-symbol::string()) | (end-repetition-plus-symbol::string()) | (postfix-option-symbol::string()) | (postfix-repetition-star-symbol::string()) | (postfix-repetition-plus-symbol::string()) | (nonterminals-may-start-with::string()) | (nonterminals-may-contain::string()) | (nonterminal-if-contains::string()) | (terminal-if-undefined::((except::string())*)) | (nonterminal-if-defined::((except::string())*)) | (decompose-symbols::((except::string())*)) | (terminal-if-uppercase::α) | (terminal-if-lowercase::α) | (terminal-if-mixedcase::α) | (terminal-if-camelcase::α) | (nonterminal-if-uppercase::α) | (nonterminal-if-lowercase::α) | (nonterminal-if-mixedcase::α) | (nonterminal-if-camelcase::α) | (glue-nonalphanumeric-terminals::α) | (break-tokens-at-whitespace::α) | (disregard-labels::α) | (consider-indentation::α) | (ignore::(((newline::α) | (space::α) | (same-indentation::α) | (lines-containing::string()))+)) | (mask::(token::string() (terminal::string()) | (epsilon::α))))* ;
--------------------slps::ldf-Readable.bgf--------------------
selector ::= string() ;
list ::= (item::mixed)+ ;
terminal ::= string() ;
mixed ::= (α | string())* ;
document ::= document-metadata part+ ;
type ::= (normative::ε) | (informative::ε) ;
nonterminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
subsection ::= subsection-metadata section-structure ;
section ::= section-metadata section-structure ;
person ::= name::string() (affiliation::string())? (email::string())? ;
label ::= string() ;
part ::= part-metadata section+ ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::ldf-v1.0-xsd.bgf--------------------
reference ::= string() ;
document ::= title::string() author::string() abstract::string() content::contentType ;
tail ::= mixedType ;
--------------------slps::ldf-v10.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-section+) (lists::(front-list+))? (lexicalPart::(LexicalSection+))? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v11.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-section+) (lists::(front-list+))? (lexicalPart::(LexicalSection+))? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v11.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::simpleSection) | (example::simpleSection) | (informative::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::simpleSection) | (description::simpleSection) | (location::simpleSection) | (considerations::simpleSection) | (defaults::simpleSection) | (normative::simpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v11.2-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::simpleSection) | (example::simpleSection) | (informative::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::simpleSection) | (description::simpleSection) | (location::simpleSection) | (considerations::simpleSection) | (defaults::simpleSection) | (normative::simpleSection) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v12.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::simpleSection) | (example::simpleSection) | (informative::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::simpleSection) | (description::simpleSection) | (location::simpleSection) | (considerations::simpleSection) | (defaults::simpleSection) | (normative::simpleSection) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v13.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::(production+)) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v13.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v14.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
code ::= string() ;
runnable ::= runnableType ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
reference ::= string() ;
link ::= (text::string())? reference::string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v15.0-xsd.bgf--------------------
runnable ::= runnableType ;
mi ::= anyMath ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
link ::= (text::string())? reference::string() ;
mtext ::= anyMath ;
msub ::= anyMath ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
tail ::= mixedType ;
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
mrow ::= anyMath ;
code ::= string() ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
math ::= anyMath ;
formula ::= α+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v15.1-xsd.bgf--------------------
runnable ::= runnableType ;
mi ::= anyMath ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(frontSection+) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? (core::structuredSection)+ (annex::structuredSection)* ;
link ::= (text::string())? reference::string() ;
mtext ::= anyMath ;
msub ::= anyMath ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
tail ::= mixedType ;
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
mrow ::= anyMath ;
code ::= string() ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
math ::= anyMath ;
formula ::= α+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v16.0-xsd.bgf--------------------
runnable ::= runnableType ;
mi ::= anyMath ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage frontMatter::(topSection*) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? ((core::structuredSection)+) | ((part::((core::structuredSection)+))+) (backMatter::(topSection*))? (annex::structuredSection)* ;
link ::= (text::string())? reference::string() ;
mtext ::= anyMath ;
msub ::= anyMath ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
tail ::= mixedType ;
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
mrow ::= anyMath ;
code ::= string() ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
math ::= anyMath ;
formula ::= α+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v17.0-xsd.bgf--------------------
runnable ::= runnableType ;
mi ::= anyMath ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage frontMatter::(topSection*) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? ((core::structuredSection)+) | ((part::((core::structuredSection)+))+) (backMatter::(topSection*))? (annex::structuredSection)* ;
link ::= (text::string())? reference::string() ;
mtext ::= anyMath ;
msub ::= anyMath ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
tail ::= mixedType ;
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
mrow ::= anyMath ;
code ::= string() ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
math ::= anyMath ;
formula ::= α+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v18.0-xsd.bgf--------------------
mi ::= anyMath ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage frontMatter::(topSection*) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? ((core::structuredSection)+) | ((part::((core::structuredSection)+))+) (backMatter::(topSection*))? (annex::structuredSection)* ;
mtext ::= anyMath ;
link ::= (text::string())? reference::string() ;
msub ::= anyMath ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
mrow ::= anyMath ;
code ::= string() ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
math ::= anyMath ;
formula ::= α+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v18.1-xsd.bgf--------------------
mi ::= anyMath ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
document ::= titlePage::titlePage frontMatter::(topSection*) (lists::(frontList+))? (lexicalPart::(lexicalSection+))? ((core::structuredSection)+) | ((part::((core::structuredSection)+))+) (backMatter::(topSection*))? (annex::structuredSection)* ;
mtext ::= anyMath ;
link ::= (text::string())? (reference::string()) | (external::string()) ;
msub ::= anyMath ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
mrow ::= anyMath ;
code ::= string() ;
keyword ::= string() ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
math ::= anyMath ;
formula ::= α+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v19.0-xsd.bgf--------------------
list ::= (item::mixed-type)+ ;
mi ::= anyMath ;
document ::= document-metainfo::document-metainfo (part::part)+ ;
mtext ::= anyMath ;
link ::= (text::string())? (reference::string()) | (external::string()) ;
previous ::= title::string() (version::string()) | (edition::string()) (uri::string())? ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
part ::= part-metainfo::part-metainfo section+ ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
section ::= (placeholder::placeholder) | (simple-section::simple-section) | (lexical-section::lexical-section) | (structured-section::structured-section) | (composite-section::composite-section) | (list-section::list-section) ;
figure ::= figure-metainfo::figure-metainfo (figure-source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v2.0-xsd.bgf--------------------
runnable ::= runnableType ;
document ::= title::string() author::string() abstract::string() content::contentType ;
reference ::= string() ;
sample ::= sampleType ;
tail ::= mixedType ;
--------------------slps::ldf-v2.1-xsd.bgf--------------------
runnable ::= runnableType ;
document ::= title::string() author::string() abstract::string() content::contentType ;
reference ::= string() ;
sample ::= sampleType ;
tail ::= mixedType ;
--------------------slps::ldf-v20.0-xsd.bgf--------------------
list ::= (item::mixed-type)+ ;
mi ::= anyMath ;
document ::= title-page content::(part+) ;
mtext ::= anyMath ;
link ::= (text::string())? (reference::string()) | (external::string()) ;
previous ::= title::string() (version::string()) | (edition::string()) (uri::string())? ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
metainfo ::= (id::string())? (title::string())? (author::string())* ;
part ::= role::part-role metainfo content::(section+) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure ::= metainfo (source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v20.1-xsd.bgf--------------------
list ::= (item::mixed-type)+ ;
mi ::= anyMath ;
document ::= title-page content::(part+) ;
mtext ::= anyMath ;
link ::= (text::string())? (reference::string()) | (external::string()) ;
previous ::= title::string() ((version::string()) | (edition::string()))? (uri::string())? ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
metainfo ::= (id::string())? (title::string())? (author::string())* ;
part ::= role::part-role metainfo content::(section+) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure ::= metainfo (source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v21.0-xsd.bgf--------------------
list ::= (item::mixed-type)+ ;
mi ::= anyMath ;
document ::= title-page content::(part+) ;
mtext ::= anyMath ;
link ::= (text::string())? (reference::string()) | (external::string()) ;
previous ::= title::string() ((version::string()) | (edition::string()))? (uri::string())? ;
anchor ::= id::string() ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
metainfo ::= (id::string())? (title::string())? (author::string())* ;
part ::= role::part-role metainfo content::(section+) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure ::= metainfo (source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v21.1-xsd.bgf--------------------
list ::= (item::mixed-type)+ ;
mi ::= anyMath ;
document ::= title-page content::(part+) ;
mtext ::= anyMath ;
link ::= (text::string())? (reference::string()) | (external::string()) ;
previous ::= title::string() ((version::string()) | (edition::string()))? (uri::string())? ;
anchor ::= id::string() ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
metainfo ::= (id::string())? (title::string())? (author::string())* ;
part ::= role::part-role metainfo content::(section+) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure ::= metainfo (source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v22.0-xsd.bgf--------------------
mi ::= anyMath ;
document ::= metadata::((body::((ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε)))? (number::string())? (author::person)* topic::string() status::((unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε)) (version::string()) | (edition::string()) (previous::title-ve-uri)* date::string()) (part::part-type)+ ;
mtext ::= anyMath ;
link ::= (text::string())? (nonterminal::string()) | (reference::string()) | (external::string()) ;
anchor ::= id::string() ;
person ::= name::string() (affiliation::string())? (email::string())? ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
metainfo ::= (id::string())? (title::string())? (author::string())* ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure ::= metainfo (source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v23.0-xsd.bgf--------------------
mi ::= anyMath ;
document ::= metadata::((body::((ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε)))? (number::string())? (author::person)* topic::string() status::((unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε)) (version::string()) | (edition::string()) (previous::named-link)* date::string()) (part::part-type)+ ;
mtext ::= anyMath ;
link ::= (text::string())? (nonterminal::string()) | (reference::string()) | (external::string()) ;
anchor ::= id::string() ;
person ::= name::string() (affiliation::string())? (email::string())? ;
msub ::= anyMath ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
metainfo ::= (id::string())? (title::string())? (author::string())* ;
table ::= (header::table-row)* (row::table-row)+ ;
mrow ::= anyMath ;
code ::= string() ;
term ::= name::string() definition::textual-content ;
keyword ::= string() ;
math ::= anyMath ;
formula ::= α+ ;
figure ::= metainfo (source::figure-source)+ ;
varepsilon ::= ε ;
mo ::= anyMath ;
msup ::= anyMath ;
mfenced ::= anyMath ;
--------------------slps::ldf-v3.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= title::title (placeholder::generated)* frontMatter::frontMatter (languageOverview::ListOfTerms)? (lexicalSection::LexicalSection)+ top-section+ (annex::TopSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
title ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
lexical ::= (lineContinuations::ε) | (whitespace::ε) | (tokens::ε) | (preprocessor::ε) | (literals::ε) | (other::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v4.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= title::title (placeholder::generated)* frontMatter::frontMatter (languageOverview::ListOfTerms)? lexical+ (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
title ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v5.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
lexicals ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= title::title (placeholder::generated)* frontMatter::frontMatter lists::frontLists lexicalPart::lexical (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
title ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
lexical ::= lexicals+ ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v6.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= title::titlePage (placeholder::generated)* frontMatter::frontMatter lists::frontLists lexicalPart::lexical (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= lexicalGroup+ ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v7.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::frontMatter (lists::frontLists)? (lexicalPart::lexical)? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= lexicalGroup+ ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::slps-btf.bgf--------------------
selector ::= string() ;
tree ::= (epsilon::ε) | (any::α) | (terminal::terminal) | (nonterminal::(production tree)) | (selectable::(selector::selector tree)) | (value::((int::integer()) | (string::string()))) | (sequence::(tree*)) | (choice::(expression tree)) | (optional::(tree?)) | (plus::(tree+)) | (star::(tree*)) ;
terminal ::= string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
nonterminal ::= string() ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
grammar ::= (root::nonterminal)* production* ;
label ::= string() ;
root ::= grammar tree ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::ldf-v7.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-sections+) (lists::frontLists)? (lexicalPart::lexical)? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= lexicalGroup+ ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v8.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-section+) (lists::(front-list+))? (lexicalPart::(lexical+))? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v8.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-section+) (lists::(front-list+))? (lexicalPart::(lexical+))? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v9.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-section+) (lists::(front-list+))? (lexicalPart::(lexical+))? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::ldf-v9.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
runnable ::= runnableType ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
document ::= titlePage::titlePage (placeholder::generated)* frontMatter::(front-simple-section+) (lists::(front-list+))? (lexicalPart::(lexical+))? (core::StructuredSection)+ (annex::StructuredSection)* ;
reference ::= string() ;
sample ::= sampleType ;
keyword ::= string() ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
tail ::= mixedType ;
--------------------slps::slps-cbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
terminal ::= string() ;
 terminal ::= string() ;
widen ::= expression expression (in::scope)? ;
unlabel ::= label::label ;
define ::= production+ tag::string() ;
iterate ::= production ;
production ::= (label::label)? nonterminal::nonterminal expression ;
 production ::= (label::label)? nonterminal::nonterminal expression ;
permute ::= production ;
vertical ::= scope ;
downgrade ::= production production ;
dump ::= ε ;
anonymize ::= production ;
replace ::= expression expression (in::scope)? tag::string() ;
concretize ::= production ;
label ::= string() ;
 label ::= string() ;
deyaccify ::= nonterminal::nonterminal ;
abstractize ::= production ;
value ::= (int::ε) | (string::ε) ;
 value ::= (int::ε) | (string::ε) ;
redefine ::= production+ tag::string() ;
atomic ::= transformation+ ;
abridge ::= production ;
equate ::= align::nonterminal with::nonterminal ;
lassoc ::= production ;
bypass ::= ε ;
import ::= production+ ;
horizontal ::= nonterminal::nonterminal ;
disappear ::= production ;
rassoc ::= production ;
eliminate ::= nonterminal::nonterminal ;
unite ::= add::nonterminal to::nonterminal ;
add ::= (vertical::production) | (horizontal::production) ;
distribute ::= scope ;
introduce ::= production+ ;
selector ::= string() ;
 selector ::= string() ;
upgrade ::= production production ;
narrow ::= expression expression (in::scope)? ;
split ::= nonterminal::nonterminal production+ scope* ;
unfold ::= nonterminal::nonterminal (in::scope)? ;
project ::= production tag::string() ;
inline ::= nonterminal ;
detour ::= production ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
 expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
reroot ::= (root::nonterminal)* ;
appear ::= production ;
designate ::= production ;
undefine ::= (nonterminal::nonterminal)+ tag::string() ;
yaccify ::= production+ ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
 scope ::= (label::label) | (nonterminal::nonterminal) ;
deanonymize ::= production ;
roots ::= (root::nonterminal)* ;
inject ::= production tag::string() ;
factor ::= expression expression (in::scope)? ;
massage ::= expression expression (in::scope)? ;
nonterminal ::= string() ;
 nonterminal ::= string() ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename-rename | reroot-reroot ;
 transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
unchain ::= production ;
remove ::= (vertical::production) | (horizontal::production) ;
chain ::= production ;
fold ::= nonterminal::nonterminal (in::scope)? ;
extract ::= production (in::scope)? ;
sequence ::= (transformation | atomic)* ;
--------------------slps::slps-edd.bgf--------------------
config ::= ((start-grammar-symbol::string()) | (end-grammar-symbol::string()) | (line-continuation-symbol::string()) | (tabulation-symbol::string()) | (start-label-symbol::string()) | (end-label-symbol::string()) | (defining-symbol::string()) | (multiple-defining-symbol::string()) | (terminator-symbol::string()) | (definition-separator-symbol::string()) | (concatenate-symbol::string()) | (start-comment-symbol::string()) | (end-comment-symbol::string()) | (start-group-symbol::string()) | (end-group-symbol::string()) | (start-option-symbol::string()) | (end-option-symbol::string()) | (start-terminal-symbol::string()) | (end-terminal-symbol::string()) | (start-nonterminal-symbol::string()) | (end-nonterminal-symbol::string()) | (start-seplist-star-symbol::string()) | (end-seplist-star-symbol::string()) | (start-seplist-plus-symbol::string()) | (end-seplist-plus-symbol::string()) | (start-repetition-star-symbol::string()) | (end-repetition-star-symbol::string()) | (start-repetition-plus-symbol::string()) | (end-repetition-plus-symbol::string()) | (postfix-option-symbol::string()) | (postfix-repetition-star-symbol::string()) | (postfix-repetition-plus-symbol::string()) | (nonterminals-may-start-with::string()) | (nonterminals-may-contain::string()) | (nonterminal-if-contains::string()) | (terminal-if-undefined::((except::string())*)) | (nonterminal-if-defined::((except::string())*)) | (decompose-symbols::((except::string())*)) | (terminal-if-uppercase::α) | (terminal-if-lowercase::α) | (terminal-if-mixedcase::α) | (terminal-if-camelcase::α) | (nonterminal-if-uppercase::α) | (nonterminal-if-lowercase::α) | (nonterminal-if-mixedcase::α) | (nonterminal-if-camelcase::α) | (glue-nonalphanumeric-terminals::α) | (break-tokens-at-whitespace::α) | (disregard-labels::α) | (consider-indentation::α) | (ignore::(((newline::α) | (space::α) | (same-indentation::α) | (lines-containing::string()))+)) | (mask::(token::string() (terminal::string()) | (epsilon::α))))* ;
--------------------slps::slps-exbgf.bgf--------------------
sequence ::= (atomic | shielded | shieldedD | shieldedU | tempunfold | atomicI | atomicC | atomicH | atomicV | yaccifyH | deyaccifyH | deyaccifyC | regroupLR | regroupRL | massage1S2P | massageS12P | massageC2S | massage12C | massageO2C | massageC2O | massage-double | massageOP2S | promoteP2S | promoteY2S | double-inline | inlineYO | inlineYF | unite-many | eliminate-many | distributeV | distributeH | inlineY | inlineYH | inlineV | inlineU | chainV | chainX | introduceH | defineH | reyaccify | reextract | reextractY | extract-twice | redefine | redefineH | metachangeT2N | renameN | addV | addH | addX | removeV | removeH | extractV | extractC | narrowS21 | narrowP21 | narrowO21 | widen12O | widen12S | widen12P | widenP2S | unfoldV | unfold | unfoldY | foldY | factor-out | pull-out)* ;
--------------------slps::slps-lcf.bgf--------------------
derived ::= from::string() using::string() ;
phase ::= (step::((perform-transformation::string()) | automated-transformation))+ ;
source ::= name::string() derived? source-grammar source-tree? test-set::(xstring*) ;
tools ::= transformer::tool comparator::tool (validator::tool)? generator* ;
xstring ::= ((expand::string()) | string())* ;
tool ::= grammar::xstring (tree::xstring)? ;
shortcut ::= name::string() expansion::xstring ;
generator ::= name::string() command::xstring ;
branch ::= input::string() (preparation::phase)? (nominal-matching::phase)? (normalizing::phase)? (structural-matching::phase)? ((extension::phase) | (correction::phase) | (relaxation::phase))* ;
target ::= name::string() branch+ ;
testset ::= name::string() command::xstring ;
scenario ::= shortcut* tools source+ target+ testset* ;
--------------------slps::slps-xbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
terminal ::= string() ;
unlabel ::= label::label ;
define ::= production+ tag::string() ;
widen ::= expression expression (in::scope)? ;
iterate ::= production ;
production ::= (label::label)? nonterminal::nonterminal expression ;
permute ::= production ;
vertical ::= scope ;
downgrade ::= production production ;
dump ::= ε ;
anonymize ::= production ;
replace ::= expression expression (in::scope)? tag::string() ;
concretize ::= production ;
label ::= string() ;
deyaccify ::= nonterminal::nonterminal ;
abstractize ::= production ;
value ::= (int::ε) | (string::ε) ;
redefine ::= production+ tag::string() ;
atomic ::= transformation+ ;
abridge ::= production ;
equate ::= align::nonterminal with::nonterminal ;
lassoc ::= production ;
bypass ::= ε ;
import ::= production+ ;
horizontal ::= nonterminal::nonterminal ;
disappear ::= production ;
rassoc ::= production ;
eliminate ::= nonterminal::nonterminal ;
unite ::= add::nonterminal to::nonterminal ;
distribute ::= scope ;
add ::= (vertical::production) | (horizontal::production) ;
introduce ::= production+ ;
selector ::= string() ;
upgrade ::= production production ;
narrow ::= expression expression (in::scope)? ;
split ::= nonterminal::nonterminal production+ scope* ;
unfold ::= nonterminal::nonterminal (in::scope)? ;
project ::= production tag::string() ;
inline ::= nonterminal ;
detour ::= production ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
reroot ::= (root::nonterminal)* ;
appear ::= production ;
designate ::= production ;
undefine ::= (nonterminal::nonterminal)+ tag::string() ;
yaccify ::= production+ ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
deanonymize ::= production ;
inject ::= production tag::string() ;
factor ::= expression expression (in::scope)? ;
massage ::= expression expression (in::scope)? ;
nonterminal ::= string() ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
unchain ::= production ;
remove ::= (vertical::production) | (horizontal::production) ;
chain ::= production ;
extract ::= production (in::scope)? ;
fold ::= nonterminal::nonterminal (in::scope)? ;
sequence ::= (transformation | atomic)* ;
--------------------slps::slps-xedd.bgf--------------------
introduce ::= metasymbol::confixMetasymbols start::string() end::string() ;
rename ::= metasymbol::metasymbols from::string() to::string() ;
step ::= rename | introduce | eliminate ;
evolution ::= step* ;
metasymbols ::= (terminator::ε) | (defining::ε) | (definition-separator::ε) | (group::ε) | (seplist-plus::ε) | (seplist-star::ε) ;
eliminate ::= metasymbol::metasymbols ;
--------------------slps::slps-xldf.bgf--------------------
terminal ::= string() ;
 terminal ::= string() ;
unlabel ::= label::label ;
widen ::= expression expression (in::scope)? ;
iterate ::= production ;
vertical ::= scope ;
downgrade ::= production production ;
dump ::= ε ;
anonymize ::= production ;
concretize ::= production ;
label ::= string() ;
 label ::= string() ;
deyaccify ::= nonterminal::nonterminal ;
abstractize ::= production ;
value ::= (int::ε) | (string::ε) ;
 value ::= (int::ε) | (string::ε) ;
drop ::= section::string() ;
bypass ::= ε ;
rassoc ::= production ;
unite ::= add::nonterminal to::nonterminal ;
distribute ::= scope ;
selector ::= string() ;
 selector ::= string() ;
narrow ::= expression expression (in::scope)? ;
detour ::= production ;
hyperlinkify ::= goal::string() uri::string() ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
factor ::= expression expression (in::scope)? ;
relative ::= (before::((id::string()) | simpleTextElement)) | (after::((id::string()) | simpleTextElement)) | (to::string()) ;
nonterminal ::= string() ;
 nonterminal ::= string() ;
unchain ::= production ;
chain ::= production ;
combine ::= section::string() with::string() ;
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
define ::= production+ tag::string() ;
production ::= (label::label)? nonterminal::nonterminal expression ;
 production ::= (label::label)? nonterminal::nonterminal expression ;
insert ::= relative content::simpleText ;
permute ::= production ;
replace ::= expression expression (in::scope)? tag::string() ;
redefine ::= production+ tag::string() ;
abridge ::= production ;
lassoc ::= production ;
equate ::= align::nonterminal with::nonterminal ;
import ::= production+ ;
horizontal ::= nonterminal::nonterminal ;
disappear ::= production ;
eliminate ::= nonterminal::nonterminal ;
add ::= (vertical::production) | (horizontal::production) ;
introduce ::= production+ ;
upgrade ::= production production ;
split ::= nonterminal::nonterminal production+ scope* ;
unfold ::= nonterminal::nonterminal (in::scope)? ;
append ::= where::string() content::simpleText ;
inline ::= nonterminal ;
project ::= production tag::string() ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
 expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
reroot ::= (root::nonterminal)* ;
appear ::= production ;
yaccify ::= production+ ;
undefine ::= (nonterminal::nonterminal)+ tag::string() ;
designate ::= production ;
deanonymize ::= production ;
inject ::= production tag::string() ;
massage ::= expression expression (in::scope)? ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
place ::= section::string() inside::string() ;
retitle ::= from::((id::string()) | (title::string())) to::string() ;
remove ::= (vertical::production) | (horizontal::production) ;
extract ::= production (in::scope)? ;
fold ::= nonterminal::nonterminal (in::scope)? ;
--------------------slps::xbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
terminal ::= string() ;
unlabel ::= label::label ;
define ::= production+ tag::string() ;
widen ::= expression expression (in::scope)? ;
iterate ::= production ;
production ::= (label::label)? nonterminal::nonterminal expression ;
permute ::= production ;
vertical ::= scope ;
downgrade ::= production production ;
dump ::= ε ;
anonymize ::= production ;
replace ::= expression expression (in::scope)? tag::string() ;
concretize ::= production ;
label ::= string() ;
deyaccify ::= nonterminal::nonterminal ;
abstractize ::= production ;
value ::= (int::ε) | (string::ε) ;
redefine ::= production+ tag::string() ;
atomic ::= transformation+ ;
abridge ::= production ;
equate ::= align::nonterminal with::nonterminal ;
lassoc ::= production ;
bypass ::= ε ;
import ::= production+ ;
horizontal ::= nonterminal::nonterminal ;
disappear ::= production ;
rassoc ::= production ;
eliminate ::= nonterminal::nonterminal ;
unite ::= add::nonterminal to::nonterminal ;
distribute ::= scope ;
add ::= (vertical::production) | (horizontal::production) ;
introduce ::= production+ ;
selector ::= string() ;
upgrade ::= production production ;
narrow ::= expression expression (in::scope)? ;
split ::= nonterminal::nonterminal production+ scope* ;
unfold ::= nonterminal::nonterminal (in::scope)? ;
project ::= production tag::string() ;
inline ::= nonterminal ;
detour ::= production ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
reroot ::= (root::nonterminal)* ;
appear ::= production ;
designate ::= production ;
undefine ::= (nonterminal::nonterminal)+ tag::string() ;
yaccify ::= production+ ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
deanonymize ::= production ;
inject ::= production tag::string() ;
factor ::= expression expression (in::scope)? ;
massage ::= expression expression (in::scope)? ;
nonterminal ::= string() ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
unchain ::= production ;
remove ::= (vertical::production) | (horizontal::production) ;
chain ::= production ;
extract ::= production (in::scope)? ;
fold ::= nonterminal::nonterminal (in::scope)? ;
sequence ::= (transformation | atomic)* ;
