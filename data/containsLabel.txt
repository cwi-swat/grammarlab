--------------------c::lankamp.bgf--------------------
Specifier ::= [StorageClass] StorageClass ;
 Specifier ::= [TypeQualifier] TypeQualifier ;
 Specifier ::= [TypeSpecifier] TypeSpecifier ;
StorageClass ::= "register" ;
 StorageClass ::= "static" ;
 StorageClass ::= "extern" ;
 StorageClass ::= "auto" ;
 StorageClass ::= [TypeDef] "typedef" ;
FunctionDefinition ::= [DefaultFunctionDefinition] specs::(Specifier*) Declarator Declaration* "{" Declaration* Statement* "}" ;
Declaration ::= [DeclarationWithoutInitDecls] specs::(Specifier+) ";" ;
 Declaration ::= [DeclarationWithInitDecls] specs::(Specifier+) initDeclarators::({InitDeclarator ","}+) ";" ;
FunctionPrototype ::= [DefaultFunctionPrototype] specs::(Specifier*) decl::PrototypeDeclarator ";" ;
Expression ::= CharacterConstant ;
 Expression ::= Expression "--" ;
 Expression ::= [Variable] Identifier ;
 Expression ::= Expression "[" Expression "]" ;
 Expression ::= [Bracket] "(" Expression ")" ;
 Expression ::= "sizeof" "(" TypeName ")" ;
 Expression ::= Expression "++" ;
 Expression ::= FloatingPointConstant ;
 Expression ::= Expression "." Identifier ;
 Expression ::= StringConstant ;
 Expression ::= IntegerConstant ;
 Expression ::= HexadecimalConstant ;
 Expression ::= Expression "->" Identifier ;
 Expression ::= Expression "(" {NonCommaExpression ","}* ")" ;
 Expression ::= Expression ;
 Expression ::= [SizeOfExpression] "sizeof" exp::Expression ;
 Expression ::= "&" Expression ;
 Expression ::= "!" Expression ;
 Expression ::= "(" TypeName ")" Expression ;
 Expression ::= "*" Expression ;
 Expression ::= "+" Expression ;
 Expression ::= "-" Expression ;
 Expression ::= "~" Expression ;
 Expression ::= [MultiplicationExpression] lexp::Expression "*" rexp::Expression ;
 Expression ::= Expression "/" Expression ;
 Expression ::= Expression "%" Expression ;
 Expression ::= Expression "+" Expression ;
 Expression ::= Expression "-" Expression ;
 Expression ::= Expression ">>" Expression ;
 Expression ::= Expression "<<" Expression ;
 Expression ::= Expression "<=" Expression ;
 Expression ::= Expression ">=" Expression ;
 Expression ::= Expression ">" Expression ;
 Expression ::= Expression "<" Expression ;
 Expression ::= Expression "==" Expression ;
 Expression ::= Expression "!=" Expression ;
 Expression ::= Expression "&" Expression ;
 Expression ::= Expression "^" Expression ;
 Expression ::= Expression "|" Expression ;
 Expression ::= Expression "&&" Expression ;
 Expression ::= Expression "||" Expression ;
 Expression ::= Expression "?" Expression ":" Expression ;
 Expression ::= Expression "|=" Expression ;
 Expression ::= Expression "&=" Expression ;
 Expression ::= Expression "*=" Expression ;
 Expression ::= Expression "/=" Expression ;
 Expression ::= Expression "+=" Expression ;
 Expression ::= Expression ">>=" Expression ;
 Expression ::= Expression "^=" Expression ;
 Expression ::= Expression "-=" Expression ;
 Expression ::= Expression "<<=" Expression ;
 Expression ::= Expression "%=" Expression ;
 Expression ::= Expression "=" Expression ;
 Expression ::= [CommaExpression] Expression "," Expression ;
GlobalDeclaration ::= [GlobalDeclarationWithoutInitDecls] specs::(Specifier+) ";" ;
 GlobalDeclaration ::= [GlobalDeclarationWithInitDecls] specs::(Specifier*) initDeclarators::({InitDeclarator ","}+) ";" ;
StructDeclaration ::= [StructDeclWithoutDecl] specs::(Specifier+) ";" ;
 StructDeclaration ::= [StructDeclWithDecl] specs::(Specifier+) {StructDeclarator ","}+ ";" ;
TypeSpecifier ::= [StructDecl] "struct" Identifier "{" StructDeclaration* "}" ;
 TypeSpecifier ::= [Union] "union" Identifier ;
 TypeSpecifier ::= [Int] "int" ;
 TypeSpecifier ::= [Void] "void" ;
 TypeSpecifier ::= [StructAnonDecl] "struct" "{" StructDeclaration* "}" ;
 TypeSpecifier ::= [Short] "short" ;
 TypeSpecifier ::= [Identifier] Identifier ;
 TypeSpecifier ::= [EnumDecl] "enum" Identifier "{" {Enumerator ","}+ "}" ;
 TypeSpecifier ::= "signed" ;
 TypeSpecifier ::= [UnionDecl] "union" Identifier "{" StructDeclaration* "}" ;
 TypeSpecifier ::= [UnionAnonDecl] "union" "{" StructDeclaration* "}" ;
 TypeSpecifier ::= [Enum] "enum" Identifier ;
 TypeSpecifier ::= [Struct] "struct" Identifier ;
 TypeSpecifier ::= "unsigned" ;
 TypeSpecifier ::= [Long] "long" ;
 TypeSpecifier ::= [Double] "double" ;
 TypeSpecifier ::= [Float] "float" ;
 TypeSpecifier ::= [EnumAnonDecl] "enum" "{" {Enumerator ","}+ "}" ;
 TypeSpecifier ::= [Char] "char" ;
AbstractDeclarator ::= [Identifier] AnonymousIdentifier ;
 AbstractDeclarator ::= [ArrayDeclarator] decl::AbstractDeclarator "[" exp::(Expression?) "]" ;
 AbstractDeclarator ::= [Bracket] "(" decl::AbstractDeclarator ")" ;
 AbstractDeclarator ::= [FunctionDeclarator] decl::AbstractDeclarator "(" params::(Parameters?) ")" ;
 AbstractDeclarator ::= [PointerDeclarator] "*" qualifiers::(TypeQualifier*) decl::AbstractDeclarator ;
PrototypeDeclarator ::= [FunctionDeclarator] decl::PrototypeDeclarator "(" params::(PrototypeParameters?) ")" ;
 PrototypeDeclarator ::= [Identifier] Identifier ;
 PrototypeDeclarator ::= [Bracket] "(" decl::AbstractDeclarator ")" ;
 PrototypeDeclarator ::= [ArrayDeclarator] decl::PrototypeDeclarator "[" exp::(Expression?) "]" ;
 PrototypeDeclarator ::= [PointerDeclarator] "*" qualifiers::(TypeQualifier*) decl::PrototypeDeclarator ;
Declarator ::= [ArrayDeclarator] decl::Declarator "[" exp::(Expression?) "]" ;
 Declarator ::= [Identifier] Identifier ;
 Declarator ::= [FunctionDeclarator] decl::Declarator "(" params::(Parameters?) ")" ;
 Declarator ::= [Bracket] "(" decl::Declarator ")" ;
 Declarator ::= [PointerDeclarator] "*" qualifiers::(TypeQualifier*) decl::Declarator ;
InitDeclarator ::= decl::Declarator "=" Initializer ;
 InitDeclarator ::= [decl] Declarator ;
NonCommaExpression ::= [NonCommaExpression] expr::Expression ;
--------------------java::java-5-landman.bgf--------------------
BlockStm ::= Stm ;
 BlockStm ::= [classDecStm] ClassDec ;
 BlockStm ::= LocalVarDecStm ;
DimExpr ::= [dim] "[" Expr "]" ;
ImportDec ::= [typeImportOnDemandDec] "import" PackageName "." "*" ";" ;
 ImportDec ::= [typeImportDec] "import" TypeName ";" ;
 ImportDec ::= [staticImportDec] "import" "static" TypeName "." Id ";" ;
 ImportDec ::= [staticImportOnDemandDec] "import" "static" TypeName "." "*" ";" ;
ArrayAccess ::= [arrayAccess] ArraySubscript ;
PackageDec ::= [packageDec] Anno* "package" PackageName ";" ;
VarDec ::= [varDec] VarDecId "=" VarInit ;
 VarDec ::= [varDec] VarDecId ;
Interfaces ::= [implementsDec] "implements" {InterfaceType ","}+ ;
ClassOrInterfaceType ::= [classOrInterfaceType] TypeDecSpec TypeArgs? ;
VarDecId ::= Id ;
 VarDecId ::= [arrayVarDecId] Id Dim+ ;
ConstrDec ::= [constrDec] ConstrHead ConstrBody ;
InterfaceType ::= [interfaceType] TypeDecSpec TypeArgs? ;
ElemVal ::= [elemValArrayInit] "{" {ElemVal ","}* "}" ;
 ElemVal ::= Expr ;
 ElemVal ::= Anno ;
 ElemVal ::= [elemValArrayInit] "{" {ElemVal ","}* "," "}" ;
InterfaceMemberDec ::= [semicolon] ";" ;
 InterfaceMemberDec ::= InterfaceDec ;
 InterfaceMemberDec ::= AbstractMethodDec ;
 InterfaceMemberDec ::= ClassDec ;
 InterfaceMemberDec ::= ConstantDec ;
TypeVar ::= [typeVar] TypeVarId ;
Block ::= [block] "{" BlockStm* "}" ;
Throws ::= [throwsDec] "throws" {ExceptionType ","}+ ;
ElemValPair ::= [elemValPair] Id "=" ;
CatchClause ::= [catch] "catch" "(" FormalParam ")" Block ;
ArrayInit ::= [arrayInit] "{" {VarInit ","}* "," "}" ;
 ArrayInit ::= [arrayInit] "{" {VarInit ","}* "}" ;
Dim ::= [dim] "[" "]" ;
InstanceInit ::= [instanceInit] Block ;
EnumBody ::= [enumBody] "{" {EnumConst ","}* EnumBodyDecs? "}" ;
 EnumBody ::= [enumBody] "{" {EnumConst ","}* "," EnumBodyDecs? "}" ;
ConstrInv ::= [qSuperConstrInv] Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" ;
 ConstrInv ::= [superConstrInv] TypeArgs? "super" "(" {Expr ","}* ")" ";" ;
 ConstrInv ::= [altConstrInv] TypeArgs? "this" "(" {Expr ","}* ")" ";" ;
IntLiteral ::= [octa] ε ;
 IntLiteral ::= [hexa] ε ;
 IntLiteral ::= [deci] ε ;
FieldAccess ::= [qSuperField] TypeName "." "super" "." Id ;
 FieldAccess ::= [field] "." Id ;
 FieldAccess ::= [superField] "super" "." Id ;
MethodSpec ::= [method] MethodName ;
 MethodSpec ::= [superMethod] "super" "." TypeArgs? Id ;
 MethodSpec ::= [genericMethod] AmbName "." TypeArgs Id ;
 MethodSpec ::= [qSuperMethod] TypeName "." "super" "." TypeArgs? Id ;
 MethodSpec ::= [method] "." TypeArgs? Id ;
Super ::= [superDec] "extends" ClassType ;
TypeArgs ::= [typeArgs] "<" {ActualTypeArg ","}+ ">" ;
AnnoDecHead ::= [annoDecHead] "@" "interface" Id ;
TypeParam ::= [typeParam] TypeVarId TypeBound? ;
FloatLiteral ::= [float] ε ;
PackageName ::= [packageName] {Id "."}+ ;
ConstrBody ::= [constrBody] "{" ConstrInv? BlockStm* "}" ;
Anno ::= [singleElemAnno] "@" TypeName "(" ")" ;
 Anno ::= [anno] "@" TypeName "(" {ElemValPair ","}* ")" ;
 Anno ::= [markerAnno] "@" TypeName ;
ArrayCreationExpr ::= [newArray] "new" ArrayBaseType DimExpr+ ;
 ArrayCreationExpr ::= [newArray] "new" ArrayBaseType ArrayInit ;
TypeDec ::= InterfaceDec ;
 TypeDec ::= ClassDec ;
 TypeDec ::= [semicolon] ";" ;
FieldDec ::= [fieldDec] Type {VarDec ","}+ ";" ;
CompilationUnit ::= [compilationUnit] PackageDec? ImportDec* TypeDec* ;
LocalVarDecStm ::= [localVarDecStm] LocalVarDec ";" ;
AnnoElemDec ::= EnumDec ;
 AnnoElemDec ::= [semicolon] ";" ;
 AnnoElemDec ::= ClassDec ;
 AnnoElemDec ::= ConstantDec ;
 AnnoElemDec ::= InterfaceDec ;
 AnnoElemDec ::= [annoMethodDec] AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" ;
BoolLiteral ::= [false] "false" ;
 BoolLiteral ::= [true] "true" ;
TypeBound ::= [typeBound] "extends" {ClassOrInterfaceType "&"}+ ;
MethodBody ::= [noMethodBody] ";" ;
 MethodBody ::= Block ;
EnumConst ::= [enumConst] Id EnumConstArgs? ClassBody? ;
AmbName ::= [ambName] AmbName "." Id ;
 AmbName ::= [ambName] Id ;
MethodDec ::= [methodDec] MethodDecHead MethodBody ;
MethodDecHead ::= [deprMethodDecHead] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ;
 MethodDecHead ::= [methodDecHead] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ;
DefaultVal ::= [defaultVal] "default" ;
ExprName ::= [exprName] Id ;
 ExprName ::= [exprName] AmbName "." Id ;
AbstractMethodDec ::= [abstractMethodDec] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";" ;
 AbstractMethodDec ::= [deprAbstractMethodDec] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" ;
StaticInit ::= [staticInit] "static" Block ;
FormalParam ::= [varArityParam] Type "..." VarDecId ;
 FormalParam ::= [param] Type VarDecId ;
Id ::= [id] ε ;
ClassLiteral ::= [voidClass] "void" "." "class" ;
 ClassLiteral ::= [class] Type "." "class" ;
EnumBodyDecs ::= [enumBodyDecs] ";" ClassBodyDec* ;
ExtendsInterfaces ::= [extendsInterfaces] "extends" {InterfaceType ","}+ ;
ClassType ::= [classType] TypeDecSpec TypeArgs? ;
ActualTypeArg ::= Type ;
 ActualTypeArg ::= [wildcard] "?" WildcardBound? ;
PackageOrTypeName ::= [packageOrTypeName] Id ;
 PackageOrTypeName ::= [packageOrTypeName] PackageOrTypeName "." Id ;
MethodName ::= [methodName] AmbName "." Id ;
 MethodName ::= [methodName] Id ;
InterfaceDecHead ::= [interfaceDecHead] "interface" Id TypeParams? ExtendsInterfaces? ;
IntType ::= [int] "int" ;
 IntType ::= [byte] "byte" ;
 IntType ::= [long] "long" ;
 IntType ::= [short] "short" ;
 IntType ::= [char] "char" ;
WildcardBound ::= [wildcardUpperBound] "extends" RefType ;
 WildcardBound ::= [wildcardLowerBound] "super" RefType ;
TypeDecSpec ::= TypeName ;
 TypeDecSpec ::= [member] TypeDecSpec TypeArgs "." Id ;
EnumDec ::= [enumDec] EnumDecHead EnumBody ;
EnumDecHead ::= [enumDecHead] "enum" Id Interfaces? ;
PrimType ::= NumType ;
 PrimType ::= [boolean] "boolean" ;
ConstantDec ::= [constantDec] Type {VarDec ","}+ ";" ;
ClassBody ::= [classBody] "{" ClassBodyDec* "}" ;
SwitchBlock ::= [switchBlock] "{" SwitchGroup* SwitchLabel* "}" ;
ResultType ::= Type ;
 ResultType ::= [void] "void" ;
FloatType ::= [double] "double" ;
 FloatType ::= [float] "float" ;
Expr ::= [postDecr] Expr "--" ;
 Expr ::= [postIncr] Expr "++" ;
 Expr ::= [castPrim] "(" PrimType ")" Expr ;
 Expr ::= [castRef] "(" RefType ")" Expr ;
 Expr ::= [minus] Expr ;
 Expr ::= [preIncr] "++" Expr ;
 Expr ::= [plus] Expr ;
 Expr ::= [preDecr] "--" Expr ;
 Expr ::= [this] "this" ;
 Expr ::= [mul] Expr "*" Expr ;
 Expr ::= [div] Expr Expr ;
 Expr ::= [remain] Expr "%" Expr ;
 Expr ::= [qThis] TypeName "." "this" ;
 Expr ::= [complement] "~" Expr ;
 Expr ::= [not] "!" Expr ;
 Expr ::= [plus] Expr Expr ;
 Expr ::= [minus] Expr Expr ;
 Expr ::= [uRightShift] Expr ">>>" Expr ;
 Expr ::= [rightShift] Expr ">>" Expr ;
 Expr ::= [leftShift] Expr "<<" Expr ;
 Expr ::= [ltEq] Expr "<=" Expr ;
 Expr ::= [lt] Expr "<" Expr ;
 Expr ::= [gtEq] Expr ">=" Expr ;
 Expr ::= [instanceOf] Expr "instanceof" RefType ;
 Expr ::= [gt] Expr ">" Expr ;
 Expr ::= [eq] Expr "==" Expr ;
 Expr ::= [notEq] Expr "!=" Expr ;
 Expr ::= [and] Expr "&" Expr ;
 Expr ::= [excOr] Expr "^" Expr ;
 Expr ::= [or] Expr "|" Expr ;
 Expr ::= [lazyAnd] Expr "&&" Expr ;
 Expr ::= [lazyOr] Expr "||" Expr ;
 Expr ::= [cond] Expr CondMid Expr ;
 Expr ::= [assignMinus] LHS "-=" Expr ;
 Expr ::= [assignExcOr] LHS "^=" Expr ;
 Expr ::= [assignPlus] LHS "+=" Expr ;
 Expr ::= [assignURightShift] LHS ">>>=" Expr ;
 Expr ::= [assignAnd] LHS "&=" Expr ;
 Expr ::= [assignDiv] LHS "/=" Expr ;
 Expr ::= [assignMul] LHS "*=" Expr ;
 Expr ::= [assignRemain] LHS "%=" Expr ;
 Expr ::= [assignLeftShift] LHS "<<=" Expr ;
 Expr ::= [assignRightShift] LHS ">>=" Expr ;
 Expr ::= [assignOr] LHS "|=" Expr ;
 Expr ::= [assign] LHS "=" Expr ;
 Expr ::= [qNewInstance] Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? ;
 Expr ::= [lit] Literal ;
 Expr ::= [newInstance] "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? ;
 Expr ::= [exprName] ExprName ;
 Expr ::= ArrayCreationExpr ;
 Expr ::= "(" Expr ")" ;
 Expr ::= ε ;
 Expr ::= [invoke] MethodSpec "(" {Expr ","}* ")" ;
ArrayType ::= [arrayType] Type "[" "]" ;
ClassMemberDec ::= ClassDec ;
 ClassMemberDec ::= MethodDec ;
 ClassMemberDec ::= FieldDec ;
 ClassMemberDec ::= [semicolon] ";" ;
 ClassMemberDec ::= InterfaceDec ;
ConstrHead ::= [constrDecHead] TypeParams? Id "(" {FormalParam ","}* ")" Throws? ;
Stm ::= [synchronized] "synchronized" "(" Expr ")" Block ;
 Stm ::= [exprStm] Expr ";" ;
 Stm ::= [for] "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm ;
 Stm ::= [for] "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm ;
 Stm ::= Block ;
 Stm ::= [continue] "continue" Id? ";" ;
 Stm ::= [try] "try" Block CatchClause+ ;
 Stm ::= [throw] "throw" Expr ";" ;
 Stm ::= [switch] "switch" "(" Expr ")" SwitchBlock ;
 Stm ::= [if] "if" "(" Expr ")" Stm ;
 Stm ::= [break] "break" Id? ";" ;
 Stm ::= [empty] ";" ;
 Stm ::= [labeled] Id ":" Stm ;
 Stm ::= [assertStm] "assert" Expr ":" Expr ";" ;
 Stm ::= [forEach] "for" "(" FormalParam ":" Expr ")" Stm ;
 Stm ::= [assertStm] "assert" Expr ";" ;
 Stm ::= [try] "try" Block CatchClause* "finally" Block ;
 Stm ::= [return] "return" Expr? ";" ;
 Stm ::= [doWhile] "do" Stm "while" "(" Expr ")" ";" ;
 Stm ::= [while] "while" "(" Expr ")" Stm ;
 Stm ::= [if] "if" "(" Expr ")" Stm "else" Stm ;
SwitchGroup ::= [switchGroup] SwitchLabel+ BlockStm+ ;
ClassDec ::= EnumDec ;
 ClassDec ::= [classDec] ClassDecHead ClassBody ;
ClassDecHead ::= [classDecHead] "class" Id TypeParams? Super? Interfaces? ;
NullLiteral ::= [null] "null" ;
LocalVarDec ::= [localVarDec] Type {VarDec ","}+ ;
TypeName ::= [typeName] PackageOrTypeName "." Id ;
 TypeName ::= [typeName] Id ;
ArrayBaseType ::= TypeName ;
 ArrayBaseType ::= PrimType ;
 ArrayBaseType ::= [unboundWld] TypeName "<" "?" ">" ;
SwitchLabel ::= [case] "case" Expr ":" ;
 SwitchLabel ::= [default] "default" ":" ;
TypeParams ::= [typeParams] "<" {TypeParam ","}+ ">" ;
--------------------xpath::w3c-xpath1.bgf--------------------
AbbreviatedRelativeLocationPath ::= [NT-AbbreviatedRelativeLocationPath] RelativeLocationPath "//" Step ;
AxisSpecifier ::= [NT-AxisSpecifier] (AxisName "::") | AbbreviatedAxisSpecifier ;
NodeType ::= [NT-NodeType] "comment" | "text" | "processing-instruction" | "node" ;
PrimaryExpr ::= [NT-PrimaryExpr] VariableReference | ("(" Expr ")") | Literal | Number | FunctionCall ;
FunctionCall ::= [NT-FunctionCall] FunctionName "(" (Argument ("," Argument)*)? ")" ;
ExprWhitespace ::= [NT-ExprWhitespace] S ;
AbsoluteLocationPath ::= [NT-AbsoluteLocationPath] ("/" RelativeLocationPath?) | AbbreviatedAbsoluteLocationPath ;
OperatorName ::= [NT-OperatorName] "and" | "or" | "mod" | "div" ;
EqualityExpr ::= [NT-EqualityExpr] RelationalExpr | (EqualityExpr "=" RelationalExpr) | (EqualityExpr "!=" RelationalExpr) ;
FilterExpr ::= [NT-FilterExpr] PrimaryExpr | (FilterExpr Predicate) ;
PredicateExpr ::= [NT-PredicateExpr] Expr ;
AxisName ::= [NT-AxisName] "ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-sibling" | "namespace" | "parent" | "preceding" | "preceding-sibling" | "self" ;
Step ::= [NT-Step] (AxisSpecifier NodeTest Predicate*) | AbbreviatedStep ;
AbbreviatedAbsoluteLocationPath ::= [NT-AbbreviatedAbsoluteLocationPath] "//" RelativeLocationPath ;
Number ::= [NT-Number] (Digits ("." Digits?)?) | ("." Digits) ;
AbbreviatedStep ::= [NT-AbbreviatedStep] "." | ".." ;
UnaryExpr ::= [NT-UnaryExpr] UnionExpr | ("-" UnaryExpr) ;
ExprToken ::= [NT-ExprToken] "(" | ")" | "[" | "]" | "." | ".." | "@" | "," | "::" | NameTest | NodeType | Operator | FunctionName | AxisName | Literal | Number | VariableReference ;
AbbreviatedAxisSpecifier ::= [NT-AbbreviatedAxisSpecifier] "@"? ;
NameTest ::= [NT-NameTest] "*" | (NCName ":" "*") | QName ;
Argument ::= [NT-Argument] Expr ;
RelationalExpr ::= [NT-RelationalExpr] AdditiveExpr | (RelationalExpr "<" AdditiveExpr) | (RelationalExpr ">" AdditiveExpr) | (RelationalExpr "<=" AdditiveExpr) | (RelationalExpr ">=" AdditiveExpr) ;
PathExpr ::= [NT-PathExpr] LocationPath | FilterExpr | (FilterExpr "/" RelativeLocationPath) | (FilterExpr "//" RelativeLocationPath) ;
LocationPath ::= [NT-LocationPath] RelativeLocationPath | AbsoluteLocationPath ;
OrExpr ::= [NT-OrExpr] AndExpr | (OrExpr "or" AndExpr) ;
Predicate ::= [NT-Predicate] "[" PredicateExpr "]" ;
Expr ::= [NT-Expr] OrExpr ;
NodeTest ::= [NT-NodeTest] NameTest | (NodeType "(" ")") | ("processing-instruction" "(" Literal ")") ;
VariableReference ::= [NT-VariableReference] "$" QName ;
AndExpr ::= [NT-AndExpr] EqualityExpr | (AndExpr "and" EqualityExpr) ;
MultiplicativeExpr ::= [NT-MultiplicativeExpr] UnaryExpr | (MultiplicativeExpr MultiplyOperator UnaryExpr) | (MultiplicativeExpr "div" UnaryExpr) | (MultiplicativeExpr "mod" UnaryExpr) ;
MultiplyOperator ::= [NT-MultiplyOperator] "*" ;
Digits ::= [NT-Digits] ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ;
RelativeLocationPath ::= [NT-RelativeLocationPath] Step | (RelativeLocationPath "/" Step) | AbbreviatedRelativeLocationPath ;
UnionExpr ::= [NT-UnionExpr] PathExpr | (UnionExpr "|" PathExpr) ;
Operator ::= [NT-Operator] OperatorName | MultiplyOperator | "/" | "//" | "|" | "+" | "-" | "=" | "!=" | "<" | "<=" | ">" | ">=" ;
AdditiveExpr ::= [NT-AdditiveExpr] MultiplicativeExpr | (AdditiveExpr "+" MultiplicativeExpr) | (AdditiveExpr "-" MultiplicativeExpr) ;
--------------------markup::cnf.bgf--------------------
Disjuncts ::= [numbers] Number+ ;
Line ::= [comment] comment::Comment ;
 Line ::= [disjunct] disjunct::Disjunct ;
--------------------markup::csv-rascal-concrete.bgf--------------------
Table ::= [table] {Record EOL}* ;
Field ::= [quoted] QStr ;
 Field ::= [unquoted] UQStr ;
Record ::= [record] {Field ","}+ ;
--------------------markup::json-rascal-concrete.bgf--------------------
Object ::= [Object] "{" members::({Member ","}*) "}" ;
Member ::= [Member] memberName::StringLiteral ":" memberValue::Value ;
Array ::= [Array] "[" values::({Value ","}*) "]" ;
Value ::= NumericLiteral ;
 Value ::= StringLiteral ;
 Value ::= [True] "true" ;
 Value ::= Object ;
 Value ::= Array ;
 Value ::= [Null] "null" ;
 Value ::= [False] "false" ;
--------------------markup::wiki-simple.bgf--------------------
WikiText ::= [wss] WikiSymbol* ;
WikiLink ::= [barred] "[[" destination::PageName "|" description::(MWWord+) "]]" ;
 WikiLink ::= [simple] "[[" destination::PageName "]]" ;
WikiSymbol ::= [w] MWWord ;
 WikiSymbol ::= [wl] WikiLink ;
--------------------fl::dcg.bgf--------------------
expr ::= [binary] atom (ops atom)* ;
 expr ::= [apply] name atom+ ;
 expr ::= [ifThenElse] "if" expr "then" expr "else" expr ;
ops ::= [equal] "==" ;
 ops ::= [plus] "+" ;
 ops ::= [minus] "-" ;
atom ::= [literal] int ;
 atom ::= [argument] name ;
 atom ::= "(" expr ")" ;
--------------------fl::rascal-a.bgf--------------------
FLPrg ::= [prg] fs::(FLFun*) ;
FLFun ::= [fun] f::string() args::(str*) body::FLExpr ;
--------------------fl::rascal-c.bgf--------------------
Function ::= [fun] f::Name args::(Name+) "=" body::Expr ;
Expr ::= [ifThenElse] "if" cond::Expr "then" thenbranch::Expr "else" elsebranch::Expr ;
 Expr ::= "(" e::Expr ")" ;
 Expr ::= [literal] i::Int ;
 Expr ::= [argument] a::Name ;
 Expr ::= [binary] lexpr::Expr op::Ops rexpr::Expr ;
 Expr ::= [apply] f::Name vargs::(Expr+) ;
Program ::= [prg] functions::({Function "\n"}+) ;
Ops ::= [plus] "+" ;
 Ops ::= [equal] "==" ;
 Ops ::= [minus] "-" ;
--------------------fl::rascal.bgf--------------------
Expr ::= [binary] Expr Ops Expr ;
 Expr ::= [apply] Name Expr+ ;
 Expr ::= [ifThenElse] "if" Expr "then" Expr "else" Expr ;
 Expr ::= "(" Expr ")" ;
 Expr ::= [argument] Name ;
 Expr ::= [literal] Int ;
Ops ::= [minus] "-" ;
 Ops ::= [plus] "+" ;
 Ops ::= [equal] "==" ;
--------------------fl::sdf.bgf--------------------
Expr ::= [binary] Expr Ops Expr ;
 Expr ::= [apply] Name Expr+ ;
 Expr ::= [ifThenElse] "if" Expr "then" Expr "else" Expr ;
 Expr ::= "(" Expr ")" ;
 Expr ::= [argument] Name ;
 Expr ::= [literal] Int ;
Ops ::= [minus] "-" ;
 Ops ::= [plus] "+" ;
 Ops ::= [equal] "==" ;
--------------------metasyntax::s-expressions.bgf--------------------
SExp ::= [list] List ;
 SExp ::= [string] String ;
SimpleString ::= [raw] Raw ;
 SimpleString ::= [base64] Base64 ;
 SimpleString ::= [hex] HexaDecimal ;
 SimpleString ::= [token] Token ;
 SimpleString ::= [quoted] QuotedString ;
String ::= [display] Display SimpleString ;
 String ::= [simple] SimpleString ;
--------------------metasyntax::aterms-rascal.bgf--------------------
Annotation ::= [Default] "{" {ATerm ","}+ "}" ;
AFun ::= [Quoted] StrCon ;
 AFun ::= [Unquoted] IdCon ;
ATerm ::= [Appl] AFun "(" {ATerm ","}+ ")" ;
 ATerm ::= [Real] RealCon ;
 ATerm ::= [List] "[" {ATerm ","}* "]" ;
 ATerm ::= [Annotated] ATerm Annotation ;
 ATerm ::= [Placeholder] "<" ATerm ">" ;
 ATerm ::= [Int] IntCon ;
 ATerm ::= [Fun] AFun ;
OptExp ::= [Present] "e" IntCon ;
 OptExp ::= [Absent] ε ;
RealCon ::= [RealCon] IntCon "." NatCon OptExp ;
IntCon ::= [Positive] "+" NatCon ;
 IntCon ::= [Natural] NatCon ;
 IntCon ::= [Negative] "-" NatCon ;
--------------------metasyntax::sdf-rascal.bgf--------------------
AFun ::= [Quoted] StrCon ;
 AFun ::= [Unquoted] ε ;
Attribute ::= [Term] ATermAttribute ;
 Attribute ::= [Assoc] Assoc ;
 Attribute ::= [Bracket] "bracket" ;
 Attribute ::= [Id] "id" "(" ModuleName ")" ;
 Attribute ::= [Avoid] "avoid" ;
 Attribute ::= [Prefer] "prefer" ;
 Attribute ::= [Reject] "reject" ;
Renamings ::= [Renamings] "[" Renaming* "]" ;
ModuleName ::= [Parameterized] id::ModuleId "[" actuals::Syms "]" ;
 ModuleName ::= [Unparameterized] ε ;
Prod ::= [Prod] Syms "->" Sym Attrs ;
Assoc ::= [NonAssoc] "non-assoc" ;
 Assoc ::= [Assoc] "assoc" ;
 Assoc ::= [Left] "left" ;
 Assoc ::= [Right] "right" ;
Definition ::= [modules] Module* ;
IntCon ::= [Negative] "-" NatCon ;
 IntCon ::= [Natural] NatCon ;
 IntCon ::= [Positive] "+" NatCon ;
ArgumentIndicator ::= [Default] "<" {NatCon ","}+ ">" ;
Alias ::= [Alias] Sym "->" Sym ;
Restriction ::= [Follow] Syms "-/-" Lookaheads ;
Sym ::= [Empty] "(" ")" ;
 Sym ::= [Lit] StrCon ;
 Sym ::= [Opt] Sym "?" ;
 Sym ::= [Seq] "(" Sym Sym+ ")" ;
 Sym ::= [Bracket] "(" Sym ")" ;
 Sym ::= [CILit] SingleQuotedStrCon ;
 Sym ::= [Varsym] "<" Sym "-VAR" ">" ;
 Sym ::= [Sort] Sort ;
 Sym ::= [Lex] "<" Sym "-LEX" ">" ;
 Sym ::= [Layout] "LAYOUT" ;
 Sym ::= [CF] "<" Sym "-CF" ">" ;
 Sym ::= [ParameterizedSort] Sort "[[" {Sym ","}+ "]]" ;
 Sym ::= [IterStar] Sym "*" ;
 Sym ::= [IterStarSep] "{" Sym Sym "}" "*" ;
 Sym ::= [Iter] Sym "+" ;
 Sym ::= [Class] Class ;
 Sym ::= [IterSep] "{" Sym Sym "}" "+" ;
 Sym ::= [Alt] Sym "|" Sym ;
 Sym ::= [Label] Label ":" Sym ;
RealCon ::= [RealCon] IntCon "." NatCon OptExp ;
FunctionName ::= [QuotedFun] StrCon ;
 FunctionName ::= [UnquotedFun] IdCon ;
Lookahead ::= [Class] class::Class ;
 Lookahead ::= [Seq] class::Class "." las::Lookaheads ;
Group ::= [NonTransitive] Group "." ;
 Group ::= [AssocGroup] "{" Assoc ":" Prods "}" ;
 Group ::= [WithArguments] Group ArgumentIndicator ;
 Group ::= [SimpleGroup] Prod ;
 Group ::= [ProdsGroup] "{" Prods "}" ;
Range ::= [Range] Character "-" Character ;
 Range ::= Character ;
Renaming ::= [production] Prod "=>" Prod ;
 Renaming ::= [Sym] Sym "=>" Sym ;
ImpSection ::= [Imports] "imports" Imports ;
Class ::= [SimpleCharClass] "[" Range* "]" ;
 Class ::= [Bracket] "(" Class ")" ;
 Class ::= [Comp] "~" Class ;
 Class ::= [Diff] Class "/" Class ;
 Class ::= [ISect] Class "/\" Class ;
 Class ::= [Union] Class "\/" Class ;
SDF ::= [Definition] "definition" def::Definition ;
Label ::= [IdCon] ε ;
 Label ::= [Quoted] StrCon ;
Lookaheads ::= [Single] Lookahead ;
 Lookaheads ::= [Alt] Lookaheads "|" Lookaheads ;
 Lookaheads ::= [List] "[[" {Lookahead ","}* "]]" ;
 Lookaheads ::= [Bracket] "(" Lookaheads ")" ;
ATermAttribute ::= [Default] ε ;
Annotation ::= [Default] "{" {ATerm ","}+ "}" ;
ATerm ::= [Real] RealCon ;
 ATerm ::= [Appl] AFun "(" {ATerm ","}+ ")" ;
 ATerm ::= [Annotated] ATerm Annotation ;
 ATerm ::= [Placeholder] "<" ATerm ">" ;
 ATerm ::= [Int] IntCon ;
 ATerm ::= [Fun] AFun ;
 ATerm ::= [List] "[" {ATerm ","}* "]" ;
Module ::= [Module] "module" ModuleName ImpSection* Sections ;
OptExp ::= [Present] "e" IntCon ;
 OptExp ::= [Absent] ε ;
Character ::= [eof] "\EOF" ;
 Character ::= [short] ShortChar ;
 Character ::= [Numeric] NumChar ;
 Character ::= [top] "\TOP" ;
 Character ::= [label_start] "\LABEL_START" ;
 Character ::= [bot] "\BOT" ;
Restrictions ::= [Default] Restriction* ;
Grammar ::= [ContextFreePriorities] "context-free" "priorities" Priorities ;
 Grammar ::= [ImpSection] ImpSection ;
 Grammar ::= [KernalStartSyms] "start-symbols" Syms ;
 Grammar ::= [Aliases] "aliases" Aliases ;
 Grammar ::= [Variables] "variables" Prods ;
 Grammar ::= [ContextFreeSyntax] "context-free" "syntax" Prods ;
 Grammar ::= [LexicalRestrictions] "lexical" "restrictions" Restrictions ;
 Grammar ::= [Sorts] "sorts" Syms ;
 Grammar ::= [ContextFreeStartSyms] "context-free" "start-symbols" Syms ;
 Grammar ::= [Syntax] "syntax" Prods ;
 Grammar ::= [Restrictions] "restrictions" Restrictions ;
 Grammar ::= [Priorities] "priorities" Priorities ;
 Grammar ::= [LexicalStartSyms] "lexical" "start-symbols" Syms ;
 Grammar ::= [LexicalVariables] "lexical" "variables" Prods ;
 Grammar ::= [ContextFreeRestrictions] "context-free" "restrictions" Restrictions ;
 Grammar ::= [LexicalPriorities] "lexical" "priorities" Priorities ;
 Grammar ::= [LexicalSyntax] "lexical" "syntax" Prods ;
Import ::= [Bracket] "(" Import ")" ;
 Import ::= [Module] ModuleName ;
 Import ::= [RenamedModule] ModuleName Renamings ;
Section ::= [Exports] "exports" Grammar* ;
 Section ::= [Hiddens] "hiddens" Grammar* ;
Priority ::= [Chain] {Group ">"}+ ;
 Priority ::= [Assoc] Group Assoc Group ;
Attrs ::= [Attrs] "{" {Attribute ","}* "}" ;
 Attrs ::= [NoAttrs] ε ;
--------------------hats::abs.bgf--------------------
SqlTupleConstant ::= [i] IntLiteral ;
 SqlTupleConstant ::= [s] SqlStringLiteral ;
 SqlTupleConstant ::= TRUE ;
 SqlTupleConstant ::= MINUS i::IntLiteral ;
 SqlTupleConstant ::= FALSE ;
 SqlTupleConstant ::= [r] VarOrFieldRef ;
SimpleName ::= [id] IDENTIFIER ;
Exp ::= [e] DataExp ;
 Exp ::= [e] EffExp ;
AttrAssignmentList ::= [a] AttrAssignment ;
 AttrAssignmentList ::= l::AttrAssignmentList COMMA a::AttrAssignment ;
SqlTupleCaseBranches ::= l::SqlTupleCaseBranches b::SqlTupleCaseBranch ;
 SqlTupleCaseBranches ::= [b] SqlTupleCaseBranch ;
Deltaparam ::= [i] INTLITERAL ;
 Deltaparam ::= [c] TYPE_IDENTIFIER ;
 Deltaparam ::= fid::TYPE_IDENTIFIER DOT aid::IDENTIFIER ;
ParamDeclList ::= l::ParamDeclList COMMA i::ParamDecl ;
 ParamDeclList ::= [i] ParamDecl ;
AdaptationList ::= l::AdaptationList ad::Adaptation ;
 AdaptationList ::= [ad] Adaptation ;
Pattern ::= USCORE ;
 Pattern ::= [l] Literal ;
 Pattern ::= [v] IDENTIFIER ;
 Pattern ::= ConstructorPattern ;
InfModifierFragmentList ::= l::InfModifierFragmentList f::InfModifierFragment ;
 InfModifierFragmentList ::= [f] InfModifierFragment ;
TypeExp ::= [n] TypeName ;
 TypeExp ::= n::TypeName LT p::DatatypeuseList GT ;
ConstructorExp ::= [f] TypeName ;
 ConstructorExp ::= f::TypeName LPAREN (l::DataExpList)? RPAREN ;
IntLiteral ::= [i] INTLITERAL ;
MmultExp ::= e1::MmultExp MULT e2::MfactorExp ;
 MmultExp ::= [e] MfactorExp ;
 MmultExp ::= e1::MmultExp DIV e2::MfactorExp ;
 MmultExp ::= e1::MmultExp MOD e2::MfactorExp ;
DeltaParamDeclList ::= [i] DeltaParamDecl ;
 DeltaParamDeclList ::= l::DeltaParamDeclList COMMA i::DeltaParamDecl ;
AddExp ::= e1::AddExp PLUS e2::MultExp ;
 AddExp ::= [e] MultExp ;
 AddExp ::= e1::AddExp MINUS e2::MultExp ;
DeltaAccessList ::= [t] DeltaAccess ;
 DeltaAccessList ::= l::DeltaAccessList t::DeltaAccess ;
ConstructorArgList ::= l::ConstructorArgList COMMA a::ConstructorArg ;
 ConstructorArgList ::= [a] ConstructorArg ;
SqlOrderingAttributeList ::= l::SqlOrderingAttributeList COMMA a::SqlOrderingAttribute ;
 SqlOrderingAttributeList ::= [a] SqlOrderingAttribute ;
SimpleTypeName ::= [id] TYPE_IDENTIFIER ;
DeltaList ::= l::DeltaList COMMA id::Delta ;
 DeltaList ::= [id] Delta ;
FactorAppcond ::= LPAREN ac::Appcond RPAREN ;
 FactorAppcond ::= [f] Feature ;
 FactorAppcond ::= NEGATION ac::FactorAppcond ;
DeltaId ::= [delta] TYPE_IDENTIFIER ;
SqlAttrsDef ::= MULT ;
 SqlAttrsDef ::= [l] SqlAttrDefList ;
SqlStringLiteral ::= [s] SQLSTRINGLITERAL ;
ExpFunctionDef ::= [ef] DataExp ;
CaseBranchList ::= l::CaseBranchList b::CaseBranch ;
 CaseBranchList ::= [b] CaseBranch ;
AtomicSqlTupleScalarFunction ::= [a] StringLiteral ;
 AtomicSqlTupleScalarFunction ::= SqlTupleConstant ;
 AtomicSqlTupleScalarFunction ::= SqlTupleCaseFunction ;
MaddExp ::= e1::MaddExp MINUS e2::MmultExp ;
 MaddExp ::= [e] MmultExp ;
 MaddExp ::= e1::MaddExp PLUS e2::MmultExp ;
Fnode ::= OPT f::FeatureDecl ;
 Fnode ::= [f] FeatureDecl ;
Ifname ::= [n] TypeName ;
DatatypeparamList ::= l::DatatypeparamList COMMA p::Datatypeparam ;
 DatatypeparamList ::= [p] Datatypeparam ;
SqlAttrDef ::= fun::SqlAggregateFunction AS e::DataExp ;
 SqlAttrDef ::= [f] Factor ;
BoundaryInt ::= [i] INTLITERAL ;
 BoundaryInt ::= MULT ;
 BoundaryInt ::= MINUS i::INTLITERAL ;
StmtWithoutAnnotations ::= REBIND field::IDENTIFIER ASSIGN e::Exp ;
 StmtWithoutAnnotations ::= r::VarOrFieldRef ASSIGN e::Exp ;
 StmtWithoutAnnotations ::= SKIP ;
 StmtWithoutAnnotations ::= REBIND obj::Exp COLON field::IDENTIFIER ASSIGN e::Exp ;
 StmtWithoutAnnotations ::= [e] EffExp ;
 StmtWithoutAnnotations ::= [vd] VarDecl ;
 StmtWithoutAnnotations ::= DURATION LPAREN min::DataExp COMMA max::DataExp RPAREN ;
 StmtWithoutAnnotations ::= SUBLOC sub::PureExp IN father::PureExp ;
 StmtWithoutAnnotations ::= ASSERT e::DataExp ;
 StmtWithoutAnnotations ::= AWAIT Guard ;
 StmtWithoutAnnotations ::= SUSPEND ;
 StmtWithoutAnnotations ::= RETURN e::Exp ;
 StmtWithoutAnnotations ::= MOVECOGTO DataExp ;
DatatypeuseList ::= [i] Datatypeuse ;
 DatatypeuseList ::= l::DatatypeuseList COMMA i::Datatypeuse ;
ModuleModifierList ::= l::ModuleModifierList m::ModuleModifier ;
 ModuleModifierList ::= [m] ModuleModifier ;
MethodList ::= l::MethodList i::Method ;
 MethodList ::= [i] Method ;
StringLiteral ::= [s] STRINGLITERAL ;
SqlAtomicRelationRef ::= [r] StringLiteral ;
 SqlAtomicRelationRef ::= [r] VarOrFieldRef ;
SqlTupleConstantList ::= [c] SqlTupleConstant ;
 SqlTupleConstantList ::= l::SqlTupleConstantList COMMA c::SqlTupleConstant ;
AnyNameList ::= [n] AnyName ;
 AnyNameList ::= l::AnyNameList COMMA n::AnyName ;
DeltaparamList ::= l::DeltaparamList COMMA p::Deltaparam ;
 DeltaparamList ::= [p] Deltaparam ;
DataExpList ::= l::DataExpList COMMA i::DataExp ;
 DataExpList ::= [i] DataExp ;
PatternList ::= l::PatternList COMMA i::Pattern ;
 PatternList ::= [i] Pattern ;
MultExp ::= e1::MultExp MULT e2::Factor ;
 MultExp ::= e1::MultExp MOD e2::Factor ;
 MultExp ::= [f] Factor ;
 MultExp ::= e1::MultExp DIV e2::Factor ;
SqlAttrAssignmentList ::= [a] SqlAttrAssignment ;
 SqlAttrAssignmentList ::= l::SqlAttrAssignmentList COMMA a::SqlAttrAssignment ;
SqlAggregateFunction ::= COUNT LPAREN MULT RPAREN ;
 SqlAggregateFunction ::= [f] SqlTupleScalarFunction ;
 SqlAggregateFunction ::= i::IDENTIFIER LPAREN f::SqlTupleScalarFunction RPAREN ;
StmtList ::= l::StmtList i::Stmt ;
 StmtList ::= [i] Stmt ;
ModifierFragmentList ::= [f] ModifierFragment ;
 ModifierFragmentList ::= l::ModifierFragmentList f::ModifierFragment ;
VarOrFieldRef ::= callee::THIS b::BANG (method::IDENTIFIER)? ;
 VarOrFieldRef ::= [n] IDENTIFIER ;
 VarOrFieldRef ::= callee::THIS d::DOT ;
 VarOrFieldRef ::= THIS DOT id::IDENTIFIER ;
DeltaDeclList ::= [t] DeltaDecl ;
 DeltaDeclList ::= l::DeltaDeclList t::DeltaDecl ;
FeatureDecl ::= [f] TYPE_IDENTIFIER ;
 FeatureDecl ::= f::TYPE_IDENTIFIER LBRACE (g::Group)? acl::AttributeConstraintList RBRACE ;
DeltaParamDecl ::= [p] ParamDecl ;
 DeltaParamDecl ::= id::TYPE_IDENTIFIER c::HasCondition ;
ConstructorArg ::= [u] Datatypeuse ;
 ConstructorArg ::= u::Datatypeuse id::IDENTIFIER ;
SqlOrderingAttribute ::= e::DataExp DESC ;
 SqlOrderingAttribute ::= [e] DataExp ;
 SqlOrderingAttribute ::= e::DataExp ASC ;
Delta ::= [id] TYPE_IDENTIFIER ;
Featvar ::= [f] TYPE_IDENTIFIER ;
ModuleDeclList ::= l::ModuleDeclList t::ModuleDecl ;
 ModuleDeclList ::= [t] ModuleDecl ;
FeatureList ::= [f] Feature ;
 FeatureList ::= l::FeatureList COMMA f::Feature ;
MlitExp ::= [i] INTLITERAL ;
 MlitExp ::= [id] IDENTIFIER ;
 MlitExp ::= f::TYPE_IDENTIFIER DOT a::IDENTIFIER ;
 MlitExp ::= [id] TYPE_IDENTIFIER ;
SqlAttrRefList ::= l::SqlAttrRefList COMMA a::SqlAttrRef ;
 SqlAttrRefList ::= [a] SqlAttrRef ;
ExportList ::= [t] Export ;
 ExportList ::= l::ExportList t::Export ;
Literal ::= [i] IntLiteral ;
 Literal ::= [s] StringLiteral ;
DataConstructorList ::= [i] DataConstructor ;
 DataConstructorList ::= l::DataConstructorList BAR i::DataConstructor ;
IntList ::= MINUS i::INTLITERAL ;
 IntList ::= il::IntList COMMA MINUS i::INTLITERAL ;
 IntList ::= il::IntList COMMA i::INTLITERAL ;
 IntList ::= [i] INTLITERAL ;
ProductList ::= [p] Product ;
 ProductList ::= l::ProductList p::Product ;
AnnotationList ::= l::AnnotationList a::Annotation ;
 AnnotationList ::= [a] Annotation ;
Datatypeparam ::= [id] TYPE_IDENTIFIER ;
DeclList ::= l::DeclList t::Decl ;
 DeclList ::= [t] Decl ;
IfnameList ::= l::IfnameList COMMA i::Ifname ;
 IfnameList ::= [i] Ifname ;
FnodeList ::= ε ;
 FnodeList ::= l::FnodeList COMMA f::Fnode ;
 FnodeList ::= [f] Fnode ;
Guard ::= [e] DataExp ;
 Guard ::= r::VarOrFieldRef QMARK ;
 Guard ::= BAR e::Exp BAR ;
 Guard ::= DURATION LPAREN min::DataExp COMMA max::DataExp RPAREN ;
 Guard ::= g1::Guard GUARDAND g2::Guard ;
ABSGoal ::= [cu] CompilationUnit ;
SqlAttrDefList ::= [a] SqlAttrDef ;
 SqlAttrDefList ::= l::SqlAttrDefList COMMA a::SqlAttrDef ;
ModuleModifier ::= [m] OoModifier ;
 ModuleModifier ::= [m] FunctionalModifier ;
ImportList ::= [t] Import ;
 ImportList ::= l::ImportList t::Import ;
--------------------metamodels::logic-concrete.bgf--------------------
Formula ::= [not] "!" arg::Formula ;
 Formula ::= [true] "true" ;
 Formula ::= [false] "false" ;
 Formula ::= [and] lhs::Formula "&" rhs::Formula ;
 Formula ::= [or] lhs::Formula "|" rhs::Formula ;
 Formula ::= [fi] lhs::Formula "<=" rhs::Formula ;
 Formula ::= [if] lhs::Formula "=>" rhs::Formula ;
 Formula ::= [iff] lhs::Formula "<=>" rhs::Formula ;
 Formula ::= [id] ε ;
--------------------pico::rascal.bgf--------------------
Statement ::= [cond] "if" cond::Expression "then" thenPart::({Statement ";"}*) "else" elsePart::({Statement ";"}*) "fi" ;
 Statement ::= [assign] var::Id ":=" val::Expression ;
 Statement ::= [cond] "if" cond::Expression "then" thenPart::({Statement ";"}*) "fi" ;
 Statement ::= [loop] "while" cond::Expression "do" body::({Statement ";"}*) "od" ;
Type ::= [string] "string" ;
 Type ::= [natural] "natural" ;
 Type ::= [nil] "nil-type" ;
Expression ::= "(" e::Expression ")" ;
 Expression ::= [natcon] natcon::Natural ;
 Expression ::= [id] name::Id ;
 Expression ::= [strcon] string::String ;
 Expression ::= [concat] lhs::Expression "||" rhs::Expression ;
 Expression ::= [add] lhs::Expression "+" rhs::Expression ;
 Expression ::= [min] lhs::Expression "-" rhs::Expression ;
IdType ::= [idtype] id::Id ":" t::Type ;
Program ::= [program] "begin" decls::Declarations body::({Statement ";"}*) "end" ;
--------------------saf::concrete.bgf--------------------
Fighter ::= [fighter] name::Id "{" specs::(Spec*) "}" ;
Spec ::= [behavior] cond::Cond "[" move::Action fight::Action "]" ;
 Spec ::= [attribute] name::Id "=" strength::Number ;
Action ::= [action] Id ;
 Action ::= [choose] "choose" "(" actions::(Id*) ")" ;
Cond ::= [and] lhs::Cond "and" rhs::Cond ;
 Cond ::= [const] Id ;
 Cond ::= [or] lhs::Cond "or" rhs::Cond ;
