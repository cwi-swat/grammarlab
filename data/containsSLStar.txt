--------------------ada::cordy-hyaric.bgf--------------------
discriminant_constraint ::= "(" {discriminant_association ","}* ")" ;
--------------------c::malton-dahn.bgf--------------------
asm_clobbered_registers ::= ":" {string ","}* ;
preprocessor ::= ("#define" id "(" id+ ")" expression NL) | ("#define" id expression NL) | (EX "#else" IN NL) | (EX "#endif" NL NL) | (NL "#if" expression IN NL) | (NL "#ifdef" id IN NL) | (NL "#ifndef" id IN NL) | ("#ident" stringlit NL) | ("#include" stringlit NL) | ("#include" "<" SPOFF filepath ">" SPON NL) | ("#line" integernumber stringlit? NL) | ("#undef" id NL) | ("#LINK" stringlit NL) ;
 preprocessor ::= (EX "#endif" comment_NL? NL) | "..." ;
 preprocessor ::= "..." comment_NL? ;
 preprocessor ::= ("#" integernumber string integernumber* NL) | ("#pragma" SPON id* "(" {id ","}* ")" NL) ;
attribute_spec ::= "__attribute__" "('(" {attribute_extension ","}* ")')" ;
attribute_extension ::= (attribute_alias "(" string ")") | attribute_aligned | (attribute_aligned "(" tagged_attribute_number ")") | (attribute_aligned "(" alignof_expression ")") | attribute_always_inline | attribute_cdecl | (attribute_cleanup "(" tagged_attribute_id ")") | attribute_const | attribute_constructor | attribute_deprecated | attribute_destructor | attribute_dllexport | attribute_dllimport | attribute_eightbit | (attribute_exception "(" exception_function {exception_arg ","}* ")") | attribute_far | attribute_funvector | (attribute_format "(" format_archetype "," tagged_attribute_number "," tagged_attribute_number ")") | (attribute_format_arg "(" tagged_attribute_number ")") | attribute_interrupt | (attribute_interrupt "(" string ")") | attribute_interrupt_handler | (attribute_interrupt_handler "(" string ")") | attribute_longcall | attribute_long_call | attribute_malloc | attribute_may_alias | (attribute_mode "(" tagged_attribute_id ")") | (attribute_model "(" attribute_model_name ")") | attribute_naked | attribute_near | attribute_no_check_mem | attribute_no_instrument | attribute_nocommon | attribute_noinline | attribute_nonnull | (attribute_nonnull "(" tagged_attribute_number+ ")") | attribute_noreturn | attribute_nothrow | attribute_packed | attribute_pure | (attribute_regparm "(" tagged_attribute_number ")") | (attribute_section "(" string ")") | attribute_shared | attribute_short_call | (attribute_signal "(" string ")") | (attribute_sp_switch "(" string ")") | attribute_stdcall | attribute_tiny | (attribute_tls_model "(" tls_model_type ")") | attribute_trans_union | (attribute_trap_exit "(" tagged_attribute_number ")") | attribute_used | attribute_unused | (attribute_vector_size "(" tagged_attribute_number ")") | (attribute_visibility "(" visibility_type ")") | attribute_weak ;
compound_literal ::= ("(" struct_or_union_specifier ")" "{" {designated_initializer ","}* ","? "}") | ("(" compound_literal_array_type ")" "{" {designated_initializer ","}* ","? "}") | ("(" compound_literal ")") ;
argument_declaration_list ::= {argument_declaration ","}* ;
 argument_declaration_list ::= "..." comment_NL* ;
postfix_extension ::= ("[" expression "]") | ("(" expression? ")") | ("." id) | ("->" id) | "++" | "--" ;
 postfix_extension ::= ("[" expression "]") | ("(" {argument_expression ","}* ")") | ("." id) | ("->" id) | "++" | "--" ;
asm_output_operands ::= ":" {asm_operand ","}* ;
designated_initializer ::= assignment_expression | (designator* designator_assignment? assignment_expression) | (designator* designator_assignment? NL "{" IN {designated_initializer ","}* ","? EX "}") ;
asm_input_operands ::= ":" {asm_operand ","}* ;
initializer ::= expression | (NL "{" IN {initializer ","}* ","? EX "}") ;
 initializer ::= comment_NL* "..." ;
 initializer ::= assignment_expression | (NL "{" IN {designated_initializer ","}* ","? EX "}") ;
enum_specifier ::= ("enum" tagged_reference_id? "{" {enumerator ","}* "}") | ("enum" tagged_reference_id) ;
 enum_specifier ::= ("enum" tagged_reference_id) | ("enum" tagged_reference_id? "{" {enumerator ","}* ","? "}") ;
--------------------c::cordy-malton-dahn.bgf--------------------
asm_clobbered_registers ::= ":" {asm_register ","}* NL ;
compound_initializer ::= ("{" "}") | ("{" IN {initializer ","}* ","? ";"? preprocessor_list_initializer* EX NL "}") ;
attribute_spec ::= (attribute_specifier "('(" {attribute_extension ","}* ")')") | (IN NL acquires_releases "(" expression ")" EX) | upper_macro_name ;
constructor_expression ::= ("(" constructor_type ")" "{" {initializer ","}* ","? "}") | ("(" constructor_expression ")") ;
sub_member_declarators ::= "(" {member_declarator ","}* ")" ;
declaration ::= (decl_specifiers {init_declarator ","}* semi) | (decl_specifiers declarator "=" compound_initializer NL) | extern_langauge_declaration | null_declaration | (local_label declarator+) | asm_spec | machinestart_declaration | preprocessor ;
machinestart_declaration ::= "MACHINE_START" "(" expression_list ")" IN {initializer ","}* ","? EX NL "MACHINE_END" ";"? NL ;
postfix_extension ::= ("[" SPON assignment_expression SPOFF "]") | (SP "(" SPON {argument_expression ","}* dotdot? SPOFF ")") | ("." id) | ("->" id macro_call?) | "++" | "--" ;
argument_declaration_list ::= {argument_declaration ","}* comma_dotdotdot? ;
member_declaration ::= (decl_specifiers {member_declarator ","}* semi) | null_declaration | preprocessor ;
ps_argument_list ::= {ps_argument ","}* ;
asm_output_operands ::= ":" {asm_operand ","}* NL ;
macro_type_arguments ::= "(" {macro_type_argument ","}* ")" ;
asm_input_operands ::= ":" {asm_operand ","}* NL ;
preprocessor_list_initializer ::= preprocessor {initializer ","}* ","? ;
enum_specifier ::= ("enum" reference_id) | ("enum" reference_id? "{" {enumerator ","}* ","? preprocessor* "}") ;
--------------------c::cordy-malton.bgf--------------------
argument_declaration_list ::= {argument_declaration ","}* ;
initializer ::= expression | (NL "{" IN {initializer ","}* ","? EX "}") ;
enum_specifier ::= ("enum" tagged_reference_id? "{" {enumerator ","}* "}") | ("enum" tagged_reference_id) ;
--------------------c::lankamp.bgf--------------------
Expression ::= CharacterConstant ;
 Expression ::= Expression "--" ;
 Expression ::= [Variable] Identifier ;
 Expression ::= Expression "[" Expression "]" ;
 Expression ::= [Bracket] "(" Expression ")" ;
 Expression ::= "sizeof" "(" TypeName ")" ;
 Expression ::= Expression "++" ;
 Expression ::= FloatingPointConstant ;
 Expression ::= Expression "." Identifier ;
 Expression ::= StringConstant ;
 Expression ::= IntegerConstant ;
 Expression ::= HexadecimalConstant ;
 Expression ::= Expression "->" Identifier ;
 Expression ::= Expression "(" {NonCommaExpression ","}* ")" ;
 Expression ::= Expression ;
 Expression ::= [SizeOfExpression] "sizeof" exp::Expression ;
 Expression ::= "&" Expression ;
 Expression ::= "!" Expression ;
 Expression ::= "(" TypeName ")" Expression ;
 Expression ::= "*" Expression ;
 Expression ::= "+" Expression ;
 Expression ::= "-" Expression ;
 Expression ::= "~" Expression ;
 Expression ::= [MultiplicationExpression] lexp::Expression "*" rexp::Expression ;
 Expression ::= Expression "/" Expression ;
 Expression ::= Expression "%" Expression ;
 Expression ::= Expression "+" Expression ;
 Expression ::= Expression "-" Expression ;
 Expression ::= Expression ">>" Expression ;
 Expression ::= Expression "<<" Expression ;
 Expression ::= Expression "<=" Expression ;
 Expression ::= Expression ">=" Expression ;
 Expression ::= Expression ">" Expression ;
 Expression ::= Expression "<" Expression ;
 Expression ::= Expression "==" Expression ;
 Expression ::= Expression "!=" Expression ;
 Expression ::= Expression "&" Expression ;
 Expression ::= Expression "^" Expression ;
 Expression ::= Expression "|" Expression ;
 Expression ::= Expression "&&" Expression ;
 Expression ::= Expression "||" Expression ;
 Expression ::= Expression "?" Expression ":" Expression ;
 Expression ::= Expression "|=" Expression ;
 Expression ::= Expression "&=" Expression ;
 Expression ::= Expression "*=" Expression ;
 Expression ::= Expression "/=" Expression ;
 Expression ::= Expression "+=" Expression ;
 Expression ::= Expression ">>=" Expression ;
 Expression ::= Expression "^=" Expression ;
 Expression ::= Expression "-=" Expression ;
 Expression ::= Expression "<<=" Expression ;
 Expression ::= Expression "%=" Expression ;
 Expression ::= Expression "=" Expression ;
 Expression ::= [CommaExpression] Expression "," Expression ;
--------------------cpp::elges-cordy.bgf--------------------
base_list ::= base_specifier ","? {base_specifier ","}* ;
parameter_declaration_list ::= {parameter_declaration ","}* comma_dotdotdot? ;
--------------------cs::csharp-zaytsev.bgf--------------------
argument-list ::= {argument ","}* ;
--------------------cs::csharp-cordy.bgf--------------------
input_parameters ::= input_parameter | ("(" {input_parameter ","}* ")") ;
attribute_argument_list ::= {attribute_argument ","}* ;
type_parameter_constraints ::= {type_parameter_constraint ","}* ;
orderby_clause ::= "orderby" {key_expr_ascending_descending ","}* ;
invocation_operator ::= "(" {argument ","}* ")" ;
 invocation_operator ::= "((" argument_list_or_key* "))" ;
argument_list ::= {argument ","}* ;
--------------------eiffel::cordy.bgf--------------------
Actual_list ::= {Actual ","}* ;
Restricted_type_list ::= {Restricted_type ","}* ;
Rename_list ::= {Rename_pair ","}* ;
Debug_key_list ::= {Debug_key ","}* ;
Index_terms ::= {Index_value ","}* ;
Feature_list ::= IN NL {Feature_name ","}* EX ;
Formal_generic_list ::= {Formal_generic ","}* ;
Expression_list ::= {Expression ","}* ;
Class_list ::= {Class_name ","}* ;
Type_list ::= {Type ","}* ;
Choices ::= {Choice ","}* ;
Attribute_list ::= {Identifier ","}* ;
--------------------eiffel::iso-25436-2006.bgf--------------------
Comment ::= "--" {Simple_string Comment_break}* ;
External_type_list ::= {External_type ","}* ;
Feature_declaration_list ::= {Feature_declaration ";"}* ;
Compound ::= {Instruction ";"}* ;
Note_list ::= {Note_entry ";"}* ;
Expression_list ::= {Expression ","}* ;
Assertion ::= {Assertion_clause ";"}* ;
--------------------fortran::waite-cordy.bgf--------------------
InquireSpecList ::= UnitIdentifier? {InquireSpec ","}* ;
ImplicitRanges ::= {ImplicitRange ","}* ;
FunctionPars ::= {FunctionPar ","}* ;
SubroutinePars ::= {SubroutinePar ","}* ;
ConnectSpecList ::= UnitIdentifierComma? {ConnectSpec ","}* ;
CloseSpecList ::= UnitIdentifierComma? {CloseSpec ","}* ;
SubroutineArgList ::= {SubroutineArg ","}* ;
--------------------java::java-1-cordy-guo.bgf--------------------
for_update ::= {expression ","}* ;
method_declarator ::= method_name "(" {formal_parameter ","}* ")" dimension* ;
array_initializer ::= "{" {variable_initializer ","}* ","? "}" ;
method_argument ::= "(" {argument ","}* ")" ;
for_init ::= ({expression ","}* ";") | local_variable_declaration ;
constructor_declarator ::= class_name "(" {formal_parameter ","}* ")" ;
class_instance_creation_expression ::= "new" class_or_interface_name "(" {argument ","}* ")" class_body? ;
--------------------java::java-5-cordy-guo-dean.bgf--------------------
for_update ::= {expression ","}* ;
method_declarator ::= method_name "(" {formal_parameter ","}* ")" dimension* ;
annotation_value_list ::= (single_annotation_value) | ({keyed_annotation_value ","}*) ;
array_initializer ::= "{" {variable_initializer ","}* ","? "}" ;
method_argument ::= "(" {argument ","}* ")" ;
single_annotation_value ::= (expression) | nested_annotation | ("{" {expression_or_nested_annotation ","}* "}") ;
for_init ::= ({expression ","}* ";") | local_variable_declaration ;
constructor_declarator ::= class_name "(" {formal_parameter ","}* ")" ;
generic_argument ::= "<" {type_argument ","}* ">" ;
class_instance_creation_expression ::= "new" class_or_interface_name "(" {argument ","}* ")" class_body? ;
generic_parameter ::= "<" {type_parameter ","}* ">" ;
enum_body ::= "{" IN {enum_element ","}* ","? class_body_declaration* EX "}" ";"? NL NL ;
--------------------java::java-5-landman.bgf--------------------
AbstractMethodDec ::= [abstractMethodDec] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";" ;
 AbstractMethodDec ::= [deprAbstractMethodDec] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" ;
ConstrHead ::= [constrDecHead] TypeParams? Id "(" {FormalParam ","}* ")" Throws? ;
EnumConstArgs ::= "(" {Expr ","}* ")" ;
Anno ::= [singleElemAnno] "@" TypeName "(" ")" ;
 Anno ::= [anno] "@" TypeName "(" {ElemValPair ","}* ")" ;
 Anno ::= [markerAnno] "@" TypeName ;
Stm ::= [synchronized] "synchronized" "(" Expr ")" Block ;
 Stm ::= [exprStm] Expr ";" ;
 Stm ::= [for] "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm ;
 Stm ::= [for] "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm ;
 Stm ::= Block ;
 Stm ::= [continue] "continue" Id? ";" ;
 Stm ::= [try] "try" Block CatchClause+ ;
 Stm ::= [throw] "throw" Expr ";" ;
 Stm ::= [switch] "switch" "(" Expr ")" SwitchBlock ;
 Stm ::= [if] "if" "(" Expr ")" Stm ;
 Stm ::= [break] "break" Id? ";" ;
 Stm ::= [empty] ";" ;
 Stm ::= [labeled] Id ":" Stm ;
 Stm ::= [assertStm] "assert" Expr ":" Expr ";" ;
 Stm ::= [forEach] "for" "(" FormalParam ":" Expr ")" Stm ;
 Stm ::= [assertStm] "assert" Expr ";" ;
 Stm ::= [try] "try" Block CatchClause* "finally" Block ;
 Stm ::= [return] "return" Expr? ";" ;
 Stm ::= [doWhile] "do" Stm "while" "(" Expr ")" ";" ;
 Stm ::= [while] "while" "(" Expr ")" Stm ;
 Stm ::= [if] "if" "(" Expr ")" Stm "else" Stm ;
ArrayInit ::= [arrayInit] "{" {VarInit ","}* "," "}" ;
 ArrayInit ::= [arrayInit] "{" {VarInit ","}* "}" ;
Expr ::= [postDecr] Expr "--" ;
 Expr ::= [postIncr] Expr "++" ;
 Expr ::= [castPrim] "(" PrimType ")" Expr ;
 Expr ::= [castRef] "(" RefType ")" Expr ;
 Expr ::= [minus] Expr ;
 Expr ::= [preIncr] "++" Expr ;
 Expr ::= [plus] Expr ;
 Expr ::= [preDecr] "--" Expr ;
 Expr ::= [this] "this" ;
 Expr ::= [mul] Expr "*" Expr ;
 Expr ::= [div] Expr Expr ;
 Expr ::= [remain] Expr "%" Expr ;
 Expr ::= [qThis] TypeName "." "this" ;
 Expr ::= [complement] "~" Expr ;
 Expr ::= [not] "!" Expr ;
 Expr ::= [plus] Expr Expr ;
 Expr ::= [minus] Expr Expr ;
 Expr ::= [uRightShift] Expr ">>>" Expr ;
 Expr ::= [rightShift] Expr ">>" Expr ;
 Expr ::= [leftShift] Expr "<<" Expr ;
 Expr ::= [ltEq] Expr "<=" Expr ;
 Expr ::= [lt] Expr "<" Expr ;
 Expr ::= [gtEq] Expr ">=" Expr ;
 Expr ::= [instanceOf] Expr "instanceof" RefType ;
 Expr ::= [gt] Expr ">" Expr ;
 Expr ::= [eq] Expr "==" Expr ;
 Expr ::= [notEq] Expr "!=" Expr ;
 Expr ::= [and] Expr "&" Expr ;
 Expr ::= [excOr] Expr "^" Expr ;
 Expr ::= [or] Expr "|" Expr ;
 Expr ::= [lazyAnd] Expr "&&" Expr ;
 Expr ::= [lazyOr] Expr "||" Expr ;
 Expr ::= [cond] Expr CondMid Expr ;
 Expr ::= [assignMinus] LHS "-=" Expr ;
 Expr ::= [assignExcOr] LHS "^=" Expr ;
 Expr ::= [assignPlus] LHS "+=" Expr ;
 Expr ::= [assignURightShift] LHS ">>>=" Expr ;
 Expr ::= [assignAnd] LHS "&=" Expr ;
 Expr ::= [assignDiv] LHS "/=" Expr ;
 Expr ::= [assignMul] LHS "*=" Expr ;
 Expr ::= [assignRemain] LHS "%=" Expr ;
 Expr ::= [assignLeftShift] LHS "<<=" Expr ;
 Expr ::= [assignRightShift] LHS ">>=" Expr ;
 Expr ::= [assignOr] LHS "|=" Expr ;
 Expr ::= [assign] LHS "=" Expr ;
 Expr ::= [qNewInstance] Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? ;
 Expr ::= [lit] Literal ;
 Expr ::= [newInstance] "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? ;
 Expr ::= [exprName] ExprName ;
 Expr ::= ArrayCreationExpr ;
 Expr ::= "(" Expr ")" ;
 Expr ::= ε ;
 Expr ::= [invoke] MethodSpec "(" {Expr ","}* ")" ;
EnumBody ::= [enumBody] "{" {EnumConst ","}* EnumBodyDecs? "}" ;
 EnumBody ::= [enumBody] "{" {EnumConst ","}* "," EnumBodyDecs? "}" ;
ElemVal ::= [elemValArrayInit] "{" {ElemVal ","}* "}" ;
 ElemVal ::= Expr ;
 ElemVal ::= Anno ;
 ElemVal ::= [elemValArrayInit] "{" {ElemVal ","}* "," "}" ;
ConstrInv ::= [qSuperConstrInv] Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" ;
 ConstrInv ::= [superConstrInv] TypeArgs? "super" "(" {Expr ","}* ")" ";" ;
 ConstrInv ::= [altConstrInv] TypeArgs? "this" "(" {Expr ","}* ")" ";" ;
MethodDecHead ::= [deprMethodDecHead] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ;
 MethodDecHead ::= [methodDecHead] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ;
--------------------modula::dagenais-cordy.bgf--------------------
Selector ::= ("." id) | ("[" Expr ComaExpr* "]") | ("(" {Actual ","}* ")") | "^" ;
ArrayCons ::= {Expr ","}* ComaDotDot? ;
Handler ::= {QualId ","}* ParenthesizedId? "=>" Stmts ;
IdList ::= {id ","}* ;
CallStmt ::= Expr "(" {Actual ","}* ")" ;
RaisesList ::= ("{" {QualId ","}* "}") | "ANY" ;
TCase ::= {Type ","}* ParenthesizedId? "=>" Stmts ;
SetCons ::= {SetElt ","}* ;
ArrayType ::= "ARRAY" {Type ","}* "OF" Type ;
RecordCons ::= {RecordElt ","}* ;
Case ::= {Labels ","}* "=>" Stmts ;
--------------------assembly::delphi.bgf--------------------
asm_unlabeledstm ::= (asm_directive {asm_directive_arg ","}*) | (asm_opcode_prefix? asm_opcode {asm_expr ","}*) ;
--------------------basic::vb6-cordy.bgf--------------------
subroutine_bracketless_params ::= expn {optional_expn ","}* ;
write_statement ::= "write" filenumber "," {print_item ","}* ;
print_statement ::= "print" filenumber "," {print_item ","}* ;
subscript ::= "(" {optional_subscript ","}* ")" ;
input_statement ::= "input" filenumber "," {reference ","}* ;
close_statement ::= "close" {filenumber ","}* ;
property_argument_list ::= "(" {property_argument ","}* ")" ;
erase_statement ::= "erase" {id ","}* ;
array_description ::= "withevents"? "preserve"? id "(" {subscript_expn ","}* ")" as_type? ;
subprogram_argument_description ::= "(" {subprogram_argument ","}* ")" ;
savesetting_statement ::= "savesetting" {expn ","}* ;
primary ::= reference | stringlit | number | hexnumber | octnumber | datelit | returncode | filenumber | (prefix_op primary) | ("(" {expn ","}* ")") ;
--------------------javascript::synytskyy-cordy.bgf--------------------
js_variable_declaration ::= "var" {js_variable_description ","}* ;
js_function_declaration ::= NL "function" id "(" {js_formal_parameter ","}* ")" NL "{" NL IN js_subscope EX "}" NL ;
js_object_literal ::= "{" {js_property_assignment ","}* ","? "}" ;
js_constant_declaration ::= "const" {js_constant_description ","}* ;
js_for_statement ::= ("for" "(" {js_declaration_or_statement_no_nl ","}* ";" js_expn? ";" js_expn? ")" js_statement) | ("for" "each"? "(" js_declaration_or_statement_no_nl "in" js_expn ")" js_statement) ;
js_array_literal ::= "[" {js_array_element ","}* "]" ;
js_function_expn ::= "function" id? "(" {js_formal_parameter ","}* ")" NL "{" NL IN js_subscope EX "}" ;
js_arguments ::= "(" {js_assignment_expn ","}* ")" ;
--------------------pascal::delphi.bgf--------------------
contains_clause ::= "contains" {uses_item ","}* ";" NL ;
case_selector ::= {case_label ","}* colon nested_stm ";"? ;
heritage_list ::= ("(" {qualified_id ","}* ")") | ("helper" "for" id) ;
implements_spec ::= "implements" {qualified_id ","}* ;
array_constant ::= "(" {typed_const ","}* ")" ;
parameter ::= {id ","}* parameter_type? ;
program_file_list ::= "(" {id ","}* ")" ;
exports_section ::= "exports" {exports_entry ","}* ";" NL ;
label_decl ::= "label" {label_id ","}* ";" NL ;
uses_clause ::= "uses" NL IN {uses_item ","}* ";" EX NL ;
array_index_list ::= "[" {array_index ","}* "]" ;
requires_clause ::= "requires" {qualified_id ","}* ";" NL ;
--------------------pascal::delphipp.bgf--------------------
pp_directivestmt ::= ("{$" space? {pp_directive ","}* bracketbody* "}") | ("(*$" space? {pp_directive ","}* starbody* "*)") ;
pp_directive ::= ("DEFINE" space id) | ("UNDEF" space id) | ("INCLUDE" space? filenamelit) | ("I" space? filenamelit) | ("LINK" space? filenamelit) | ("L" space? filenamelit) | ("RESOURCE" space? filenamelit space? filenamelit?) | ("R" space? filenamelit space? filenamelit?) | ("HPPEMIT" space? charlit) | ("EXTERNALSYM" space id) | "NODEFINE" | "MINENUMSIZE" | "DENYPACKAGEUNIT" | "WEAKPACKAGEUNIT" | ("IMAGEBASE" space? anynumber) | ("C" space id) | ("MINENUMSIZE" space anynumber) | pp_minenumsize | ("ALIGN" space? anynumber) | pp_align | ("M" space? {anynumber ","}*) | ("MAXSTACKSIZE" space anynumber) | ("MINSTACKSIZE" space anynumber) | ("RESOURCERESERVE" space anynumber) | "NOINCLUDE" | "WARN" | "MESSAGE" | "APPTYPE" | ("LIBPREFIX" space? charlit) | ("LIBSUFIX" space? charlit) | ("LIBVERSION" space? charlit) | ("DESCRIPTION" space? charlit) | ("D" space? charlit) | ("EXTENSION" space id) | ("E" space id) | (pp_switch space?) ;
--------------------pascal::object.bgf--------------------
set_constructor ::= "[" {set_element ","}* "]" ;
enumeratedType ::= "(" {decl_name ","}* ")" ;
array_constant ::= "(" {typed_constant ","}* ")" ;
parameter ::= {decl_name ","}* parameter_type? ;
square_ordinalType ::= "[" {ordinalType ","}* "]" ;
arguments ::= "(" {expression ","}* ")" ;
class_heritage ::= "(" {ref_name ","}* ")" ;
program_file_list ::= "(" {id ","}* ")" ;
array_subscript ::= "[" {expression ","}* "]" ;
interface_heritage ::= "(" {ref_name ","}* ")" ;
--------------------php::cordy.bgf--------------------
List ::= "list" "(" {ListElem ","}* ")" ;
Array ::= "array" "(" IN {ArrayPair ","}* ","? EX ")" ;
ForStatement ::= ("for" "(" {Expr ","}* ";" {Expr ","}* ";" {Expr ","}* ")" NL Statement) | ("for" "(" {Expr ","}* ";" {Expr ","}* ";" {Expr ","}* ")" ":" NL IN Statement* EX "endfor" ";" NL) ;
CallParams ::= "(" {CallParam ","}* ")" ;
InterfaceMember ::= VarModifiers? "function" "&"? id "(" {Param ","}* ")" ";" NL ;
ClassMember ::= (VarModifiers? FunctionDecl) | (VarModifiers? "abstract" VarModifiers? "function" "&"? id "(" {Param ","}* ")" ";" NL) | ("var" {InstanceVariable ","}+ ";" NL) | ("const" id "=" StaticScalar ";" NL) | (VarModifiers {InstanceVariable ","}+ ";" NL) ;
FunctionDecl ::= "function" "&"? id "(" {Param ","}* ")" NL Block ;
--------------------python::sorochan-cordy.bgf--------------------
dictmaker ::= {dict_entry ","}* endofline* ","? endofline* ;
print_stmt ::= "print" ">>"? {test ","}* ","? ;
listmaker ::= (endofline* test endofline* plist_for endofline*) | (endofline* {test ","}* ","? endofline*) ;
arglist ::= star_test? {argument ","}* comma_opt_star_test? ;
testlist1 ::= {test ","}* ;
--------------------markup::csv-rascal-concrete.bgf--------------------
Table ::= [table] {Record EOL}* ;
--------------------markup::json-rascal-concrete.bgf--------------------
Object ::= [Object] "{" members::({Member ","}*) "}" ;
Array ::= [Array] "[" values::({Value ","}*) "]" ;
--------------------markup::json-zaytsev-concrete.bgf--------------------
JSONObject ::= "{" {JSONKeyValue ","}* "}" ;
JSONArray ::= "[" {JSONBasicType ","}* "]" ;
--------------------metasyntax::aterms-rascal.bgf--------------------
ATerm ::= [Appl] AFun "(" {ATerm ","}+ ")" ;
 ATerm ::= [Real] RealCon ;
 ATerm ::= [List] "[" {ATerm ","}* "]" ;
 ATerm ::= [Annotated] ATerm Annotation ;
 ATerm ::= [Placeholder] "<" ATerm ">" ;
 ATerm ::= [Int] IntCon ;
 ATerm ::= [Fun] AFun ;
--------------------metasyntax::box-rascal.bgf--------------------
AlignmentOptions ::= "(" {AlignmentOption ","}* ")" ;
--------------------metasyntax::sdf-rascal.bgf--------------------
ATerm ::= [Real] RealCon ;
 ATerm ::= [Appl] AFun "(" {ATerm ","}+ ")" ;
 ATerm ::= [Annotated] ATerm Annotation ;
 ATerm ::= [Placeholder] "<" ATerm ">" ;
 ATerm ::= [Int] IntCon ;
 ATerm ::= [Fun] AFun ;
 ATerm ::= [List] "[" {ATerm ","}* "]" ;
Priorities ::= {Priority ","}* ;
Attrs ::= [Attrs] "{" {Attribute ","}* "}" ;
 Attrs ::= [NoAttrs] ε ;
Lookaheads ::= [Single] Lookahead ;
 Lookaheads ::= [Alt] Lookaheads "|" Lookaheads ;
 Lookaheads ::= [List] "[[" {Lookahead ","}* "]]" ;
 Lookaheads ::= [Bracket] "(" Lookaheads ")" ;
--------------------pico::rascal.bgf--------------------
Statement ::= [cond] "if" cond::Expression "then" thenPart::({Statement ";"}*) "else" elsePart::({Statement ";"}*) "fi" ;
 Statement ::= [assign] var::Id ":=" val::Expression ;
 Statement ::= [cond] "if" cond::Expression "then" thenPart::({Statement ";"}*) "fi" ;
 Statement ::= [loop] "while" cond::Expression "do" body::({Statement ";"}*) "od" ;
Declarations ::= "declare" decls::({IdType ","}*) ";" ;
Program ::= [program] "begin" decls::Declarations body::({Statement ";"}*) "end" ;
