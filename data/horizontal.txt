--------------------ada::kellogg.bgf--------------------
discrete_subtype_definition ::= range | subtype_ind ;
subprogram_body ::= (p::PROCEDURE def_id formal_part_opt IS body_part SEMI) | (f::FUNCTION function_tail IS body_part SEMI) ;
range ::= range_dots | range_attrib_ref ;
enumeration_literal_specification ::= IDENTIFIER | CHARACTER_LITERAL ;
entry_index_opt ::= (LPAREN expression) | ε ;
derived_or_private_or_record ::= (abstract_opt NEW subtype_ind WITH) | (NEW subtype_ind) | (abstract_tagged_limited_opt PRIVATE | record_definition) ;
discrete_range ::= range | subtype_ind ;
basic_decl_item ::= (pkg::PACKAGE def_id spec_decl_part) | (tsk::TASK task_type_or_single_decl) | (pro::PROTECTED prot_type_or_single_decl SEMI) | subprog_decl | decl_common ;
prot_type_or_single_decl ::= (TYPE def_id discrim_part_opt protected_definition) | (def_id protected_definition) ;
value ::= (OTHERS RIGHT_SHAFT expression) | (ranged_expr_s (RIGHT_SHAFT expression)?) ;
prot_op_decl ::= entry_declaration | (p::PROCEDURE def_id formal_part_opt SEMI) | (f::FUNCTION def_designator function_tail SEMI) | rep_spec | pragma ;
signed_term ::= (p::PLUS term) | (m::MINUS term) | term ;
subprog_decl ::= (p::PROCEDURE def_id generic_subp_inst | (formal_part_opt renames | is_separate_or_abstract_or_decl SEMI)) | (f::FUNCTION def_designator generic_subp_inst | (function_tail renames | is_separate_or_abstract_or_decl SEMI)) ;
subprog_decl_or_body ::= (p::PROCEDURE def_id formal_part_opt (IS body_part) | ε SEMI) | (f::FUNCTION def_designator function_tail (IS body_part) | ε SEMI) ;
discrete_subtype_def_opt ::= (LPAREN discrete_subtype_definition) | ε ;
subprog_decl_or_rename_or_inst_or_body ::= (p::PROCEDURE def_id generic_subp_inst | (formal_part_opt renames | (IS separate_or_abstract | body_part) | ε SEMI)) | (f::FUNCTION def_designator generic_subp_inst | (function_tail renames | (IS separate_or_abstract | body_part) | ε SEMI)) ;
select_alternative ::= accept_alternative | delay_alternative | (t::TERMINATE SEMI) ;
entry_index_spec_opt ::= (LPAREN FOR def_id IN discrete_subtype_definition) | ε ;
declarative_item ::= (pkg::PACKAGE (body_is separate | (pkg_body_part end_id_opt) SEMI) | (def_id spec_decl_part)) | (tsk::TASK (body_is separate | body_part SEMI) | task_type_or_single_decl) | (pro::PROTECTED (body_is separate | (prot_op_bodies_opt end_id_opt)) | prot_type_or_single_decl SEMI) | subprog_decl_or_rename_or_inst_or_body | decl_common ;
range_or_mark ::= range | subtype_mark ;
separate_or_abstract ::= SEPARATE | ABSTRACT ;
choice ::= OTHERS | discrete_with_range | expression ;
component_list ::= (NuLL SEMI) | (component_items variant_part?) | (empty_component_items variant_part) ;
decl_common ::= (t::TYPE IDENTIFIER (IS type_def) | (discrim_part (IS derived_or_private_or_record) | ε) | empty_discrim_opt SEMI) | (s::SUBTYPE IDENTIFIER IS subtype_ind SEMI) | generic_decl | use_clause | (r::FOR (local_enum_name USE) | (subtype_mark USE rep_spec_part) SEMI) | (IDENTIFIER erd::COLON EXCEPTION RENAMES compound_name) | (IDENTIFIER ord::COLON subtype_mark RENAMES name) | (defining_identifier_list od::COLON EXCEPTION | (CONSTANT ASSIGN) | (aliased_constant_opt (array_type_definition init_opt) | (subtype_ind init_opt)) SEMI) ;
is_separate_or_abstract_or_decl ::= (IS separate_or_abstract) | ε ;
attribute_id ::= RANGE | DIGITS | DELTA | ACCESS | IDENTIFIER ;
selector_names_opt ::= association_head | ε ;
discriminable_type_definition ::= (abstract_opt NEW subtype_ind WITH) | (NEW subtype_ind) | (abstract_tagged_limited_opt PRIVATE) ;
rep_spec_part ::= (RECORD align_opt comp_loc_s END RECORD) | (AT expression) | expression ;
def_id ::= (cn::compound_name) | (n::IDENTIFIER) ;
designator ::= (op::definable_operator_symbol) | (n::IDENTIFIER) ;
exception_choice ::= compound_name | OTHERS ;
task_type_or_single_decl ::= (TYPE def_id discrim_part_opt task_definition_opt) | (def_id task_definition_opt) ;
factor ::= (NOT primary) | (ABS primary) | (primary (EXPON primary)?) ;
id_opt ::= (endid::definable_operator_symbol) | (n::compound_name) | ε ;
def_designator ::= (n::compound_name) | (d::designator) ;
DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
discrete_with_range ::= mark_with_constraint | range ;
EXTENDED_DIGIT ::= DIGIT | "a" | "b" | "c" | "d" | "e" | "f" ;
WS_ ::= " " | "\t" | "\f" | "\r\n" | "\r" | "\n" ;
primary ::= name_or_qualified | parenthesized_primary | allocator | NuLL | NUMERIC_LIT | CHARACTER_LITERAL | (cs::CHAR_STRING operator_call_tail?) ;
record_definition ::= (RECORD component_list END RECORD) | (NuLL RECORD) ;
task_definition_opt ::= (IS task_items_opt private_task_items_opt end_id_opt SEMI) | SEMI ;
type_def ::= (LPAREN enum_id_s RPAREN) | (RANGE range) | (MOD expression) | (DIGITS expression range_constraint_opt) | (DELTA expression (RANGE range) | (DIGITS expression range_constraint_opt)) | array_type_definition | access_type_definition | (empty_discrim_opt derived_or_private_or_record) ;
--------------------ada::kempe.bgf--------------------
numeric_literal ::= decimal_literal | based_literal ;
generic_formal_parameter_declaration ::= formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
defining_designator ::= defining_program_unit_name | defining_operator_symbol ;
general_access_modifier ::= "all" | "constant" ;
enumeration_literal_specification ::= defining_identifier | defining_character_literal ;
object_declaration ::= (defining_identifier_list ":" "aliased"? "constant"? subtype_indication (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? array_type_definition (":=" expression)? ";") | single_task_declaration | single_protected_declaration ;
library_unit_body ::= subprogram_body | package_body ;
attribute_definition_clause ::= ("for" local_name "'" attribute_designator "use" expression ";") | ("for" local_name "'" attribute_designator "use" name ";") ;
type_definition ::= enumeration_type_definition | integer_type_definition | real_type_definition | array_type_definition | record_type_definition | access_type_definition | derived_type_definition ;
discrete_range ::= discrete_subtype_indication | range ;
integer_type_definition ::= signed_integer_type_definition | modular_type_definition ;
type_declaration ::= full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration ;
unary_adding_operator ::= "+" | "-" ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
parameter_specification ::= (defining_identifier_list ":" mode subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
select_statement ::= selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select ;
selector_name ::= identifier | character_literal | operator_symbol ;
select_alternative ::= accept_alternative | delay_alternative | terminate_alternative ;
basic_declaration ::= type_declaration | subtype_declaration | object_declaration | number_declaration | subprogram_declaration | abstract_subprogram_declaration | package_declaration | renaming_declaration | exception_declaration | generic_declaration | generic_instantiation ;
declarative_item ::= basic_declarative_item | body ;
generic_instantiation ::= ("package" defining_program_unit_name "is" "new" generic_package_name generic_actual_part? ";") | ("procedure" defining_program_unit_name "is" "new" generic_procedure_name generic_actual_part? ";") | ("function" defining_designator "is" "new" generic_function_name generic_actual_part? ";") ;
function_call ::= function_name | (function_prefix actual_parameter_part) ;
access_to_subprogram_definition ::= ("access" "protected"? "procedure" parameter_profile) | ("access" "protected"? "function" parameter_and_result_profile) ;
explicit_actual_parameter ::= expression | variable_name ;
local_name ::= direct_name | (direct_name "'" attribute_designator) | library_unit_name ;
ancestor_part ::= expression | subtype_mark ;
constraint ::= scalar_constraint | composite_constraint ;
compound_statement ::= if_statement | case_statement | loop_statement | block_statement | accept_statement | select_statement ;
array_aggregate ::= positional_array_aggregate | named_array_aggregate ;
basic_declarative_item ::= basic_declaration | representation_clause | use_clause ;
real_type_definition ::= floating_point_definition | fixed_point_definition ;
protected_operation_declaration ::= subprogram_declaration | entry_declaration | representation_clause ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
string_element ::= """" | non_quotation_mark_graphic_character ;
fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" expression) ;
record_component_association_list ::= (record_component_association ("," record_component_association)*) | ("null" "record") ;
explicit_generic_actual_parameter ::= expression | variable_name | subprogram_name | entry_name | subtype_mark | package_instance_name ;
letter_or_digit ::= identifier_letter | digit ;
subprogram_specification ::= ("procedure" defining_program_unit_name parameter_profile) | ("function" defining_designator parameter_and_result_profile) ;
iteration_scheme ::= ("while" condition) | ("for" loop_parameter_specification) ;
subprogram_default ::= default_name | "<>" ;
binary_adding_operator ::= "+" | "-" | "&" ;
library_unit_declaration ::= subprogram_declaration | package_declaration | generic_declaration | generic_instantiation ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
discrete_subtype_definition ::= discrete_subtype_indication | "range" ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
relational_operator ::= "=" | "/=" | "<" | "<=" | ">" | ">=" ;
formal_package_actual_part ::= "(<>)" | (generic_actual_part?) ;
type_conversion ::= (subtype_mark "(" expression ")") | (subtype_mark "(" name ")") ;
procedure_call_statement ::= (procedure_name ";") | (procedure_prefix actual_parameter_part ";") ;
component_choice_list ::= (component_selector_name ("|" component_selector_name)*) | "others" ;
renaming_declaration ::= object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration ;
delay_statement ::= delay_until_statement | delay_relative_statement ;
proper_body ::= subprogram_body | package_body | task_body | protected_body ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
positional_array_aggregate ::= ("(" expression "," expression ("," expression)* ")") | ("(" expression ("," expression)* "," "others" "=>" expression ")") ;
body_stub ::= subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;
character ::= graphic_character | format_effector | other_control_function ;
formal_type_definition ::= formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition ;
use_clause ::= use_package_clause | use_type_clause ;
discrete_choice ::= expression | discrete_range | "others" ;
extended_digit ::= digit | "A" | "B" | "C" | "D" | "E" | "F" ;
protected_element_declaration ::= protected_operation_declaration | component_declaration ;
discriminant_specification ::= (defining_identifier_list ":" subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
full_type_declaration ::= ("type" defining_identifier known_discriminant_part? "is" type_definition ";") | task_type_declaration | protected_type_declaration ;
context_item ::= with_clause | use_clause ;
mode ::= ("in"?) | ("in" "out") | "out" ;
simple_statement ::= null_statement | assignment_statement | exit_statement | goto_statement | procedure_call_statement | return_statement | entry_call_statement | requeue_statement | delay_statement | abort_statement | raise_statement | code_statement ;
body ::= proper_body | body_stub ;
pragma_argument_association ::= ((pragma_argument_identifier "=>")? name) | ((pragma_argument_identifier "=>")? expression) ;
representation_clause ::= attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause ;
direct_name ::= identifier | operator_symbol ;
component_list ::= (component_item component_item*) | (component_item* variant_part) | ("null" ";") ;
generic_renaming_declaration ::= ("generic" "package" defining_program_unit_name "renames" generic_package_name ";") | ("generic" "procedure" defining_program_unit_name "renames" generic_procedure_name ";") | ("generic" "function" defining_program_unit_name "renames" generic_function_name ";") ;
highest_precedence_operator ::= "**" | "abs" | "not" ;
access_type_definition ::= access_to_object_definition | access_to_subprogram_definition ;
protected_operation_item ::= subprogram_declaration | subprogram_body | entry_body | representation_clause ;
qualified_expression ::= (subtype_mark "'(" expression ")") | (subtype_mark "'" aggregate) ;
triggering_statement ::= entry_call_statement | delay_statement ;
logical_operator ::= "and" | "or" | "xor" ;
expression ::= (relation ("and" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" relation)*) | (relation ("or" "else" relation)*) | (relation ("xor" relation)*) ;
library_item ::= ("private"? library_unit_declaration) | library_unit_body | ("private"? library_unit_renaming_declaration) ;
attribute_designator ::= (identifier ("(" static_expression ")")?) | "Access" | "Delta" | "Digits" ;
composite_constraint ::= index_constraint | discriminant_constraint ;
component_item ::= component_declaration | representation_clause ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
generic_declaration ::= generic_subprogram_declaration | generic_package_declaration ;
prefix ::= name | implicit_dereference ;
array_type_definition ::= unconstrained_array_definition | constrained_array_definition ;
graphic_character ::= identifier_letter | digit | space_character | special_character ;
exception_choice ::= exception_name | "others" ;
discriminant_part ::= unknown_discriminant_part | known_discriminant_part ;
scalar_constraint ::= range_constraint | digits_constraint | delta_constraint ;
library_unit_renaming_declaration ::= package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration ;
task_item ::= entry_declaration | representation_clause ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | explicit_dereference | indexed_component | slice | selected_component | attribute_reference | type_conversion | function_call | character_literal ;
multiplying_operator ::= "*" | "/" | "mod" | "rem" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
record_definition ::= ("record" component_list "end" "record") | ("null" "record") ;
compilation_unit ::= (context_clause library_item) | (context_clause subunit) ;
--------------------ada::laemmel-verhoef.bgf--------------------
generic_formal_parameter_declaration ::= formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range_definition) | (simple_expression "not"? "in" subtype_mark) ;
defining_designator ::= defining_program_unit_name | defining_operator_symbol ;
general_access_modifier ::= "all" | "constant" ;
enumeration_literal_specification ::= defining_identifier | defining_character_literal ;
object_declaration ::= (defining_identifier_list ":" "aliased"? "constant"? subtype_indication (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? array_type_definition (":=" expression)? ";") | single_task_declaration | single_protected_declaration ;
library_unit_body ::= subprogram_body | package_body ;
attribute_definition_clause ::= ("for" local_name "'" attribute_designator "use" expression ";") | ("for" local_name "'" attribute_designator "use" name ";") ;
type_definition ::= enumeration_type_definition | integer_type_definition | real_type_definition | array_type_definition | record_type_definition | access_type_definition | derived_type_definition ;
discrete_range ::= discrete_subtype_indication | range_definition ;
integer_type_definition ::= signed_integer_type_definition | modular_type_definition ;
type_declaration ::= full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration ;
unary_adding_operator ::= "+" | "-" ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
parameter_specification ::= (defining_identifier_list ":" mode subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
select_statement ::= selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select ;
selector_name ::= identifier | character_literal | operator_symbol ;
select_alternative ::= accept_alternative | delay_alternative | terminate_alternative ;
basic_declaration ::= type_declaration | subtype_declaration | object_declaration | number_declaration | subprogram_declaration | abstract_subprogram_declaration | package_declaration | renaming_declaration | exception_declaration | generic_declaration | generic_instantiation ;
declarative_item ::= basic_declarative_item | body ;
generic_instantiation ::= ("package" defining_program_unit_name "is" "new" generic_package_name generic_actual_part? ";") | ("procedure" defining_program_unit_name "is" "new" generic_procedure_name generic_actual_part? ";") | ("function" defining_designator "is" "new" generic_function_name generic_actual_part? ";") ;
access_to_subprogram_definition ::= ("access" "protected"? "procedure" parameter_profile) | ("access" "protected"? "function" parameter_and_result_profile) ;
function_call ::= function_name | (function_prefix actual_parameter_part) ;
explicit_actual_parameter ::= expression | variable_name ;
local_name ::= direct_name | (direct_name "'" attribute_designator) | library_unit_name ;
ancestor_part ::= expression | subtype_mark ;
constraint ::= scalar_constraint | composite_constraint ;
compound_statement ::= if_statement | case_statement | loop_statement | block_statement | accept_statement | select_statement ;
array_aggregate ::= positional_array_aggregate | named_array_aggregate ;
basic_declarative_item ::= basic_declaration | representation_clause | use_clause ;
real_type_definition ::= floating_point_definition | fixed_point_definition ;
protected_operation_declaration ::= subprogram_declaration | entry_declaration | representation_clause ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" expression) ;
record_component_association_list ::= (record_component_association ("," record_component_association)*) | ("null" "record") ;
explicit_generic_actual_parameter ::= expression | variable_name | subprogram_name | entry_name | subtype_mark | package_instance_name ;
subprogram_specification ::= ("procedure" defining_program_unit_name parameter_profile) | ("function" defining_designator parameter_and_result_profile) ;
iteration_scheme ::= ("while" condition) | ("for" loop_parameter_specification) ;
subprogram_default ::= default_name | "<>" ;
binary_adding_operator ::= "+" | "-" | "&" ;
library_unit_declaration ::= subprogram_declaration | package_declaration | generic_declaration | generic_instantiation ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
discrete_subtype_definition ::= discrete_subtype_indication | "range" ;
relational_operator ::= "=" | "/=" | "<" | "<=" | ">" | ">=" ;
formal_package_actual_part ::= ("(" "<>" ")") | (generic_actual_part?) ;
type_conversion ::= (subtype_mark "(" expression ")") | (subtype_mark "(" name ")") ;
component_choice_list ::= (component_selector_name ("|" component_selector_name)*) | "others" ;
procedure_call_statement ::= (procedure_name ";") | (procedure_prefix actual_parameter_part ";") ;
renaming_declaration ::= object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration ;
delay_statement ::= delay_until_statement | delay_relative_statement ;
proper_body ::= subprogram_body | package_body | task_body | protected_body ;
positional_array_aggregate ::= ("(" expression "," expression ("," expression)* ")") | ("(" expression ("," expression)* "," "others" "=>" expression ")") ;
body_stub ::= subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;
formal_type_definition ::= formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition ;
use_clause ::= use_package_clause | use_type_clause ;
discrete_choice ::= expression | discrete_range | "others" ;
protected_element_declaration ::= protected_operation_declaration | component_declaration ;
discriminant_specification ::= (defining_identifier_list ":" subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
full_type_declaration ::= ("type" defining_identifier known_discriminant_part? "is" type_definition ";") | task_type_declaration | protected_type_declaration ;
context_item ::= with_clause | use_clause ;
mode ::= ("in"?) | ("in" "out") | "out" ;
simple_statement ::= null_statement | assignment_statement | exit_statement | goto_statement | procedure_call_statement | return_statement | entry_call_statement | requeue_statement | delay_statement | abort_statement | raise_statement | code_statement ;
body ::= proper_body | body_stub ;
pragma_argument_association ::= ((pragma_argument_identifier "=>")? name) | ((pragma_argument_identifier "=>")? expression) ;
representation_clause ::= attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause ;
direct_name ::= identifier | operator_symbol ;
component_list ::= (component_item component_item*) | (component_item* variant_part) | ("null" ";") ;
generic_renaming_declaration ::= ("generic" "package" defining_program_unit_name "renames" generic_package_name ";") | ("generic" "procedure" defining_program_unit_name "renames" generic_procedure_name ";") | ("generic" "function" defining_program_unit_name "renames" generic_function_name ";") ;
highest_precedence_operator ::= "**" | "abs" | "not" ;
access_type_definition ::= access_to_object_definition | access_to_subprogram_definition ;
protected_operation_item ::= subprogram_declaration | subprogram_body | entry_body | representation_clause ;
qualified_expression ::= (subtype_mark "'" "(" expression ")") | (subtype_mark "'" aggregate) ;
triggering_statement ::= entry_call_statement | delay_statement ;
logical_operator ::= "and" | "or" | "xor" ;
expression ::= (relation ("and" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" relation)*) | (relation ("or" "else" relation)*) | (relation ("xor" relation)*) ;
library_item ::= ("private"? library_unit_declaration) | library_unit_body | ("private"? library_unit_renaming_declaration) ;
attribute_designator ::= (identifier ("(" static_expression ")")?) | "Access" | "Delta" | "Digits" ;
range_definition ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
composite_constraint ::= index_constraint | discriminant_constraint ;
component_item ::= component_declaration | representation_clause ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
generic_declaration ::= generic_subprogram_declaration | generic_package_declaration ;
prefix ::= name | implicit_dereference ;
array_type_definition ::= unconstrained_array_definition | constrained_array_definition ;
exception_choice ::= exception_name | "others" ;
discriminant_part ::= unknown_discriminant_part | known_discriminant_part ;
scalar_constraint ::= range_constraint | digits_constraint | delta_constraint ;
library_unit_renaming_declaration ::= package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration ;
task_item ::= entry_declaration | representation_clause ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | explicit_dereference | indexed_component | slice | selected_component | attribute_reference | type_conversion | function_call | character_literal ;
multiplying_operator ::= "*" | "/" | "mod" | "rem" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
record_definition ::= ("record" component_list "end" "record") | ("null" "record") ;
compilation_unit ::= (context_clause library_item) | (context_clause subunit) ;
--------------------ada::lncs-2219.bgf--------------------
numeric_literal ::= decimal_literal | based_literal ;
generic_formal_parameter_declaration ::= formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
defining_designator ::= defining_program_unit_name | defining_operator_symbol ;
general_access_modifier ::= "all" | "constant" ;
enumeration_literal_specification ::= defining_identifier | defining_character_literal ;
object_declaration ::= (defining_identifier_list ":" "aliased"? "constant"? subtype_indication (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? array_type_definition (":=" expression)? ";") | single_task_declaration | single_protected_declaration ;
library_unit_body ::= subprogram_body | package_body ;
attribute_definition_clause ::= ("for" local_name "'" attribute_designator "use" expression ";") | ("for" local_name "'" attribute_designator "use" name ";") ;
type_definition ::= enumeration_type_definition | real_type_definition | record_type_definition | derived_type_definition | integer_type_definition | array_type_definition | access_type_definition ;
discrete_range ::= discrete_subtype_indication | range ;
integer_type_definition ::= signed_integer_type_definition | modular_type_definition ;
type_declaration ::= full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration ;
unary_adding_operator ::= "+" | "-" ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
parameter_specification ::= (defining_identifier_list ":" mode subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
select_statement ::= selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select ;
selector_name ::= identifier | character_literal | operator_symbol ;
select_alternative ::= accept_alternative | delay_alternative | terminate_alternative ;
basic_declaration ::= type_declaration | object_declaration | subprogram_declaration | package_declaration | exception_declaration | generic_instantiation | subtype_declaration | number_declaration | abstract_subprogram_declaration | renaming_declaration | generic_declaration ;
declarative_item ::= basic_declarative_item | body ;
generic_instantiation ::= ("package" defining_program_unit_name "is" "new" generic_package_name generic_actual_part? ";") | ("procedure" defining_program_unit_name "is" "new" generic_procedure_name generic_actual_part? ";") | ("function" defining_designator "is" "new" generic_function_name generic_actual_part? ";") ;
function_call ::= function_name | (function_prefix actual_parameter_part) ;
access_to_subprogram_definition ::= ("access" "protected"? "procedure" parameter_profile) | ("access" "protected"? "function" parameter_and_result_profile) ;
explicit_actual_parameter ::= expression | variable_name ;
local_name ::= direct_name | (direct_name "'" attribute_designator) | library_unit_name ;
ancestor_part ::= expression | subtype_mark ;
constraint ::= scalar_constraint | composite_constraint ;
compound_statement ::= if_statement | loop_statement | accept_statement | case_statement | block_statement | select_statement ;
array_aggregate ::= positional_array_aggregate | named_array_aggregate ;
basic_declarative_item ::= basic_declaration | aspect_clause | use_clause ;
real_type_definition ::= floating_point_definition | fixed_point_definition ;
protected_operation_declaration ::= subprogram_declaration | entry_declaration | aspect_clause ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
string_element ::= """" | non_quotation_mark_graphic_character ;
fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" expression) ;
record_component_association_list ::= (record_component_association ("," record_component_association)*) | ("null" "record") ;
explicit_generic_actual_parameter ::= expression | variable_name | subprogram_name | entry_name | subtype_mark | package_instance_name ;
letter_or_digit ::= identifier_letter | digit ;
subprogram_specification ::= ("procedure" defining_program_unit_name parameter_profile) | ("function" defining_designator parameter_and_result_profile) ;
iteration_scheme ::= ("while" condition) | ("for" loop_parameter_specification) ;
subprogram_default ::= default_name | "<>" ;
binary_adding_operator ::= "+" | "-" | "&" ;
library_unit_declaration ::= subprogram_declaration | package_declaration | generic_declaration | generic_instantiation ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
discrete_subtype_definition ::= discrete_subtype_indication | range ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
relational_operator ::= "=" | "/=" | "<" | "<=" | ">" | ">=" ;
formal_package_actual_part ::= "(<>)" | (generic_actual_part?) ;
type_conversion ::= (subtype_mark "(" expression ")") | (subtype_mark "(" name ")") ;
procedure_call_statement ::= (procedure_name ";") | (procedure_prefix actual_parameter_part ";") ;
component_choice_list ::= (component_selector_name ("|" component_selector_name)*) | "others" ;
aspect_clause ::= attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause ;
renaming_declaration ::= object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration ;
delay_statement ::= delay_until_statement | delay_relative_statement ;
proper_body ::= subprogram_body | package_body | task_body | protected_body ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
positional_array_aggregate ::= ("(" expression "," expression ("," expression)* ")") | ("(" expression ("," expression)* "," "others" "=>" expression ")") ;
body_stub ::= subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;
character ::= graphic_character | format_effector | other_control_function ;
formal_type_definition ::= formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition ;
use_clause ::= use_package_clause | use_type_clause ;
discrete_choice ::= expression | discrete_range | "others" ;
extended_digit ::= digit | "A" | "B" | "C" | "D" | "E" | "F" ;
protected_element_declaration ::= protected_operation_declaration | component_declaration ;
discriminant_specification ::= (defining_identifier_list ":" subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
full_type_declaration ::= ("type" defining_identifier known_discriminant_part? "is" type_definition ";") | task_type_declaration | protected_type_declaration ;
context_item ::= with_clause | use_clause ;
mode ::= ("in"?) | ("in" "out") | "out" ;
simple_statement ::= null_statement | assignment_statement | goto_statement | return_statement | requeue_statement | abort_statement | code_statement | exit_statement | procedure_call_statement | entry_call_statement | delay_statement | raise_statement ;
body ::= proper_body | body_stub ;
pragma_argument_association ::= ((pragma_argument_identifier "=>")? name) | ((pragma_argument_identifier "=>")? expression) ;
direct_name ::= identifier | operator_symbol ;
component_list ::= (component_item component_item*) | (component_item* variant_part) | ("null" ";") ;
generic_renaming_declaration ::= ("generic" "package" defining_program_unit_name "renames" generic_package_name ";") | ("generic" "procedure" defining_program_unit_name "renames" generic_procedure_name ";") | ("generic" "function" defining_program_unit_name "renames" generic_function_name ";") ;
highest_precedence_operator ::= "**" | "abs" | "not" ;
access_type_definition ::= access_to_object_definition | access_to_subprogram_definition ;
protected_operation_item ::= subprogram_declaration | subprogram_body | entry_body | aspect_clause ;
qualified_expression ::= (subtype_mark "'(" expression ")") | (subtype_mark "'" aggregate) ;
triggering_statement ::= entry_call_statement | delay_statement ;
logical_operator ::= "and" | "or" | "xor" ;
expression ::= (relation ("and" relation)*) | (relation ("or" relation)*) | (relation ("xor" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" "else" relation)*) ;
library_item ::= ("private"? library_unit_declaration) | library_unit_body | ("private"? library_unit_renaming_declaration) ;
attribute_designator ::= (identifier ("(" static_expression ")")?) | "Access" | "Delta" | "Digits" ;
composite_constraint ::= index_constraint | discriminant_constraint ;
component_item ::= component_declaration | aspect_clause ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
generic_declaration ::= generic_subprogram_declaration | generic_package_declaration ;
prefix ::= name | implicit_dereference ;
array_type_definition ::= unconstrained_array_definition | constrained_array_definition ;
graphic_character ::= identifier_letter | digit | space_character | special_character ;
exception_choice ::= exception_name | "others" ;
discriminant_part ::= unknown_discriminant_part | known_discriminant_part ;
scalar_constraint ::= range_constraint | digits_constraint | delta_constraint ;
library_unit_renaming_declaration ::= package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration ;
task_item ::= entry_declaration | aspect_clause ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | indexed_component | selected_component | type_conversion | character_literal | explicit_dereference | slice | attribute_reference | function_call ;
multiplying_operator ::= "*" | "/" | "mod" | "rem" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
record_definition ::= ("record" component_list "end" "record") | ("null" "record") ;
compilation_unit ::= (context_clause library_item) | (context_clause subunit) ;
--------------------ada::lncs-4348.bgf--------------------
numeric_literal ::= decimal_literal | based_literal ;
generic_formal_parameter_declaration ::= formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration ;
relation ::= (simple_expression (relational_operator simple_expression)?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
procedure_or_entry_call ::= procedure_call_statement | entry_call_statement ;
defining_designator ::= defining_program_unit_name | defining_operator_symbol ;
general_access_modifier ::= "all" | "constant" ;
enumeration_literal_specification ::= defining_identifier | defining_character_literal ;
object_declaration ::= (defining_identifier_list ":" "aliased"? "constant"? subtype_indication (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? access_definition (":=" expression)? ";") | (defining_identifier_list ":" "aliased"? "constant"? array_type_definition (":=" expression)? ";") | single_task_declaration | single_protected_declaration ;
library_unit_body ::= subprogram_body | package_body ;
attribute_definition_clause ::= ("for" local_name "'" attribute_designator "use" expression ";") | ("for" local_name "'" attribute_designator "use" name ";") ;
type_definition ::= enumeration_type_definition | real_type_definition | record_type_definition | derived_type_definition | integer_type_definition | array_type_definition | access_type_definition | interface_type_definition ;
discrete_range ::= discrete_subtype_indication | range ;
integer_type_definition ::= signed_integer_type_definition | modular_type_definition ;
type_declaration ::= full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration ;
unary_adding_operator ::= "+" | "-" ;
identifier_extend ::= mark_non_spacing | mark_spacing_combining | number_decimal | punctuation_connector | other_format ;
statement ::= (label* simple_statement) | (label* compound_statement) ;
parameter_specification ::= (defining_identifier_list ":" mode null_exclusion? subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
select_statement ::= selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select ;
selector_name ::= identifier | character_literal | operator_symbol ;
select_alternative ::= accept_alternative | delay_alternative | terminate_alternative ;
basic_declaration ::= type_declaration | object_declaration | subprogram_declaration | null_procedure_declaration | renaming_declaration | generic_declaration | subtype_declaration | number_declaration | abstract_subprogram_declaration | package_declaration | exception_declaration | generic_instantiation ;
declarative_item ::= basic_declarative_item | body ;
restriction_parameter_argument ::= name | expression ;
generic_instantiation ::= ("package" defining_program_unit_name "is" "new" generic_package_name generic_actual_part? ";") | (overriding_indicator? "procedure" defining_program_unit_name "is" "new" generic_procedure_name generic_actual_part? ";") | (overriding_indicator? "function" defining_designator "is" "new" generic_function_name generic_actual_part? ";") ;
function_call ::= function_name | (function_prefix actual_parameter_part) ;
access_to_subprogram_definition ::= ("access" "protected"? "procedure" parameter_profile) | ("access" "protected"? "function" parameter_and_result_profile) ;
explicit_actual_parameter ::= expression | variable_name ;
local_name ::= direct_name | (direct_name "'" attribute_designator) | library_unit_name ;
ancestor_part ::= expression | subtype_mark ;
constraint ::= scalar_constraint | composite_constraint ;
raise_statement ::= ("raise" ";") | ("raise" exception_name ("with" string_expression)? ";") ;
compound_statement ::= if_statement | loop_statement | extended_return_statement | accept_statement | case_statement | block_statement | select_statement ;
array_component_association ::= (discrete_choice_list "=>" expression) | (discrete_choice_list "=><>") ;
array_aggregate ::= positional_array_aggregate | named_array_aggregate ;
basic_declarative_item ::= basic_declaration | aspect_clause | use_clause ;
real_type_definition ::= floating_point_definition | fixed_point_definition ;
component_definition ::= ("aliased"? subtype_indication) | ("aliased"? access_definition) ;
protected_operation_declaration ::= subprogram_declaration | entry_declaration | aspect_clause ;
record_component_association ::= ((component_choice_list "=>")? expression) | (component_choice_list "=><>") ;
formal_subprogram_declaration ::= formal_concrete_subprogram_declaration | formal_abstract_subprogram_declaration ;
factor ::= (primary ("**" primary)?) | ("abs" primary) | ("not" primary) ;
string_element ::= """" | non_quotation_mark_graphic_character ;
fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition ;
restriction ::= restriction_identifier | (restriction_parameter_identifier "=>" restriction_parameter_argument) ;
record_component_association_list ::= (record_component_association ("," record_component_association)*) | ("null" "record") ;
identifier_start ::= letter_uppercase | letter_lowercase | letter_titlecase | letter_modifier | letter_other | number_letter ;
explicit_generic_actual_parameter ::= expression | variable_name | subprogram_name | entry_name | subtype_mark | package_instance_name ;
subprogram_specification ::= procedure_specification | function_specification ;
iteration_scheme ::= ("while" condition) | ("for" loop_parameter_specification) ;
subprogram_default ::= default_name | "<>" | "null" ;
parameter_and_result_profile ::= (formal_part? "return" null_exclusion? subtype_mark) | (formal_part? "return" access_definition) ;
binary_adding_operator ::= "+" | "-" | "&" ;
library_unit_declaration ::= subprogram_declaration | package_declaration | generic_declaration | generic_instantiation ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
discrete_subtype_definition ::= discrete_subtype_indication | range ;
range ::= range_attribute_reference | (simple_expression ".." simple_expression) ;
relational_operator ::= "=" | "/=" | "<" | "<=" | ">" | ">=" ;
formal_package_actual_part ::= ("(" ("others" "=>")? "<>)") | (generic_actual_part?) | ("(" formal_package_association ("," formal_package_association)* ("," "others" "=><>")? ")") ;
type_conversion ::= (subtype_mark "(" expression ")") | (subtype_mark "(" name ")") ;
procedure_call_statement ::= (procedure_name ";") | (procedure_prefix actual_parameter_part ";") ;
component_choice_list ::= (component_selector_name ("|" component_selector_name)*) | "others" ;
formal_package_association ::= generic_association | (generic_formal_parameter_selector_name "=><>") ;
aspect_clause ::= attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause ;
object_renaming_declaration ::= (defining_identifier ":" null_exclusion? subtype_mark "renames" object_name ";") | (defining_identifier ":" access_definition "renames" object_name ";") ;
renaming_declaration ::= object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration ;
delay_statement ::= delay_until_statement | delay_relative_statement ;
proper_body ::= subprogram_body | package_body | task_body | protected_body ;
return_subtype_indication ::= subtype_indication | access_definition ;
exponent ::= ("E" "+"? numeral) | ("E" "-" numeral) ;
positional_array_aggregate ::= ("(" expression "," expression ("," expression)* ")") | ("(" expression ("," expression)* "," "others" "=>" expression ")") | ("(" expression ("," expression)* "," "others" "=><>)") ;
digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
body_stub ::= subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;
formal_type_definition ::= formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition | formal_interface_type_definition ;
use_clause ::= use_package_clause | use_type_clause ;
discrete_choice ::= expression | discrete_range | "others" ;
extended_digit ::= digit | "A" | "B" | "C" | "D" | "E" | "F" ;
protected_element_declaration ::= protected_operation_declaration | component_declaration ;
discriminant_specification ::= (defining_identifier_list ":" null_exclusion? subtype_mark (":=" default_expression)?) | (defining_identifier_list ":" access_definition (":=" default_expression)?) ;
full_type_declaration ::= ("type" defining_identifier known_discriminant_part? "is" type_definition ";") | task_type_declaration | protected_type_declaration ;
context_item ::= with_clause | use_clause ;
mode ::= ("in"?) | ("in" "out") | "out" ;
simple_statement ::= null_statement | assignment_statement | goto_statement | simple_return_statement | requeue_statement | abort_statement | code_statement | exit_statement | procedure_call_statement | entry_call_statement | delay_statement | raise_statement ;
body ::= proper_body | body_stub ;
pragma_argument_association ::= ((pragma_argument_identifier "=>")? name) | ((pragma_argument_identifier "=>")? expression) ;
direct_name ::= identifier | operator_symbol ;
component_list ::= (component_item component_item*) | (component_item* variant_part) | ("null" ";") ;
generic_renaming_declaration ::= ("generic" "package" defining_program_unit_name "renames" generic_package_name ";") | ("generic" "procedure" defining_program_unit_name "renames" generic_procedure_name ";") | ("generic" "function" defining_program_unit_name "renames" generic_function_name ";") ;
highest_precedence_operator ::= "**" | "abs" | "not" ;
access_type_definition ::= (null_exclusion? access_to_object_definition) | (null_exclusion? access_to_subprogram_definition) ;
protected_operation_item ::= subprogram_declaration | subprogram_body | entry_body | aspect_clause ;
qualified_expression ::= (subtype_mark "'(" expression ")") | (subtype_mark "'" aggregate) ;
triggering_statement ::= procedure_or_entry_call | delay_statement ;
logical_operator ::= "and" | "or" | "xor" ;
expression ::= (relation ("and" relation)*) | (relation ("or" relation)*) | (relation ("xor" relation)*) | (relation ("and" "then" relation)*) | (relation ("or" "else" relation)*) ;
library_item ::= ("private"? library_unit_declaration) | library_unit_body | ("private"? library_unit_renaming_declaration) ;
attribute_designator ::= (identifier ("(" static_expression ")")?) | "Access" | "Delta" | "Digits" ;
composite_constraint ::= index_constraint | discriminant_constraint ;
component_item ::= component_declaration | aspect_clause ;
designator ::= ((parent_unit_name ".")? identifier) | operator_symbol ;
generic_declaration ::= generic_subprogram_declaration | generic_package_declaration ;
prefix ::= name | implicit_dereference ;
array_type_definition ::= unconstrained_array_definition | constrained_array_definition ;
exception_choice ::= exception_name | "others" ;
discriminant_part ::= unknown_discriminant_part | known_discriminant_part ;
scalar_constraint ::= range_constraint | digits_constraint | delta_constraint ;
access_definition ::= (null_exclusion? "access" "constant"? subtype_mark) | (null_exclusion? "access" "protected"? "procedure" parameter_profile) | (null_exclusion? "access" "protected"? "function" parameter_and_result_profile) ;
library_unit_renaming_declaration ::= package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration ;
task_item ::= entry_declaration | aspect_clause ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= direct_name | indexed_component | selected_component | type_conversion | character_literal | explicit_dereference | slice | attribute_reference | function_call ;
with_clause ::= limited_with_clause | nonlimited_with_clause ;
multiplying_operator ::= "*" | "/" | "mod" | "rem" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") ;
record_definition ::= ("record" component_list "end" "record") | ("null" "record") ;
compilation_unit ::= (context_clause library_item) | (context_clause subunit) ;
--------------------ada::cordy-hyaric.bgf--------------------
numeric_literal ::= decimal_literal | based_literal ;
generic_formal_parameter_declaration ::= formal_object_declaration | formal_type_declaration | formal_subprogram_declaration | formal_package_declaration ;
relation ::= (simple_expression relational_operator_simple_expression?) | (simple_expression "not"? "in" range) | (simple_expression "not"? "in" subtype_mark) ;
procedure_or_entry_call ::= procedure_call_statement | entry_call_statement ;
defining_designator ::= defining_program_unit_name | defining_operator_symbol ;
general_access_modifier ::= "all" | "constant" ;
enumeration_literal_specification ::= defining_identifier | defining_character_literal ;
object_declaration ::= (defining_identifier_list colon "aliased"? "constant"? subtype_access_or_array_type_definition object_declaration_expression? semi) | single_task_declaration | single_protected_declaration ;
library_unit_body ::= subprogram_body | package_body ;
type_definition ::= enumeration_type_definition | integer_type_definition | real_type_definition | array_type_definition | record_type_definition | access_type_definition | derived_type_definition | interface_type_definition ;
discrete_range ::= subtype_indication | range ;
integer_type_definition ::= signed_integer_type_definition | modular_type_definition ;
type_declaration ::= full_type_declaration | incomplete_type_declaration | private_type_declaration | private_extension_declaration ;
unary_adding_operator ::= "+" | "-" ;
formal_derived_type_definition_modifier ::= "limited" | "synchronized" ;
select_statement ::= selective_accept | timed_entry_call | conditional_entry_call | asynchronous_select ;
subtype_access_or_array_type_definition ::= subtype_indication | access_definition | array_type_definition ;
selector_name ::= identifier | character_literal | operator_symbol ;
select_alternative ::= accept_alternative | delay_alternative | terminate_alternative ;
basic_declaration ::= type_declaration | subtype_declaration | object_declaration | number_declaration | subprogram_declaration | abstract_subprogram_declaration | null_procedure_declaration | package_declaration | renaming_declaration | exception_declaration | generic_declaration | generic_instantiation | pragma ;
declarative_item ::= basic_declarative_item | body ;
and_or_xor ::= ("and" "then"?) | ("or" "else"?) | "xor" ;
generic_instantiation ::= ("package" defining_program_unit_name "is" generic_instantiation_clause) | (overriding_indicator? "procedure" defining_program_unit_name "is" generic_instantiation_clause) | (overriding_indicator? "function" defining_designator "is" generic_instantiation_clause) ;
access_to_subprogram_definition ::= ("access" "protected"? "procedure" parameter_profile) | ("access" "protected"? "function" parameter_and_result_profile) ;
interface_list ::= subtype_mark | (subtype_mark "and" interface_list) ;
local_name ::= direct_name | (direct_name SPOFF "'" attribute_designator SPON) ;
ancestor_part ::= expression | subtype_mark ;
constraint ::= scalar_constraint | composite_constraint ;
raise_statement ::= ("raise" semi) | ("raise" name raise_statement_expression? semi) ;
compound_statement ::= if_statement | case_statement | loop_statement | block_statement | extended_return_statement | accept_statement | select_statement ;
array_aggregate ::= positional_array_aggregate | named_array_aggregate ;
basic_declarative_item ::= basic_declaration | aspect_clause | use_clause ;
subtype_or_access_definition ::= (null_exclusion? subtype_mark) | access_definition ;
real_type_definition ::= floating_point_definition | fixed_point_definition ;
component_definition ::= ("aliased"? subtype_indication) | ("aliased"? access_definition) ;
protected_operation_declaration ::= subprogram_declaration | entry_declaration | aspect_clause | pragma ;
record_component_association ::= expression | (component_choice_list arrow expression_or_null) ;
orbar ::= "|" | "!" ;
formal_subprogram_declaration ::= formal_concrete_subprogram_declaration | formal_abstract_subprogram_declaration ;
factor ::= (primary starstar_primary?) | ("abs" primary) | ("not" primary) ;
fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition ;
record_component_association_list ::= ({record_component_association ","}+) | ("null" "record") ;
explicit_generic_actual_parameter ::= expression | name | subtype_mark ;
formal_object_declaration ::= (defining_identifier_list colon mode null_exclusion? subtype_mark formal_object_declaration_default? semi) | (defining_identifier_list colon mode access_definition formal_object_declaration_default? semi) ;
unlabeled_statement ::= simple_statement | compound_statement ;
name_component ::= explicit_dereference_component | indexed_slice_type_conv_or_function_call_component | selected_component_component | attribute_reference_component ;
subprogram_specification ::= procedure_specification | function_specification ;
iteration_scheme ::= ("while" condition) | ("for" loop_parameter_specification) ;
subprogram_default ::= default_name | "<>" | "null" ;
binary_adding_operator ::= "+" | "-" | (IN NL "&" EX) ;
library_unit_declaration ::= subprogram_declaration | package_declaration | generic_declaration | generic_instantiation | pragma ;
interface_and_record_extension_specification ::= ("and" interface_list record_extension_part?) | record_extension_part ;
aggregate ::= record_aggregate | extension_aggregate | array_aggregate ;
discrete_subtype_definition ::= subtype_indication | range ;
range ::= range_attribute_reference | (simple_expression SP ".." SP simple_expression) ;
relational_operator ::= "=" | "/=" | "<" | "<=" | ">" | ">=" ;
expression_or_null ::= expression | "<>" ;
pragma ::= ("pragma" id blocksemi) | ("pragma" id pragma_arguments blocksemi) ;
formal_package_actual_part ::= ("(" others_arrow? "<>" ")") | (generic_actual_part?) | ("(" {formal_package_association ","}+ comma_others_arrow_null? ")") ;
component_choice_list ::= (selector_name or_selector_name*) | "others" ;
formal_package_association ::= generic_association | (selector_name arrow "<>") ;
private_extension_declaration_modifier ::= "limited" | "synchronized" ;
aspect_clause ::= attribute_definition_clause | enumeration_representation_clause | record_representation_clause | at_clause ;
object_renaming_declaration ::= (defining_identifier colon null_exclusion? subtype_mark "renames" name semi) | (defining_identifier colon access_definition "renames" name semi) ;
renaming_declaration ::= object_renaming_declaration | exception_renaming_declaration | package_renaming_declaration | subprogram_renaming_declaration | generic_renaming_declaration ;
delay_statement ::= delay_until_statement | delay_relative_statement ;
proper_body ::= subprogram_body | package_body | task_body | protected_body ;
return_subtype_indication ::= subtype_indication | access_definition ;
body_stub ::= subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;
expression_or_aggregate ::= ("(" SPON expression ")") | (SPON aggregate) ;
identifier ::= id | wide_identifier ;
formal_type_definition ::= formal_private_type_definition | formal_derived_type_definition | formal_discrete_type_definition | formal_signed_integer_type_definition | formal_modular_type_definition | formal_floating_point_definition | formal_ordinary_fixed_point_definition | formal_decimal_fixed_point_definition | formal_array_type_definition | formal_access_type_definition | formal_interface_type_definition ;
use_clause ::= use_package_clause | use_type_clause ;
discrete_choice ::= expression | discrete_range | "others" ;
protected_element_declaration ::= protected_operation_declaration | component_declaration ;
discriminant_specification ::= (defining_identifier_list colon null_exclusion? subtype_mark discriminant_specification_default?) | (defining_identifier_list colon access_definition discriminant_specification_default?) ;
full_type_declaration ::= ("type" defining_identifier known_discriminant_part? "is" type_definition blocksemi) | task_type_declaration | protected_type_declaration ;
context_item ::= with_clause | use_clause ;
mode ::= ("in"?) | ("in" "out") | "out" ;
simple_statement ::= null_statement | procedure_call_statement | assignment_statement | exit_statement | goto_statement | simple_return_statement | entry_call_statement | requeue_statement | delay_statement | abort_statement | raise_statement | code_statement | pragma ;
body ::= proper_body | body_stub ;
direct_name ::= identifier | operator_symbol ;
component_list ::= (component_item+) | (component_item* variant_part) | ("null" semi) ;
generic_renaming_declaration ::= ("generic" "package" defining_program_unit_name "renames" name blocksemi) | ("generic" "procedure" defining_program_unit_name "renames" name blocksemi) | ("generic" "function" defining_program_unit_name "renames" name blocksemi) ;
highest_precedence_operator ::= "**" | "abs" | "not" ;
access_type_definition ::= (null_exclusion? access_to_object_definition) | (null_exclusion? access_to_subprogram_definition) ;
protected_operation_item ::= subprogram_declaration | subprogram_body | entry_body | aspect_clause ;
triggering_statement ::= procedure_or_entry_call | delay_statement ;
logical_operator ::= "and" | "or" | "xor" ;
library_item ::= ("private"? library_unit_declaration) | library_unit_body | ("private"? library_unit_renaming_declaration) ;
attribute_designator ::= (identifier attribute_designator_expression?) | "access" | "delta" | "digits" ;
composite_constraint ::= index_constraint | discriminant_constraint ;
component_item ::= component_declaration | aspect_clause | pragma ;
parameter_type_specification ::= (mode null_exclusion? subtype_mark parameter_specification_default?) | (access_definition parameter_specification_default?) ;
designator ::= (designator_parent_unit_name? identifier) | operator_symbol ;
generic_declaration ::= generic_subprogram_declaration | generic_package_declaration ;
array_type_definition ::= unconstrained_array_definition | constrained_array_definition ;
exception_choice ::= name | "others" ;
discriminant_part ::= unknown_discriminant_part | known_discriminant_part ;
scalar_constraint ::= range_constraint | digits_constraint | delta_constraint ;
access_definition ::= (null_exclusion? "access" "constant"? subtype_mark) | (null_exclusion? "access" "protected"? "procedure" parameter_profile) | (null_exclusion? "access" "protected"? "function" parameter_and_result_profile) ;
library_unit_renaming_declaration ::= package_renaming_declaration | generic_renaming_declaration | subprogram_renaming_declaration | pragma ;
task_item ::= entry_declaration | aspect_clause | pragma ;
index_or_parameter_value ::= expression | discrete_range | parameter_association ;
allocator ::= ("new" subtype_indication) | ("new" qualified_expression) ;
name ::= (direct_name name_component*) | character_literal ;
with_clause ::= limited_with_clause | nonlimited_with_clause ;
multiplying_operator ::= "*" | "/" | "mod" | "rem" ;
interface_type_definition_modifier ::= "limited" | "task" | "protected" | "synchronized" ;
primary ::= numeric_literal | "null" | string_literal | aggregate | name | qualified_expression | allocator | ("(" expression ")") | if_expression ;
record_definition ::= (IN eol "record" IN eol component_list EX "end" "record" EX) | ("null" "record") ;
generic_formal_parameter_declaration_or_use_clause ::= generic_formal_parameter_declaration | use_clause | pragma ;
compilation_unit ::= (context_clause library_item) | (context_clause subunit) | pragma ;
--------------------c::iso-9899-1999.bgf--------------------
iteration-statement ::= ("while" "(" expression ")" statement) | ("do" statement "while" "(" expression ")" ";") | ("for" "(" expression? ";" expression? ";" expression? ")" statement) | ("for" "(" declaration expression? ";" expression? ")" statement) ;
conditional-expression ::= logical-OR-expression | (logical-OR-expression "?" expression ":" conditional-expression) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) ;
logical-OR-expression ::= logical-AND-expression | (logical-OR-expression "||" logical-AND-expression) ;
init-declarator-list ::= init-declarator | (init-declarator-list "," init-declarator) ;
pointer ::= ("*" type-qualifier-list?) | ("*" type-qualifier-list? pointer) ;
abstract-declarator ::= pointer | (pointer? direct-abstract-declarator) ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
external-declaration ::= function-definition | declaration ;
designator-list ::= designator | (designator-list designator) ;
unary-expression ::= postfix-expression | ("++" unary-expression) | ("--" unary-expression) | (unary-operator cast-expression) | ("sizeof" unary-expression) | ("sizeof" "(" type-name ")") ;
labeled-statement ::= (identifier ":" statement) | ("case" constant-expression ":" statement) | ("default" ":" statement) ;
enum-specifier ::= ("enum" identifier? "{" enumerator-list "}") | ("enum" identifier? "{" enumerator-list "," "}") | ("enum" identifier) ;
logical-AND-expression ::= inclusive-OR-expression | (logical-AND-expression "&&" inclusive-OR-expression) ;
postfix-expression ::= primary-expression | (postfix-expression "[" expression "]") | (postfix-expression "(" argument-expression-list? ")") | (postfix-expression "." identifier) | (postfix-expression "->" identifier) | (postfix-expression "++") | (postfix-expression "--") | ("(" type-name ")" "{" initializer-list "}") | ("(" type-name ")" "{" initializer-list "," "}") ;
statement ::= labeled-statement | compound-statement | expression-statement | selection-statement | iteration-statement | jump-statement ;
multiplicative-expression ::= cast-expression | (multiplicative-expression "*" cast-expression) | (multiplicative-expression "/" cast-expression) | (multiplicative-expression "%" cast-expression) ;
selection-statement ::= ("if" "(" expression ")" statement) | ("if" "(" expression ")" statement "else" statement) | ("switch" "(" expression ")" statement) ;
AND-expression ::= equality-expression | (AND-expression "&" equality-expression) ;
parameter-type-list ::= parameter-list | (parameter-list "," "...") ;
type-specifier ::= "void" | "char" | "short" | "int" | "long" | "float" | "double" | "signed" | "unsigned" | "_Bool" | "_Complex" | "_Imaginary" | struct-or-union-specifier | enum-specifier | typedef-name ;
initializer-list ::= (designation? initializer) | (initializer-list "," designation? initializer) ;
struct-declarator ::= declarator | (declarator? ":" constant-expression) ;
declaration-specifiers ::= (storage-class-specifier declaration-specifiers?) | (type-specifier declaration-specifiers?) | (type-qualifier declaration-specifiers?) | (function-specifier declaration-specifiers?) ;
cast-expression ::= unary-expression | ("(" type-name ")" cast-expression) ;
assignment-operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" ;
argument-expression-list ::= assignment-expression | (argument-expression-list "," assignment-expression) ;
initializer ::= assignment-expression | ("{" initializer-list "}") | ("{" initializer-list "," "}") ;
inclusive-OR-expression ::= exclusive-OR-expression | (inclusive-OR-expression "|" exclusive-OR-expression) ;
translation-unit ::= external-declaration | (translation-unit external-declaration) ;
struct-or-union ::= "struct" | "union" ;
block-item-list ::= block-item | (block-item-list block-item) ;
direct-abstract-declarator ::= ("(" abstract-declarator ")") | (direct-abstract-declarator? "[" assignment-expression? "]") | (direct-abstract-declarator? "[" "*" "]") | (direct-abstract-declarator? "(" parameter-type-list? ")") ;
assignment-expression ::= conditional-expression | (unary-expression assignment-operator assignment-expression) ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
type-qualifier ::= "const" | "restrict" | "volatile" ;
storage-class-specifier ::= "typedef" | "extern" | "static" | "auto" | "register" ;
parameter-declaration ::= (declaration-specifiers declarator) | (declaration-specifiers abstract-declarator?) ;
direct-declarator ::= identifier | ("(" declarator ")") | (direct-declarator "[" type-qualifier-list? assignment-expression? "]") | (direct-declarator "[" "static" type-qualifier-list? assignment-expression "]") | (direct-declarator "[" type-qualifier-list "static" assignment-expression "]") | (direct-declarator "[" type-qualifier-list? "*" "]") | (direct-declarator "(" parameter-type-list ")") | (direct-declarator "(" identifier-list? ")") ;
designator ::= ("[" constant-expression "]") | ("." identifier) ;
type-qualifier-list ::= type-qualifier | (type-qualifier-list type-qualifier) ;
block-item ::= declaration | statement ;
exclusive-OR-expression ::= AND-expression | (exclusive-OR-expression "^" AND-expression) ;
declaration-list ::= declaration | (declaration-list declaration) ;
jump-statement ::= ("goto" identifier ";") | ("continue" ";") | ("break" ";") | ("return" expression? ";") ;
specifier-qualifier-list ::= (type-specifier specifier-qualifier-list?) | (type-qualifier specifier-qualifier-list?) ;
init-declarator ::= declarator | (declarator "=" initializer) ;
struct-or-union-specifier ::= (struct-or-union identifier? "{" struct-declaration-list "}") | (struct-or-union identifier) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
struct-declaration-list ::= struct-declaration | (struct-declaration-list struct-declaration) ;
enumerator-list ::= enumerator | (enumerator-list "," enumerator) ;
enumerator ::= enumeration-constant | (enumeration-constant "=" constant-expression) ;
primary-expression ::= identifier | constant | string-literal | ("(" expression ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
identifier-list ::= identifier | (identifier-list "," identifier) ;
unary-operator ::= "&" | "*" | "+" | "-" | "~" | "!" ;
parameter-list ::= parameter-declaration | (parameter-list "," parameter-declaration) ;
struct-declarator-list ::= struct-declarator | (struct-declarator-list "," struct-declarator) ;
--------------------c::iso-9899-tc2.bgf--------------------
iteration-statement ::= ("while" "(" expression ")" statement) | ("do" statement "while" "(" expression ")" ";") | ("for" "(" expression? ";" expression? ";" expression? ")" statement) | ("for" "(" declaration expression? ";" expression? ")" statement) ;
conditional-expression ::= logical-OR-expression | (logical-OR-expression "?" expression ":" conditional-expression) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) ;
logical-OR-expression ::= logical-AND-expression | (logical-OR-expression "||" logical-AND-expression) ;
init-declarator-list ::= init-declarator | (init-declarator-list "," init-declarator) ;
pointer ::= ("*" type-qualifier-list?) | ("*" type-qualifier-list? pointer) ;
abstract-declarator ::= pointer | (pointer? direct-abstract-declarator) ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
external-declaration ::= function-definition | declaration ;
designator-list ::= designator | (designator-list designator) ;
unary-expression ::= postfix-expression | ("++" unary-expression) | ("--" unary-expression) | (unary-operator cast-expression) | ("sizeof" unary-expression) | ("sizeof" "(" type-name ")") ;
labeled-statement ::= (identifier ":" statement) | ("case" constant-expression ":" statement) | ("default" ":" statement) ;
enum-specifier ::= ("enum" identifier? "{" enumerator-list "}") | ("enum" identifier? "{" enumerator-list "," "}") | ("enum" identifier) ;
logical-AND-expression ::= inclusive-OR-expression | (logical-AND-expression "&&" inclusive-OR-expression) ;
postfix-expression ::= primary-expression | (postfix-expression "[" expression "]") | (postfix-expression "(" argument-expression-list? ")") | (postfix-expression "." identifier) | (postfix-expression "->" identifier) | (postfix-expression "++") | (postfix-expression "--") | ("(" type-name ")" "{" initializer-list "}") | ("(" type-name ")" "{" initializer-list "," "}") ;
statement ::= labeled-statement | compound-statement | expression-statement | selection-statement | iteration-statement | jump-statement ;
multiplicative-expression ::= cast-expression | (multiplicative-expression "*" cast-expression) | (multiplicative-expression "/" cast-expression) | (multiplicative-expression "%" cast-expression) ;
selection-statement ::= ("if" "(" expression ")" statement) | ("if" "(" expression ")" statement "else" statement) | ("switch" "(" expression ")" statement) ;
AND-expression ::= equality-expression | (AND-expression "&" equality-expression) ;
parameter-type-list ::= parameter-list | (parameter-list "," "...") ;
type-specifier ::= "void" | "char" | "short" | "int" | "long" | "float" | "double" | "signed" | "unsigned" | "_Bool" | "_Complex" | struct-or-union-specifier | enum-specifier | typedef-name ;
initializer-list ::= (designation? initializer) | (initializer-list "," designation? initializer) ;
struct-declarator ::= declarator | (declarator? ":" constant-expression) ;
declaration-specifiers ::= (storage-class-specifier declaration-specifiers?) | (type-specifier declaration-specifiers?) | (type-qualifier declaration-specifiers?) | (function-specifier declaration-specifiers?) ;
cast-expression ::= unary-expression | ("(" type-name ")" cast-expression) ;
assignment-operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" ;
argument-expression-list ::= assignment-expression | (argument-expression-list "," assignment-expression) ;
initializer ::= assignment-expression | ("{" initializer-list "}") | ("{" initializer-list "," "}") ;
inclusive-OR-expression ::= exclusive-OR-expression | (inclusive-OR-expression "|" exclusive-OR-expression) ;
translation-unit ::= external-declaration | (translation-unit external-declaration) ;
struct-or-union ::= "struct" | "union" ;
block-item-list ::= block-item | (block-item-list block-item) ;
direct-abstract-declarator ::= ("(" abstract-declarator ")") | (direct-abstract-declarator? "[" assignment-expression? "]") | (direct-abstract-declarator? "[" "*" "]") | (direct-abstract-declarator? "(" parameter-type-list? ")") ;
assignment-expression ::= conditional-expression | (unary-expression assignment-operator assignment-expression) ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
type-qualifier ::= "const" | "restrict" | "volatile" ;
storage-class-specifier ::= "typedef" | "extern" | "static" | "auto" | "register" ;
parameter-declaration ::= (declaration-specifiers declarator) | (declaration-specifiers abstract-declarator?) ;
direct-declarator ::= identifier | ("(" declarator ")") | (direct-declarator "[" type-qualifier-list? assignment-expression? "]") | (direct-declarator "[" "static" type-qualifier-list? assignment-expression "]") | (direct-declarator "[" type-qualifier-list "static" assignment-expression "]") | (direct-declarator "[" type-qualifier-list? "*" "]") | (direct-declarator "(" parameter-type-list ")") | (direct-declarator "(" identifier-list? ")") ;
designator ::= ("[" constant-expression "]") | ("." identifier) ;
type-qualifier-list ::= type-qualifier | (type-qualifier-list type-qualifier) ;
block-item ::= declaration | statement ;
exclusive-OR-expression ::= AND-expression | (exclusive-OR-expression "^" AND-expression) ;
declaration-list ::= declaration | (declaration-list declaration) ;
jump-statement ::= ("goto" identifier ";") | ("continue" ";") | ("break" ";") | ("return" expression? ";") ;
specifier-qualifier-list ::= (type-specifier specifier-qualifier-list?) | (type-qualifier specifier-qualifier-list?) ;
init-declarator ::= declarator | (declarator "=" initializer) ;
struct-or-union-specifier ::= (struct-or-union identifier? "{" struct-declaration-list "}") | (struct-or-union identifier) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
struct-declaration-list ::= struct-declaration | (struct-declaration-list struct-declaration) ;
enumerator-list ::= enumerator | (enumerator-list "," enumerator) ;
enumerator ::= enumeration-constant | (enumeration-constant "=" constant-expression) ;
primary-expression ::= identifier | constant | string-literal | ("(" expression ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
identifier-list ::= identifier | (identifier-list "," identifier) ;
unary-operator ::= "&" | "*" | "+" | "-" | "~" | "!" ;
parameter-list ::= parameter-declaration | (parameter-list "," parameter-declaration) ;
struct-declarator-list ::= struct-declarator | (struct-declarator-list "," struct-declarator) ;
--------------------c::iso-9899-tc3.bgf--------------------
iteration-statement ::= ("while" "(" expression ")" statement) | ("do" statement "while" "(" expression ")" ";") | ("for" "(" expression? ";" expression? ";" expression? ")" statement) | ("for" "(" declaration expression? ";" expression? ")" statement) ;
conditional-expression ::= logical-OR-expression | (logical-OR-expression "?" expression ":" conditional-expression) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) ;
logical-OR-expression ::= logical-AND-expression | (logical-OR-expression "||" logical-AND-expression) ;
init-declarator-list ::= init-declarator | (init-declarator-list "," init-declarator) ;
pointer ::= ("*" type-qualifier-list?) | ("*" type-qualifier-list? pointer) ;
abstract-declarator ::= pointer | (pointer? direct-abstract-declarator) ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
external-declaration ::= function-definition | declaration ;
designator-list ::= designator | (designator-list designator) ;
unary-expression ::= postfix-expression | ("++" unary-expression) | ("--" unary-expression) | (unary-operator cast-expression) | ("sizeof" unary-expression) | ("sizeof" "(" type-name ")") ;
labeled-statement ::= (identifier ":" statement) | ("case" constant-expression ":" statement) | ("default" ":" statement) ;
enum-specifier ::= ("enum" identifier? "{" enumerator-list "}") | ("enum" identifier? "{" enumerator-list "," "}") | ("enum" identifier) ;
logical-AND-expression ::= inclusive-OR-expression | (logical-AND-expression "&&" inclusive-OR-expression) ;
postfix-expression ::= primary-expression | (postfix-expression "[" expression "]") | (postfix-expression "(" argument-expression-list? ")") | (postfix-expression "." identifier) | (postfix-expression "->" identifier) | (postfix-expression "++") | (postfix-expression "--") | ("(" type-name ")" "{" initializer-list "}") | ("(" type-name ")" "{" initializer-list "," "}") ;
statement ::= labeled-statement | compound-statement | expression-statement | selection-statement | iteration-statement | jump-statement ;
multiplicative-expression ::= cast-expression | (multiplicative-expression "*" cast-expression) | (multiplicative-expression "/" cast-expression) | (multiplicative-expression "%" cast-expression) ;
selection-statement ::= ("if" "(" expression ")" statement) | ("if" "(" expression ")" statement "else" statement) | ("switch" "(" expression ")" statement) ;
AND-expression ::= equality-expression | (AND-expression "&" equality-expression) ;
parameter-type-list ::= parameter-list | (parameter-list "," "...") ;
type-specifier ::= "void" | "char" | "short" | "int" | "long" | "float" | "double" | "signed" | "unsigned" | "_Bool" | "_Complex" | struct-or-union-specifier | enum-specifier | typedef-name ;
initializer-list ::= (designation? initializer) | (initializer-list "," designation? initializer) ;
struct-declarator ::= declarator | (declarator? ":" constant-expression) ;
declaration-specifiers ::= (storage-class-specifier declaration-specifiers?) | (type-specifier declaration-specifiers?) | (type-qualifier declaration-specifiers?) | (function-specifier declaration-specifiers?) ;
cast-expression ::= unary-expression | ("(" type-name ")" cast-expression) ;
assignment-operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" ;
argument-expression-list ::= assignment-expression | (argument-expression-list "," assignment-expression) ;
initializer ::= assignment-expression | ("{" initializer-list "}") | ("{" initializer-list "," "}") ;
inclusive-OR-expression ::= exclusive-OR-expression | (inclusive-OR-expression "|" exclusive-OR-expression) ;
translation-unit ::= external-declaration | (translation-unit external-declaration) ;
struct-or-union ::= "struct" | "union" ;
block-item-list ::= block-item | (block-item-list block-item) ;
direct-abstract-declarator ::= ("(" abstract-declarator ")") | (direct-abstract-declarator? "[" type-qualifier-list? assignment-expression? "]") | (direct-abstract-declarator? "[" "static" type-qualifier-list? assignment-expression "]") | (direct-abstract-declarator? "[" type-qualifier-list "static" assignment-expression "]") | (direct-abstract-declarator? "[" "*" "]") | (direct-abstract-declarator? "(" parameter-type-list? ")") ;
assignment-expression ::= conditional-expression | (unary-expression assignment-operator assignment-expression) ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
type-qualifier ::= "const" | "restrict" | "volatile" ;
storage-class-specifier ::= "typedef" | "extern" | "static" | "auto" | "register" ;
parameter-declaration ::= (declaration-specifiers declarator) | (declaration-specifiers abstract-declarator?) ;
direct-declarator ::= identifier | ("(" declarator ")") | (direct-declarator "[" type-qualifier-list? assignment-expression? "]") | (direct-declarator "[" "static" type-qualifier-list? assignment-expression "]") | (direct-declarator "[" type-qualifier-list "static" assignment-expression "]") | (direct-declarator "[" type-qualifier-list? "*" "]") | (direct-declarator "(" parameter-type-list ")") | (direct-declarator "(" identifier-list? ")") ;
designator ::= ("[" constant-expression "]") | ("." identifier) ;
type-qualifier-list ::= type-qualifier | (type-qualifier-list type-qualifier) ;
block-item ::= declaration | statement ;
exclusive-OR-expression ::= AND-expression | (exclusive-OR-expression "^" AND-expression) ;
declaration-list ::= declaration | (declaration-list declaration) ;
jump-statement ::= ("goto" identifier ";") | ("continue" ";") | ("break" ";") | ("return" expression? ";") ;
specifier-qualifier-list ::= (type-specifier specifier-qualifier-list?) | (type-qualifier specifier-qualifier-list?) ;
init-declarator ::= declarator | (declarator "=" initializer) ;
struct-or-union-specifier ::= (struct-or-union identifier? "{" struct-declaration-list "}") | (struct-or-union identifier) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
struct-declaration-list ::= struct-declaration | (struct-declaration-list struct-declaration) ;
enumerator-list ::= enumerator | (enumerator-list "," enumerator) ;
enumerator ::= enumeration-constant | (enumeration-constant "=" constant-expression) ;
primary-expression ::= identifier | constant | string-literal | ("(" expression ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
identifier-list ::= identifier | (identifier-list "," identifier) ;
unary-operator ::= "&" | "*" | "+" | "-" | "~" | "!" ;
parameter-list ::= parameter-declaration | (parameter-list "," parameter-declaration) ;
struct-declarator-list ::= struct-declarator | (struct-declarator-list "," struct-declarator) ;
--------------------c::antoniol.bgf--------------------
not_newline ::= long_comment | (token) ;
line ::= ifdef | ("//"? other_preprocessor_line newline) | ("//"? any_other_line newline) ;
ifdef_token ::= ifdef_line | elsedef_line | elsifdef_line | endifdef_line ;
--------------------c::malton-dahn.bgf--------------------
slash ::= "/" | "\" | "." | ":" ;
attribute_destructor ::= "destructor" | "__destructor__" | "__destructor" | "destructor__" ;
compound_literal_array_declarator ::= (ptr_operator* array_declarator_extension*) | ("(" compound_literal_array_declarator ")" array_declarator_extension*) ;
attribute_packed ::= "__packed__" | "__packed" | "packed__" | "packed" ;
attribute_format ::= "__format__" | "__format" | "format__" | "format" ;
bit_qualifier ::= "long" | "short" | "signed" | "unsigned" | "__signed__" | "__signed" ;
attribute_noreturn ::= "__noreturn__" | "__noreturn" | "noreturn__" | "noreturn" ;
attribute_far ::= "__far__" | "__far" | "far__" | "far" ;
designated_initializer ::= assignment_expression | (designator* designator_assignment? assignment_expression) | (designator* designator_assignment? NL "{" IN {designated_initializer ","}* ","? EX "}") ;
attribute_sp_switch ::= "sp_switch" | "__sp_switch__" | "__sp_switch" | "sp_switch__" ;
argument_declarator ::= declarator | abstract_declarator ;
attribute_alias ::= "alias" | "__alias__" | "__alias" | "alias__" ;
attribute_exception ::= "exception" | "__exception__" | "__exception" | "exception__" ;
attribute_malloc ::= "malloc" | "__malloc__" | "__malloc" | "malloc__" ;
attribute_near ::= "__near__" | "__near" | "near__" | "near" ;
attribute_shared ::= "shared" | "__shared__" | "__shared" | "shared__" ;
restrict_qualifier ::= "__restrict" | "restrict__" | "restrict" | "__restrict__" ;
simple_type_or_qualifier ::= simple_type_name | type_qualifier ;
exception_arg ::= (stringlit* stringlit) | tagged_attribute_id ;
attribute_mode ::= "__mode__" | "__mode" | "mode__" | "mode" ;
attribute_always_inline ::= "__always_inline__" | "__always_inline" | "always_inline__" | "always_inline" ;
unannotated_reference_base ::= reference_id | nonreferential_primary ;
attribute_model_name ::= "small" | "__small__" | "__small" | "small__" | "medium" | "__medium__" | "__medium" | "medium__" | "large" | "__large__" | "__large" | "large__" ;
attribute_no_check_mem ::= "no_check_memory_usage" | "__no_check_memory_usage__" | "__no_check_memory_usage" | "no_check_memory_usage__" ;
attribute_eightbit ::= "eightbit_data" | "__eightbit_data__" | "__eightbit_data" | "eightbit_data__" ;
attribute_long_call ::= "long_call" | "__long_call__" | "__long_call" | "long_call__" ;
attribute_stdcall ::= "stdcall" | "__stdcall__" | "__stdcall" | "stdcall__" ;
gnu_long_int ::= gnu_long_int_string | gnu_long_int_charlit ;
attribute_noinline ::= "__noinline__" | "__noinline" | "noinline__" | "noinline" ;
attribute_regparm ::= "regparm" | "__regparm__" | "__regparm" | "regparm__" ;
attribute_extension ::= (attribute_alias "(" string ")") | attribute_aligned | (attribute_aligned "(" tagged_attribute_number ")") | (attribute_aligned "(" alignof_expression ")") | attribute_always_inline | attribute_cdecl | (attribute_cleanup "(" tagged_attribute_id ")") | attribute_const | attribute_constructor | attribute_deprecated | attribute_destructor | attribute_dllexport | attribute_dllimport | attribute_eightbit | (attribute_exception "(" exception_function {exception_arg ","}* ")") | attribute_far | attribute_funvector | (attribute_format "(" format_archetype "," tagged_attribute_number "," tagged_attribute_number ")") | (attribute_format_arg "(" tagged_attribute_number ")") | attribute_interrupt | (attribute_interrupt "(" string ")") | attribute_interrupt_handler | (attribute_interrupt_handler "(" string ")") | attribute_longcall | attribute_long_call | attribute_malloc | attribute_may_alias | (attribute_mode "(" tagged_attribute_id ")") | (attribute_model "(" attribute_model_name ")") | attribute_naked | attribute_near | attribute_no_check_mem | attribute_no_instrument | attribute_nocommon | attribute_noinline | attribute_nonnull | (attribute_nonnull "(" tagged_attribute_number+ ")") | attribute_noreturn | attribute_nothrow | attribute_packed | attribute_pure | (attribute_regparm "(" tagged_attribute_number ")") | (attribute_section "(" string ")") | attribute_shared | attribute_short_call | (attribute_signal "(" string ")") | (attribute_sp_switch "(" string ")") | attribute_stdcall | attribute_tiny | (attribute_tls_model "(" tls_model_type ")") | attribute_trans_union | (attribute_trap_exit "(" tagged_attribute_number ")") | attribute_used | attribute_unused | (attribute_vector_size "(" tagged_attribute_number ")") | (attribute_visibility "(" visibility_type ")") | attribute_weak ;
argument_expression ::= assignment_expression | type_name ;
attribute_vector_size ::= "__vector_size__" | "__vector_size" | "vector_size__" | "vector_size" ;
attribute_unused ::= "__unused__" | "__unused" | "unused__" | "unused" ;
designator_assignment ::= ":" | "=" ;
attribute_constructor ::= "constructor" | "__constructor__" | "__constructor" | "constructor__" ;
assignment_operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
attribute_trans_union ::= "__transparent_union__" | "__transparent_union" | "transparent_union__" | "transparent_union" ;
tls_model_type ::= "global-dynamic" | "local-dynamic" | "initial-exec" | "local-exec" ;
attribute_naked ::= "naked" | "__naked__" | "__naked" | "naked__" ;
reference ::= reference_id | reference_expression ;
exception_function ::= (stringlit* stringlit) | tagged_attribute_id ;
visibility_type ::= "default" | "hidden" | "protected" | "internal" ;
attribute_model ::= "model" | "__model__" | "__model" | "model__" ;
attribute_short_call ::= "short_call" | "__short_call__" | "__short_call" | "short_call__" ;
attribute_tiny ::= "tiny_data" | "__tiny_data__" | "__tiny_data" | "tiny_data__" ;
attribute_section ::= "section" | "__section__" | "__section" | "section__" ;
attribute_no_instrument ::= "no_instrument_function" | "__no_instrument_function__" | "__no_instrument_function" | "no_instrument_function__" ;
format_archetype ::= "printf" | "__printf__" | "__printf" | "printf__" | "scanf" | "__scanf__" | "__scanf" | "scanf__" | "strftime" | "__strftime__" | "__strftime" | "strftime__" | "strfmon" | "__strfmon__" | "__strfmon" | "strfmon__" ;
attribute_aligned ::= "__aligned__" | "__aligned" | "aligned__" | "aligned" ;
file_id ::= id | key ;
attribute_pure ::= "__pure__" | "__pure" | "pure__" | "pure" ;
attribute_weak ::= "weak" | "__weak__" | "__weak" | "weak__" ;
array_designator ::= ("[" constant_expression "]" postfix_extension*) | ("[" constant_expression SP "..." SP constant_expression "]" postfix_extension*) ;
attribute_deprecated ::= "__deprecated__" | "__deprecated" | "deprecated__" | "deprecated" ;
attribute_dllexport ::= "__dllexport__" | "__dllexport" | "dllexport__" | "dllexport" ;
attribute_nonnull ::= "__nonnull__" | "__nonnull" | "nonnull__" | "nonnull" ;
declarator_extension ::= function_declarator_extension | array_declarator_extension ;
attribute_nocommon ::= "nocommon" | "__nocommon__" | "nocommon__" | "__nocommon" ;
attribute_signal ::= "signal" | "__signal__" | "__signal" | "signal__" ;
attribute_cdecl ::= "cdecl" | "__cdecl__" | "__cdecl" | "cdecl__" ;
attribute_dllimport ::= "dllimport" | "__dllimport__" | "__dllimport" | "dllimport__" ;
declaration_or_function_definition ::= declaration | function_definition ;
simple_type_name ::= "char" | "int" | "void" | "float" | "double" | type_id ;
attribute_nothrow ::= "__nothrow__" | "__nothrow" | "nothrow__" | "nothrow" ;
postfix_expression ::= reference | nonreference ;
binary_operator ::= "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "||" | "&&" | "|" | "^" | "&" | "<<" | ">>" ;
attribute_funvector ::= "function_vector" | "__function_vector__" | "__function_vector" | "function_vector__" ;
attribute_longcall ::= "longcall" | "__longcall__" | "__longcall" | "longcall__" ;
struct_or_union ::= "struct" | "union" ;
alignof_expression ::= ("__alignof__" "(" unary_expression ")") | ("__alignof" "(" unary_expression ")") | ("__alignof__" "(" type_name ")") | ("__alignof" "(" type_name ")") ;
compound_literal ::= ("(" struct_or_union_specifier ")" "{" {designated_initializer ","}* ","? "}") | ("(" compound_literal_array_type ")" "{" {designated_initializer ","}* ","? "}") | ("(" compound_literal ")") ;
ptr_qualifier ::= restrict_qualifier | cv_qualifier ;
binary_expression ::= unary_expression | (binary_expression binary_operator unary_expression) ;
attribute_visibility ::= "__visibility__" | "__visibility" | "visibility__" | "visibility" ;
designator ::= array_designator | struct_or_union_designator ;
attribute_may_alias ::= "__may_alias__" | "__may_alias" | "may_alias__" | "may_alias" ;
attribute_format_arg ::= "__format_arg__" | "__format_arg" | "format_arg__" | "format_arg" ;
typeof_specifier ::= "__typeof" | "typeof" | "__typeof__" | "typeof__" ;
sc_specifier ::= "auto" | "register" | "static" | "extern" | "typedef" ;
attribute_trap_exit ::= "trap_exit" | "__trap_exit__" | "__trap_exit" | "trap_exit__" ;
asm_or_cv ::= "__asm__" | "asm" | "asm__" | "__asm" | cv_qualifier ;
attribute_interrupt_handler ::= "interrupt_handler" | "__interrupt_handler__" | "__interrupt_handler" | "interrupt_handler__" ;
attributes_or_asm ::= attribute_spec | asm_spec ;
typeof_expression ::= (typeof_specifier "(" simple_type_name ")") | (typeof_specifier "(" expression ")") ;
inline_qualifier ::= "__inline" | "__inline__" | "inline__" | "inline" ;
attribute_tls_model ::= "__tls_model__" | "__tls_model" | "tls_model__" | "tls_model" ;
attribute_cleanup ::= "__cleanup__" | "__cleanup" | "cleanup__" | "cleanup" ;
attribute_const ::= "__const__" | "__const" | "const__" | "const" ;
attribute_interrupt ::= "interrupt" | "__interrupt__" | "__interrupt" | "interrupt__" ;
attribute_used ::= "__used__" | "__used" | "used__" | "used" ;
--------------------c::bruneliere.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------c::cordy-malton-dahn.bgf--------------------
asm_spec ::= (asm cv_qualifier* "(" IN asm_template asm_output_operands? asm_input_operands? asm_clobbered_registers? EX ")") | (asm cv_qualifier* "{" IN asm_instruction_semi* asm_instruction semi? EX "}") ;
attribute_spec ::= (attribute_specifier "('(" {attribute_extension ","}* ")')") | (IN NL acquires_releases "(" expression ")" EX) | upper_macro_name ;
constructor_expression ::= ("(" constructor_type ")" "{" {initializer ","}* ","? "}") | ("(" constructor_expression ")") ;
asm ::= "__asm__" | "asm" | "asm__" | "__asm" ;
colon_equals_or_equals ::= ":" | "=" | "|=" ;
KR_simple_type_name ::= simple_type_name | (struct_or_union id) | enum_specifier | bit_qualifier ;
declaration ::= (decl_specifiers {init_declarator ","}* semi) | (decl_specifiers declarator "=" compound_initializer NL) | extern_langauge_declaration | null_declaration | (local_label declarator+) | asm_spec | machinestart_declaration | preprocessor ;
ps_argument ::= constant_expression | register_spec ;
for_statement ::= ("for" "(" expression_list? ";" expression_list? ";" expression_list? ")" sub_statement) | ("for" "(" decl_specifiers init_declarator+ ";" expression_list? ";" expression_list? ")" sub_statement) | ("for" "(" expression_list? ";" expression_list? ")" sub_statement) | (foreachid "(" expression_list ")" sub_statement) ;
type_specifier ::= simple_type_name | enum_specifier | struct_or_union_specifier | typeof_expression | complex_specifier ;
argument_declaration ::= (decl_specifiers argument_declarator?) | ("(" argument_declaration ")") ;
bit_qualifier ::= "long" | "short" | "signed" | "unsigned" | "__signed__" | "__signed" ;
member_declarator ::= (declarator bitfieldsize? sub_member_declarators? attributes_or_asm*) | bitfieldsize ;
postfix_extension ::= ("[" SPON assignment_expression SPOFF "]") | (SP "(" SPON {argument_expression ","}* dotdot? SPOFF ")") | ("." id) | ("->" id macro_call?) | "++" | "--" ;
label ::= (EX label_id ":" IN NL) | (EX SP SP "case" constant_expression ":" IN NL) | (EX SP SP "default" ":" IN NL) | (EX SP SP "case" constant_expression SP "..." SP constant_expression ":" IN NL) ;
argument_declarator ::= (declarator attributes_or_asm*) | (abstract_declarator attributes_or_asm*) ;
string_unit ::= stringlit | pseudo_string | register_spec | preprocessor ;
statement ::= (preprocessor* label* unlabeled_statement) | label | preprocessor ;
c_unlabeled_statement ::= (simple_statement semi) | structured_statement ;
abstract_declarator ::= (ptr_operator+ declarator_extension* SPON) | array_declarator_extension | ("(" abstract_declarator+ ")" declarator_extension*) | ("(" type_name+ ")") | "static" ;
acquires_releases ::= "__acquires" | "__releases" ;
multiplicative_operator ::= "*" | "/" | "%" | "DIV" | "MOD" ;
decl_qualifier_or_type_specifier ::= decl_qualifier | type_specifier | (macro_specifier nosemiNL?) ;
unknown_item ::= ("{" unknown_item* "}") | token | key ;
asm_register ::= string | pseudo_string ;
restrict_qualifier ::= "__restrict" | "restrict__" | "restrict" | "__restrict__" ;
simple_type_or_qualifier ::= simple_type_name | type_qualifier ;
type_qualifier ::= bit_qualifier | cv_qualifier | inline_qualifier | restrict_qualifier | init_qualifier | exit_qualifier | user_qualifier | force_qualifier | asmlinkage_qualifier | zexport_qualifier | attribute_spec ;
preprocessor_function_header ::= (NL preprocessor function_header) | (NL function_header) ;
nf_qualifier ::= "near" | "far" | "NEAR" | "FAR" ;
function_definition_or_declaration ::= function_definition | declaration | preprocessor | (compound_statement NL) | macro_declaration_or_statement | unknown_declaration_or_statement ;
equals_initializer ::= ("=" initializer) | initializer ;
initializer ::= (preprocessor* initializer_unit+) | (ε initializer_unit) ;
while_statement ::= ("while" "(" expression_list ")" sub_statement else_statement?) | (whileeachid "(" expression_list ")" sub_statement else_statement?) ;
constructor_type ::= struct_or_union_specifier | (type_specifiers ptr_operator* array_declarator_extension*) ;
base_declarator ::= reference_id | (SPON "(" decl_specifiers? declarator ")") ;
gnu_statement ::= error_statement | else_statement ;
cv_qualifier ::= "const" | "volatile" | "CONST" | "__const" | "__const__" | "const__" | "__volatile__" | "__volatile" | "volatile__" | "__iomem" | initdata | "internal_function" | "yyconst" | "pascal" | upper_macro_name ;
gnu_long_int ::= gnu_long_int_string | gnu_long_int_charlit ;
alignof_specifier ::= "__alignof__" | "__alignof" ;
attribute_specifier ::= "__attribute__" | "__attribute" ;
expression_or_type_name ::= type_name | expression ;
argument_expression ::= (preprocessor* id? assignment_expression id? colon_number? preprocessor*) | type_name | structured_statement | equality_operator | relational_operator | (assignment_operator assignment_expression) | "do" | "extern" | "continue" | ε ;
register_spec ::= ("%" SPOFF "%"? id SPON) | ("%" SPOFF "%"? integernumber id? SPON) ;
assignment_operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
force_qualifier ::= "__force" | "force__" | "force" | "__force__" ;
ptr_operator ::= (nf_qualifier? "*" SPOFF ptr_qualifier*) | (nf_qualifier? "(" "*" ")" SPOFF ptr_qualifier*) ;
decl_qualifier ::= sc_specifier | type_qualifier | extension_specifier | weak_specifier | declspec_specifier ;
member_declaration ::= (decl_specifiers {member_declarator ","}* semi) | null_declaration | preprocessor ;
function_header ::= (decl_specifiers? declarator function_declarator_extension attribute_spec*) | ("YY_DECL" NL) ;
macro_argument ::= ("(" macro_arguments ")") | token | key ;
bit_OR_operator ::= "|" | "BIT_OR" | "bit_or" ;
compound_initializer ::= ("{" "}") | ("{" IN {initializer ","}* ","? ";"? preprocessor_list_initializer* EX NL "}") ;
attribute_name ::= id | cv_qualifier ;
if_statement ::= ("if" "(" expression_list preprocessor* ")" sub_statement else_statement?) | ("if" postfix_expression sub_statement else_statement?) ;
macro_declaration_or_statement ::= (reference_id_equals? macro_call equals_initializer? ";"? NL) | (upper_macro_name ";"? NL) ;
logical_OR_operator ::= "||" | "OR" | "or" ;
assignment_expression ::= conditional_expression | (unary_expression_assign assignment_expression) ;
unlabeled_statement ::= c_unlabeled_statement | gnu_statement ;
equality_operator ::= "==" | "!=" ;
exit_qualifier ::= "__exit" | "exit__" | "exit" | "__exit__" ;
sub_unary_expression ::= postfix_expression | (unary_operator SPOFF cast_expression SPON) | (SPON sizeof_expression) | (SPON alignof_expression) ;
shift_operator ::= "<<" | ">>" ;
initializer_unit ::= assignment_expression | compound_initializer | (NL element_label colon_equals_or_equals? initializer ";"?) | (NL "[" constant_expression dotdotdot? constant_expression? "]" "="? initializer ";"?) | macro_call ;
extension_specifier ::= "__extension__" | "__extension" ;
relational_operator ::= "<" | ">" | "<=" | ">=" ;
do_statement ::= ("do" sub_statement "while" "(" expression_list ")" semi) | ("do" sub_statement "while" macro_call semi) | ("do" sub_statement whileeachid "(" expression_list ")" semi) ;
init_qualifier ::= "__init" | "init__" | "init" | "__init__" ;
device_attr ::= "DEVICE_ATTR" | "SYSDEV_ATTR" | "DEFINE_TIMER" | "DECLARE_TASKLET" ;
initdata ::= "__initdata" | "__devinitdata" | "__cpuinitdata" | "__read_mostly" | "__initmv" | "__initdata_or_module" | "__pminitdata" | "__cpuinit" | "__devinit" | "BDATA" | "compat_init_data" | "in2000__INITDATA" ;
declaration_or_statement ::= declaration | statement | preprocessor | function_definition | macro_declaration_or_statement | unknown_declaration_or_statement ;
additive_operator ::= "+" | "-" ;
weak_specifier ::= "__weak__" | "__weak" ;
user_qualifier ::= "__user" | "user__" | "user" | "__user__" ;
statement_declaration_or_end ::= declaration_or_statement | "}" ;
unary_operator ::= "&" | "*" | "+" | "-" | "~" | "!" | "&&" | "NOT" | "not" ;
declarator_extension ::= function_declarator_extension | array_declarator_extension ;
sub_statement ::= compound_statement | (IN NL statement EX) | (IN NL macro_declaration_or_statement EX) ;
complex ::= "__complex" | "__complex__" | "__Complex" ;
element_name_extension ::= ("." element_name) | ("[" constant_expression "]") ;
else_sub_statement ::= if_statement | sub_statement ;
constant ::= number | float | hex | long | (SP dotfloat) | charlit | string | gnu_long_int | gnu_long_int_string | hexfloat ;
switch_statement ::= ("switch" "(" expression_list ")" sub_statement) | ("switch" macro_call sub_statement) ;
simple_type_name ::= "char" | "int" | "void" | "float" | "double" | type_id ;
logical_AND_operator ::= "&&" | "AND" | "and" | "ANDP" ;
simple_statement ::= jump_statement | null_statement | expression_statement ;
initialization ::= (initdata? "=" initializer) | ("(" constant_expression ")") | macro_call ;
sizeof_expression ::= ("sizeof" "(" type_name ")") | ("sizeof" unary_expression) ;
bit_AND_operator ::= "&" | "BIT_AND" | "bit_and" ;
jump_statement ::= ("goto" label_id) | "continue" | "break" | ("return" expression?) | ("goto" ptr_operator expression) | ("return" expression attribute_spec?) ;
struct_or_union ::= "struct" | "union" ;
struct_or_union_specifier ::= (struct_or_union attribute_spec* reference_id? struct_or_union_body attribute_spec*) | (struct_or_union attribute_spec* reference_id attribute_spec*) ;
bit_XOR_operator ::= "^" | "BIT_XOR" | "bit_xor" ;
type_specifiers ::= (type_qualifier* type_specifier type_qualifier*) | (type_qualifier+) ;
ptr_qualifier ::= (SPON cv_qualifier) | (SPON inline_qualifier) | (SPON restrict_qualifier) | (SPON init_qualifier) | (SPON exit_qualifier) | (SPON user_qualifier) | (SPON zexport_qualifier) ;
string ::= (stringlit string_unit*) | (pseudo_string stringlit string_unit*) ;
pre_increment_operator ::= ("++" SPOFF) | ("--" SPOFF) ;
typeof_specifier ::= "__typeof" | "typeof" | "__typeof__" | "typeof__" ;
reference_id ::= id | foreachid | whileeachid ;
sc_specifier ::= "auto" | "register" | "static" | "extern" | "far" | "near" | "typedef" | "local" | "vector" | "const_debug" | "INIT" | "STATIC" | "NEAR" | "FAR" ;
unknown_declaration_or_statement ::= (unknown_item+ ";" NL) | (unknown_item+ NL) ;
token_or_key ::= token | key ;
attributes_or_asm ::= attribute_spec | asm_spec ;
asm_operand ::= (bracketed_id? string "(" expression ")") | (pseudo_string "(" expression ")") ;
inline_qualifier ::= "__inline" | "__inline__" | "inline__" | "inline" | "SBA_INLINE" ;
primary ::= reference_id | constant | string | ("(" SPON expression_list ","? ")") | ("{" SPON expression_list ","? "}") | (SPON extension_specifier "(" expression_list ")") | (SPON constructor_expression) | (SPON asm_spec) ;
structured_statement ::= if_statement | for_statement | while_statement | switch_statement | do_statement | compound_statement | asm_statement ;
enum_specifier ::= ("enum" reference_id) | ("enum" reference_id? "{" {enumerator ","}* ","? preprocessor* "}") ;
attribute_argument ::= ("(" attribute_argument* ")") | token_or_key ;
--------------------c::cordy-malton.bgf--------------------
file_id ::= id | key ;
slash ::= "/" | "\" | "." | ":" ;
declaration ::= (declaration_body semi) | preprocessor ;
type_specifier ::= simple_type_name | enum_specifier | struct_or_union_specifier ;
argument_declaration ::= (decl_specifiers argument_declarator?) | "..." ;
member_declarator ::= (declarator bitfieldsize?) | bitfieldsize ;
postfix_extension ::= ("[" expression "]") | ("(" expression? ")") | ("." id) | ("->" id) | "++" | "--" ;
label ::= (label_id ":") | (EX SP SP "case" constant_expression ":" IN NL) | (EX SP SP "default" ":" IN NL) ;
unary_operator ::= "*" | "&" | "+" | "-" | "!" | "~" | "++" | "--" ;
argument_declarator ::= declarator | abstract_declarator ;
declarator_extension ::= function_declarator_extension | array_declarator_extension ;
statement ::= (label* unlabeled_statement) | preprocessor ;
abstract_declarator ::= (ptr_operator+ declarator_extension*) | ("(" abstract_declarator ")" declarator_extension*) ;
unary_expression ::= postfix_expression | (unary_operator SPOFF unary_expression SPON) | ("(" type_name ")" unary_expression) | sizeof_expression ;
type_qualifier ::= "long" | "short" | "signed" | "unsigned" ;
unannotated_reference_base ::= reference_id | nonreferential_primary ;
constant ::= number | float | hex | long | (SP dotfloat) | charlit | string ;
declaration_or_function_definition ::= declaration | function_definition ;
simple_type_name ::= "char" | "int" | "void" | "float" | "double" | type_id ;
initializer ::= expression | (NL "{" IN {initializer ","}* ","? EX "}") ;
postfix_expression ::= reference | nonreference ;
binary_operator ::= "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "||" | "&&" | "|" | "^" | "&" | "<<" | ">>" ;
initialization ::= ("=" initializer) | ("(" constant_expression ")") ;
base_declarator ::= reference_id | ("(" declarator ")") ;
nonreferential_primary ::= constant | string | ("(" expression ")") ;
sizeof_expression ::= ("sizeof" "(" type_name ")") | ("sizeof" unary_expression) ;
jump_statement ::= ("goto" label_id semi) | ("continue" semi) | ("break" semi) | ("return" expression? semi) ;
cv_qualifier ::= "const" | "volatile" ;
struct_or_union ::= "struct" | "union" ;
struct_or_union_specifier ::= (struct_or_union tagged_reference_id? "{" IN NL member_declaration* EX "}") | (struct_or_union tagged_reference_id) ;
type_specifiers ::= (type_qualifier+ type_specifier? type_qualifier*) | (type_specifier type_qualifier*) ;
binary_expression ::= unary_expression | (binary_expression binary_operator unary_expression) ;
assignment_operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
decl_qualifier ::= sc_specifier | cv_qualifier | type_qualifier ;
member_declaration ::= (decl_specifiers member_declarator+ semi) | preprocessor ;
preprocessor ::= ("#define" id "(" id+ ")" expression NL) | ("#define" id expression NL) | (EX "#else" IN NL) | (EX "#endif" NL NL) | (NL "#if" expression IN NL) | (NL "#ifdef" id IN NL) | (NL "#ifndef" id IN NL) | ("#ident" stringlit NL) | ("#include" stringlit NL) | ("#include" "<" SPOFF filepath ">" SPON NL) | ("#line" integernumber stringlit? NL) | ("#undef" id NL) | ("#LINK" stringlit NL) ;
sc_specifier ::= "auto" | "register" | "static" | "extern" | "typedef" ;
reference ::= reference_id | reference_expression ;
unlabeled_statement ::= expression_statement | if_statement | for_statement | while_statement | switch_statement | do_statement | null_statement | jump_statement | compound_statement ;
declaration_body ::= (decl_specifiers init_declarator+) | enum_specifier | struct_or_union_specifier ;
compound_statement_body ::= (statement* EX) | (declaration compound_statement_body) ;
enum_specifier ::= ("enum" tagged_reference_id? "{" {enumerator ","}* "}") | ("enum" tagged_reference_id) ;
--------------------cpp::iso-n2723.bgf--------------------
braced-init-list ::= ("{" initializer-list ","? "}") | ("{" "}") ;
iteration-statement ::= ("while" "(" condition ")" statement) | ("do" statement "while" "(" expression ")" ";") | ("for" "(" for-init-statement condition? ";" expression? ")" statement) ;
new-declarator ::= (ptr-operator new-declarator?) | direct-new-declarator ;
logical-or-expression ::= logical-and-expression | (logical-or-expression "||" logical-and-expression) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) ;
init-declarator-list ::= init-declarator | (init-declarator-list "," init-declarator) ;
type-id-list ::= (type-id "..."?) | (type-id-list "," type-id "..."?) ;
enumerator-definition ::= enumerator | (enumerator "=" constant-expression) ;
exception-declaration ::= (type-specifier-seq declarator) | (type-specifier-seq abstract-declarator) | type-specifier-seq | "..." ;
linkage-specification ::= ("extern" string-literal "{" declaration-seq? "}") | ("extern" string-literal declaration) ;
lambda-parameter-declaration-list ::= lambda-parameter | (lambda-parameter "," lambda-parameter-declaration-list) ;
delete-expression ::= ("::"? "delete" cast-expression) | ("::"? "delete" "[" "]" cast-expression) ;
declaration ::= block-declaration | function-definition | template-declaration | explicit-instantiation | explicit-specialization | linkage-specification | namespace-definition ;
function-body ::= (ctor-initializer? compound-statement) | function-try-block ;
for-init-statement ::= expression-statement | simple-declaration ;
unary-expression ::= postfix-expression | ("++" cast-expression) | ("--" cast-expression) | (unary-operator cast-expression) | ("sizeof" unary-expression) | ("sizeof" "(" type-id ")") | ("sizeof" "..." "(" identifier ")") | ("alignof" "(" type-id ")") | new-expression | delete-expression ;
template-parameter-list ::= template-parameter | (template-parameter-list "," template-parameter) ;
enum-specifier ::= (enum-key identifier? enum-base? "{" enumerator-list? "}") | (enum-key identifier? enum-base? "{" enumerator-list "," "}") ;
postfix-expression ::= primary-expression | (postfix-expression "[" expression "]") | (postfix-expression "[" braced-init-list "]") | (postfix-expression "(" expression-list? ")") | (simple-type-specifier "(" expression-list? ")") | (typename-specifier "(" expression-list? ")") | (simple-type-specifier braced-init-list) | (typename-specifier braced-init-list) | (postfix-expression "." "template"? id-expression) | (postfix-expression "->" "template"? id-expression) | (postfix-expression "." pseudo-destructor-name) | (postfix-expression "->" pseudo-destructor-name) | (postfix-expression "++") | (postfix-expression "--") | ("dynamic_cast" "<" type-id ">" "(" expression ")") | ("static_cast" "<" type-id ">" "(" expression ")") | ("reinterpret_cast" "<" type-id ">" "(" expression ")") | ("const_cast" "<" type-id ">" "(" expression ")") | ("typeid" "(" expression ")") | ("typeid" "(" type-id ")") ;
ref-qualifier ::= "&" | "&&" ;
statement ::= labeled-statement | expression-statement | compound-statement | selection-statement | iteration-statement | jump-statement | declaration-statement | try-block ;
multiplicative-expression ::= pm-expression | (multiplicative-expression "*" pm-expression) | (multiplicative-expression "/" pm-expression) | (multiplicative-expression "%" pm-expression) ;
selection-statement ::= ("if" "(" condition ")" statement) | ("if" "(" condition ")" statement "else" statement) | ("switch" "(" condition ")" statement) ;
qualified-id ::= ("::"? nested-name-specifier "template"? unqualified-id) | ("::" identifier) | ("::" operator-function-id) | ("::" template-id) ;
type-specifier ::= simple-type-specifier | class-specifier | enum-specifier | elaborated-type-specifier | typename-specifier | cv-qualifier ;
mem-initializer ::= (mem-initializer-id "(" expression-list? ")") | (mem-initializer-id braced-init-list) ;
function-definition ::= (decl-specifier-seq? declarator function-body) | (decl-specifier-seq? declarator "=" "default" ";") | (decl-specifier-seq? declarator "=" "delete" ";") ;
pm-expression ::= cast-expression | (pm-expression ".*" cast-expression) | (pm-expression "->*" cast-expression) ;
cast-expression ::= unary-expression | ("(" type-id ")" cast-expression) ;
simple-type-specifier ::= ("::"? nested-name-specifier? type-name) | ("::"? nested-name-specifier "template" simple-template-id) | "char" | "char16_t" | "char32_t" | "wchar_t" | "bool" | "short" | "int" | "long" | "signed" | "unsigned" | "float" | "double" | "void" | "auto" | ("decltype" "(" expression ")") ;
new-expression ::= ("::"? "new" new-placement? new-type-id new-initializer?) | ("::"? "new" new-placement? "(" type-id ")" new-initializer?) ;
initializer ::= ("=" initializer-clause) | ("(" expression-list ")") | braced-init-list ;
direct-new-declarator ::= ("[" expression "]") | (direct-new-declarator "[" constant-expression "]") ;
mem-initializer-id ::= ("::"? nested-name-specifier? class-name) | identifier ;
decl-specifier ::= storage-class-specifier | type-specifier | function-specifier | "friend" | "typedef" | "constexpr" | alignment-specifier ;
direct-abstract-declarator ::= (direct-abstract-declarator? "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification?) | (direct-abstract-declarator? "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification? "->" type-id) | (direct-abstract-declarator? "[" constant-expression? "]") | ("(" abstract-declarator ")") ;
storage-class-specifier ::= "register" | "static" | "thread_local" | "extern" | "mutable" ;
type-parameter ::= ("class" "..."? identifier?) | ("class" identifier? "=" type-id) | ("typename" "..."? identifier?) | ("typename" identifier? "=" type-id) | ("template" "<" template-parameter-list ">" "class" "..."? identifier?) | ("template" "<" template-parameter-list ">" "class" identifier? "=" id-expression) ;
parameter-declaration ::= (decl-specifier-seq declarator) | (decl-specifier-seq declarator "=" assignment-expression) | (decl-specifier-seq abstract-declarator?) | (decl-specifier-seq abstract-declarator? "=" assignment-expression) ;
alignment-specifier ::= ("alignas" "(" constant-expression ")") | ("alignas" "(" type-id ")") ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
pseudo-destructor-name ::= ("::"? nested-name-specifier? type-name "::" "~" type-name) | ("::"? nested-name-specifier "template" simple-template-id "::" "~" type-name) | ("::"? nested-name-specifier? "~" type-name) ;
cv-qualifier ::= "const" | "volatile" ;
template-id ::= simple-template-id | (operator-function-id "<" template-argument-list? ">") ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
base-specifier-list ::= (base-specifier "..."?) | (base-specifier-list "," base-specifier "..."?) ;
member-declaration ::= (decl-specifier-seq? member-declarator-list? ";") | (function-definition ";"?) | ("::"? nested-name-specifier "template"? unqualified-id ";") | using-declaration | static_assert-declaration | template-declaration ;
parameter-declaration-clause ::= (parameter-declaration-list? "..."?) | (parameter-declaration-list "," "...") ;
capture ::= identifier | ("&" identifier) | "this" ;
capture-list ::= capture | (capture-list "," capture) ;
member-declarator ::= (declarator pure-specifier?) | (declarator constant-initializer?) | (identifier? ":" constant-expression) ;
primary-expression ::= literal | "this" | ("(" expression ")") | id-expression | lambda-expression ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
base-specifier ::= ("::"? nested-name-specifier? class-name) | ("virtual" access-specifier? "::"? nested-name-specifier? class-name) | (access-specifier "virtual"? "::"? nested-name-specifier? class-name) ;
lambda-capture ::= capture-default | capture-list | (capture-default "," capture-list) ;
class-name ::= identifier | simple-template-id ;
conditional-expression ::= logical-or-expression | (logical-or-expression "?" expression ":" assignment-expression) ;
type-name ::= class-name | enum-name | typedef-name ;
namespace-name ::= original-namespace-name | namespace-alias ;
abstract-declarator ::= (ptr-operator abstract-declarator?) | direct-abstract-declarator | "..." ;
elaborated-type-specifier ::= (class-key "::"? nested-name-specifier? identifier) | (class-key "::"? nested-name-specifier? "template"? simple-template-id) | (enum-key "::"? nested-name-specifier? identifier) ;
block-declaration ::= simple-declaration | asm-definition | namespace-alias-definition | using-declaration | using-directive | static_assert-declaration | alias-declaration ;
initializer-clause ::= assignment-expression | braced-init-list ;
capture-default ::= "&" | "=" ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
declarator-id ::= ("..."? id-expression) | ("::"? nested-name-specifier? class-name) ;
typename-specifier ::= ("typename" "::"? nested-name-specifier identifier) | ("typename" "::"? nested-name-specifier "template"? simple-template-id) ;
new-initializer ::= ("(" expression-list? ")") | braced-init-list ;
labeled-statement ::= (identifier ":" statement) | ("case" constant-expression ":" statement) | ("default" ":" statement) ;
parameter-declaration-list ::= parameter-declaration | (parameter-declaration-list "," parameter-declaration) ;
using-declaration ::= ("using" "typename"? "::"? nested-name-specifier unqualified-id ";") | ("using" "::" unqualified-id ";") ;
declarator ::= direct-declarator | (ptr-operator declarator) ;
template-argument ::= constant-expression | type-id | id-expression ;
initializer-list ::= (initializer-clause "..."?) | (initializer-list "," initializer-clause "..."?) ;
operator ::= "new" | "delete" | ("new" "[" "]") | ("delete" "[" "]") | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "(" | ")" | "[" | "]" ;
assignment-operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
ptr-operator ::= ("*" cv-qualifier-seq?) | "&" | "&&" | ("::"? nested-name-specifier "*" cv-qualifier-seq?) ;
mem-initializer-list ::= (mem-initializer "..."?) | (mem-initializer "," mem-initializer-list "..."?) ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
template-argument-list ::= (template-argument "..."?) | (template-argument-list "," template-argument "..."?) ;
condition ::= expression | (type-specifier-seq declarator "=" initializer-clause) | (type-specifier-seq declarator braced-init-list) ;
named-namespace-definition ::= original-namespace-definition | extension-namespace-definition ;
assignment-expression ::= conditional-expression | (logical-or-expression assignment-operator initializer-clause) | throw-expression ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
template-parameter ::= type-parameter | parameter-declaration ;
access-specifier ::= "private" | "protected" | "public" ;
class-head ::= (class-key identifier? base-clause?) | (class-key nested-name-specifier identifier base-clause?) | (class-key nested-name-specifier? simple-template-id base-clause?) ;
direct-declarator ::= declarator-id | (direct-declarator "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification?) | (direct-declarator "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification? "->" type-id) | (direct-declarator "[" constant-expression? "]") | ("(" declarator ")") ;
enum-key ::= "enum" | ("enum" "class") | ("enum" "struct") ;
logical-and-expression ::= inclusive-or-expression | (logical-and-expression "&&" inclusive-or-expression) ;
nested-name-specifier ::= (type-name "::") | (namespace-name "::") | (nested-name-specifier identifier "::") | (nested-name-specifier "template"? simple-template-id "::") ;
member-specification ::= (member-declaration member-specification?) | (access-specifier ":" member-specification?) ;
jump-statement ::= ("break" ";") | ("continue" ";") | ("return" expression? ";") | ("return" braced-init-list ";") | ("goto" identifier ";") ;
declaration-seq ::= declaration | (declaration-seq declaration) ;
class-key ::= "class" | "struct" | "union" ;
id-expression ::= unqualified-id | qualified-id ;
function-specifier ::= "inline" | "virtual" | "explicit" ;
enumerator-list ::= enumerator-definition | (enumerator-list "," enumerator-definition) ;
member-declarator-list ::= member-declarator | (member-declarator-list "," member-declarator) ;
namespace-definition ::= named-namespace-definition | unnamed-namespace-definition ;
unqualified-id ::= identifier | operator-function-id | conversion-function-id | ("~" class-name) | template-id ;
unary-operator ::= "*" | "&" | "+" | "-" | "!" | "~" ;
statement-seq ::= statement | (statement-seq statement) ;
--------------------cpp::bruneliere.bgf--------------------
Boolean ::= "true" | "false" ;
VisibilityKind ::= (vk_public::ε) | (vk_private::ε) | (vk_protected::ε) ;
--------------------cpp::elges-cordy.bgf--------------------
selection_statement ::= ("if" "(" expression ")" statement else_statement?) | ("switch" "(" expression ")" statement) ;
parenthesized_parameter_declaration_list ::= ("(" parameter_declaration_list ")") | ("(" parenthesized_parameter_declaration_list ")") ;
elaborated_type_specifier ::= (class_key "::"? nested_name_spec? class_name) | ("enum" "::"? nested_name_spec? id) ;
declaration ::= asm_declaration | class_definition | function_definition | namespace_definition | template_declaration | linkage_specification | exception_specification | using_declaration | (decl_specifiers? declarator_list ";" NL) | (decl_specifiers ";" NL) | (";" NL) | (preprocessor NL) ;
type_specifier ::= simple_type_name | class_specifier | enum_specifier | elaborated_type_specifier | const_volatile_qualifier ;
declared_item ::= declared_name | ("(" declarator ")") ;
deallocation_expression ::= ("::"? "delete" cast_expression) | ("::"? "delete" "[" expression? "]" cast_expression) ;
class_component ::= class_name | ("~" SPOFF class_name SPON) | operator_function_name | conversion_function_name | qualified_name ;
member_declarator ::= (declarator initializer?) | (id? SPOFF ":" SPON constant_expression) ;
primary_expression ::= literal | "this" | ("::" id) | ("::" operator_function_name) | ("(" expression ")") | name ;
postfix_extension ::= ("[" expression? "]") | ("(" expression_list? ")") | ("." name) | ("->" name) | "++" | "--" ;
label ::= (id SPOFF ":" SPON) | (EX "case" constant_expression SPOFF ":" SPON NL IN) | (EX "default" SPOFF ":" SPON NL IN) ;
storage_class_specifier ::= "auto" | "register" | "static" | "extern" ;
allocation_declarator ::= allocation_array_declarator | ("*" const_volatile_qualifier_list? allocation_declarator?) | ("::"? nested_name_spec "*" const_volatile_qualifier_list? allocation_declarator?) | (qualified_name "::" "*" const_volatile_qualifier_list? allocation_declarator?) ;
declared_name ::= (nested_name_spec? name) | ("~" SPOFF id SPON) ;
abstract_declarator ::= (abstract_extension+) | ("(" abstract_declarator ")" abstract_extension*) ;
decl_specifier ::= storage_class_specifier | type_specifier | function_specifier | "friend" | "typedef" ;
pointer_operator ::= (stars const_volatile_qualifier_list?) | ("&" const_volatile_qualifier_list?) | (id "::" stars const_volatile_qualifier_list?) | ("::"? nested_name_spec "*" const_volatile_qualifier_list) ;
template_argument ::= type_name | non_gt_binary_expression ;
initializer ::= ("=" initial_value) | ("(" expression_list? ")") ;
abstract_extension ::= ("(" parameter_declaration_list ")" const_volatile_qualifier_list?) | ("[" constant_expression? "]") | pointer_operator | ("(" abstract_declarator ")") ;
stars ::= "*" | "**" ;
template_argument_list ::= template_argument | (template_argument_list "," template_argument) ;
number_constant ::= ("-"? number) | hexnumber ;
template_parameter_list ::= template_parameter | (template_parameter_list "," template_parameter) ;
for_body ::= compound_statement | (IN NL statement EX) ;
allocation_array_declarator ::= ("[" expression? "]") | (allocation_array_declarator "[" expression? "]") ;
assignment_operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
member_declaration ::= (function_definition ";"?) | (qualified_name ";" NL) | using_declaration | (decl_specifiers? member_declarator_list ";" NL) | (decl_specifiers ";" NL) | (";" NL) | (preprocessor NL) ;
allocation_type_name ::= (type_specifiers allocation_declarator?) | ("(" type_name ")" allocation_declarator?) ;
base_specifier ::= ("::"? nested_name_spec? class_name) | ("virtual" access_specifier? "::"? nested_name_spec? class_name) | (access_specifier "virtual"? "::"? nested_name_spec? class_name) ;
preprocessor ::= ("#define" id "(" id+ ")" expression) | ("#define" id expression) | (EX "#else" IN) | (EX "#endif" NL) | (NL "#if" expression IN) | (NL "#ifdef" id IN) | (NL "#ifndef" id IN) | ("#ident" stringlit) | ("#include" stringlit) | ("#include" "<" SPOFF filename ">" SPON) | ("#line" integernumber stringlit?) | ("#undef" id) | ("#LINK" stringlit) ;
file_identifier ::= id | key ;
assignment_expression ::= conditional_expression | (unary_expression assignment_operator assignment_expression) ;
unlabeled_statement ::= null_statement | expression_statement | compound_statement | selection_statement | iteration_statement | jump_statement | declaration_statement | try_block ;
class_head ::= (class_key id? base_spec?) | (class_key nested_name_spec id base_spec?) | (class_key class_name base_spec?) ;
class_or_namespace_name ::= class_name | namespace_name ;
using_declaration ::= ("using" "::"? nested_name_spec? name ";") | ("using" "namespace" "::"? nested_name_spec? id ";") ;
namespace_definition ::= ("namespace" id? "{" NL IN declaration_list? EX "}" NL NL) | ("namespace" id "=" qualified_namespace_spec) ;
initial_value ::= assignment_expression | ("{" IN initializer_list ","? EX "}") ;
for_init_statement ::= (expression ";") | (decl_specifiers? declarator_list ";") | (decl_specifiers ";") | ";" ;
unary_operator ::= "**" | "*" | "&" | "+" | "-" | "!" | "~" ;
declarator_extension ::= (parenthesized_parameter_declaration_list const_volatile_qualifier_list?) | ("[" constant_expression? "]") ;
literal ::= number_constant | character_constant | string_constant ;
function_body ::= (NL compound_statement ";"? NL) | ("try" ctor_initializer? NL compound_statement ";"? NL handler_list) ;
unary_expression ::= postfix_expression | ("++" unary_expression) | ("--" unary_expression) | (unary_operator cast_expression) | ("sizeof" unary_expression) | ("sizeof" "(" type_name ")") | allocation_expression | deallocation_expression | throw_expression ;
operator ::= "new" | "delete" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "-+" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | ("(" type_specifier? ")") | ("[" "]") ;
template_parameter ::= type_parameter | parameter_declaration ;
access_specifier ::= "private" | "protected" | "public" ;
const_volatile_qualifier ::= "const" | "volatile" ;
simple_type_name ::= "char" | "bool" | "short" | "int" | "long" | "signed" | "unsigned" | "float" | "double" | "void" | ("::"? nested_name_spec? id) | ("::"? nested_name_spec? template_class_name) ;
binary_operator ::= "||" | "&&" | "|" | "^" | "&" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "<<" | ">>" | "+" | "-" | "*" | "/" | "%" | ".*" | "->*" ;
postfix_expression ::= (primary_expression postfix_extension*) | (simple_type_name "(" expression_list? ")" postfix_extension*) ;
exception_declarator ::= declarator | abstract_declarator ;
initializer_element ::= assignment_expression | (NL "{" IN initializer_list ","? EX "}") ;
jump_statement ::= ("break" ";" NL) | ("continue" ";" NL) | ("return" expression? ";" NL) | ("goto" id ";" NL) ;
expression ::= assignment_expression | (expression "," assignment_expression) ;
cast_expression ::= unary_expression | ("(" type_name ")" cast_expression) ;
class_key ::= "class" | "struct" | "union" ;
function_specifier ::= "inline" | "virtual" ;
iteration_statement ::= ("while" "(" expression ")" statement) | ("do" statement "while" "(" expression ")" ";" NL) | ("for" "(" for_init_statement expression? ";" expression? ")" for_body) ;
name ::= id | template_class_name | qualified_name | operator_function_name | conversion_function_name ;
exception_declaration ::= (type_specifiers exception_declarator?) | "..." ;
linkage_specification ::= (NL "extern" stringlit "{" NL IN declaration_list EX "}" ";"? NL NL) | ("extern" stringlit declaration) ;
parameter_declarator ::= declarator | (abstract_declarator?) ;
type_list ::= type_name | (type_list "," type_name) ;
non_gt_binary_operator ::= "||" | "&&" | "|" | "^" | "&" | "==" | "!=" | "<" | "<=" | ">=" | "<<" | ">>" | "+" | "-" | "*" | "/" | "%" | ".*" | "->*" ;
--------------------cpp::iso-14882-1998.bgf--------------------
iteration-statement ::= ("while" "(" condition ")" statement) | ("do" statement "while" "(" expression ")" ";") | ("for" "(" for-init-statement condition? ";" expression? ")" statement) ;
new-declarator ::= (ptr-operator new-declarator?) | direct-new-declarator ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) ;
logical-or-expression ::= logical-and-expression | (logical-or-expression "||" logical-and-expression) ;
init-declarator-list ::= init-declarator | (init-declarator-list "," init-declarator) ;
type-id-list ::= type-id | (type-id-list "," type-id) ;
enumerator-definition ::= enumerator | (enumerator "=" constant-expression) ;
exception-declaration ::= (type-specifier-seq declarator) | (type-specifier-seq abstract-declarator) | type-specifier-seq | "..." ;
linkage-specification ::= ("extern" string-literal "{" declaration-seq? "}") | ("extern" string-literal declaration) ;
delete-expression ::= ("::"? "delete" cast-expression) | ("::"? "delete" "[" "]" cast-expression) ;
declaration ::= block-declaration | function-definition | template-declaration | explicit-instantiation | explicit-specialization | linkage-specification | namespace-definition ;
for-init-statement ::= expression-statement | simple-declaration ;
unary-expression ::= postfix-expression | ("++" cast-expression) | ("--" cast-expression) | (unary-operator cast-expression) | ("sizeof" unary-expression) | ("sizeof" "(" type-id ")") | new-expression | delete-expression ;
template-parameter-list ::= template-parameter | (template-parameter-list "," template-parameter) ;
postfix-expression ::= primary-expression | (postfix-expression "[" expression "]") | (postfix-expression "(" expression-list? ")") | (simple-type-specifier "(" expression-list? ")") | ("typename" "::"? nested-name-specifier identifier "(" expression-list? ")") | ("typename" "::"? nested-name-specifier "template"? template-id "(" expression-list? ")") | (postfix-expression "." "template"? id-expression) | (postfix-expression "->" "template"? id-expression) | (postfix-expression "." pseudo-destructor-name) | (postfix-expression "->" pseudo-destructor-name) | (postfix-expression "++") | (postfix-expression "--") | ("dynamic_cast" "<" type-id ">" "(" expression ")") | ("static_cast" "<" type-id ">" "(" expression ")") | ("reinterpret_cast" "<" type-id ">" "(" expression ")") | ("const_cast" "<" type-id ">" "(" expression ")") | ("typeid" "(" expression ")") | ("typeid" "(" type-id ")") ;
statement ::= labeled-statement | expression-statement | compound-statement | selection-statement | iteration-statement | jump-statement | declaration-statement | try-block ;
multiplicative-expression ::= pm-expression | (multiplicative-expression "*" pm-expression) | (multiplicative-expression "/" pm-expression) | (multiplicative-expression "%" pm-expression) ;
selection-statement ::= ("if" "(" condition ")" statement) | ("if" "(" condition ")" statement "else" statement) | ("switch" "(" condition ")" statement) ;
qualified-id ::= ("::"? nested-name-specifier "template"? unqualified-id) | ("::" identifier) | ("::" operator-function-id) | ("::" template-id) ;
type-specifier ::= simple-type-specifier | class-specifier | enum-specifier | elaborated-type-specifier | cv-qualifier ;
function-definition ::= (decl-specifier-seq? declarator ctor-initializer? function-body) | (decl-specifier-seq? declarator function-try-block) ;
pm-expression ::= cast-expression | (pm-expression ".*" cast-expression) | (pm-expression "->*" cast-expression) ;
cast-expression ::= unary-expression | ("(" type-id ")" cast-expression) ;
simple-type-specifier ::= ("::"? nested-name-specifier? type-name) | ("::"? nested-name-specifier "template" template-id) | "char" | "wchar_t" | "bool" | "short" | "int" | "long" | "signed" | "unsigned" | "float" | "double" | "void" ;
new-expression ::= ("::"? "new" new-placement? new-type-id new-initializer?) | ("::"? "new" new-placement? "(" type-id ")" new-initializer?) ;
initializer ::= ("=" initializer-clause) | ("(" expression-list ")") ;
direct-new-declarator ::= ("[" expression "]") | (direct-new-declarator "[" constant-expression "]") ;
mem-initializer-id ::= ("::"? nested-name-specifier? class-name) | identifier ;
decl-specifier ::= storage-class-specifier | type-specifier | function-specifier | "friend" | "typedef" ;
direct-abstract-declarator ::= (direct-abstract-declarator? "(" parameter-declaration-clause ")" cv-qualifier-seq? exception-specification?) | (direct-abstract-declarator? "[" constant-expression? "]") | ("(" abstract-declarator ")") ;
storage-class-specifier ::= "auto" | "register" | "static" | "extern" | "mutable" ;
type-parameter ::= ("class" identifier?) | ("class" identifier? "=" type-id) | ("typename" identifier?) | ("typename" identifier? "=" type-id) | ("template" "<" template-parameter-list ">" "class" identifier?) | ("template" "<" template-parameter-list ">" "class" identifier? "=" id-expression) ;
parameter-declaration ::= (decl-specifier-seq declarator) | (decl-specifier-seq declarator "=" assignment-expression) | (decl-specifier-seq abstract-declarator?) | (decl-specifier-seq abstract-declarator? "=" assignment-expression) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
class-or-namespace-name ::= class-name | namespace-name ;
pseudo-destructor-name ::= ("::"? nested-name-specifier? type-name "::" "~" type-name) | ("::"? nested-name-specifier "template" template-id "::" "~" type-name) | ("::"? nested-name-specifier? "~" type-name) ;
cv-qualifier ::= "const" | "volatile" ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
base-specifier-list ::= base-specifier | (base-specifier-list "," base-specifier) ;
member-declaration ::= (decl-specifier-seq? member-declarator-list? ";") | (function-definition ";"?) | ("::"? nested-name-specifier "template"? unqualified-id ";") | using-declaration | template-declaration ;
parameter-declaration-clause ::= (parameter-declaration-list? "..."?) | (parameter-declaration-list "," "...") ;
member-declarator ::= (declarator pure-specifier?) | (declarator constant-initializer?) | (identifier? ":" constant-expression) ;
primary-expression ::= literal | "this" | ("(" expression ")") | id-expression ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
base-specifier ::= ("::"? nested-name-specifier? class-name) | ("virtual" access-specifier? "::"? nested-name-specifier? class-name) | (access-specifier "virtual"? "::"? nested-name-specifier? class-name) ;
class-name ::= identifier | template-id ;
conditional-expression ::= logical-or-expression | (logical-or-expression "?" expression ":" assignment-expression) ;
type-name ::= class-name | enum-name | typedef-name ;
namespace-name ::= original-namespace-name | namespace-alias ;
abstract-declarator ::= (ptr-operator abstract-declarator?) | direct-abstract-declarator ;
elaborated-type-specifier ::= (class-key "::"? nested-name-specifier? identifier) | ("enum" "::"? nested-name-specifier? identifier) | ("typename" "::"? nested-name-specifier identifier) | ("typename" "::"? nested-name-specifier "template"? template-id) ;
initializer-clause ::= assignment-expression | ("{" initializer-list ","? "}") | ("{" "}") ;
block-declaration ::= simple-declaration | asm-definition | namespace-alias-definition | using-declaration | using-directive ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
declarator-id ::= id-expression | ("::"? nested-name-specifier? type-name) ;
labeled-statement ::= (identifier ":" statement) | ("case" constant-expression ":" statement) | ("default" ":" statement) ;
parameter-declaration-list ::= parameter-declaration | (parameter-declaration-list "," parameter-declaration) ;
expression-list ::= assignment-expression | (expression-list "," assignment-expression) ;
using-declaration ::= ("using" "typename"? "::"? nested-name-specifier unqualified-id ";") | ("using" "::" unqualified-id ";") ;
declarator ::= direct-declarator | (ptr-operator declarator) ;
template-argument ::= assignment-expression | type-id | id-expression ;
initializer-list ::= initializer-clause | (initializer-list "," initializer-clause) ;
assignment-operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
operator ::= "new" | "delete" | ("new" "[" "]") | ("delete" "[" "]") | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | ("(" ")") | ("[" "]") ;
ptr-operator ::= ("*" cv-qualifier-seq?) | "&" | ("::"? nested-name-specifier "*" cv-qualifier-seq?) ;
mem-initializer-list ::= mem-initializer | (mem-initializer "," mem-initializer-list) ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
condition ::= expression | (type-specifier-seq declarator "=" assignment-expression) ;
template-argument-list ::= template-argument | (template-argument-list "," template-argument) ;
named-namespace-definition ::= original-namespace-definition | extension-namespace-definition ;
expression ::= assignment-expression | (expression "," assignment-expression) ;
assignment-expression ::= conditional-expression | (logical-or-expression assignment-operator assignment-expression) | throw-expression ;
template-parameter ::= type-parameter | parameter-declaration ;
access-specifier ::= "private" | "protected" | "public" ;
class-head ::= (class-key identifier? base-clause?) | (class-key nested-name-specifier identifier base-clause?) | (class-key nested-name-specifier? template-id base-clause?) ;
direct-declarator ::= declarator-id | (direct-declarator "(" parameter-declaration-clause ")" cv-qualifier-seq? exception-specification?) | (direct-declarator "[" constant-expression? "]") | ("(" declarator ")") ;
logical-and-expression ::= inclusive-or-expression | (logical-and-expression "&&" inclusive-or-expression) ;
nested-name-specifier ::= (class-or-namespace-name "::" nested-name-specifier?) | (class-or-namespace-name "::" "template" nested-name-specifier) ;
jump-statement ::= ("break" ";") | ("continue" ";") | ("return" expression? ";") | ("goto" identifier ";") ;
member-specification ::= (member-declaration member-specification?) | (access-specifier ":" member-specification?) ;
declaration-seq ::= declaration | (declaration-seq declaration) ;
class-key ::= "class" | "struct" | "union" ;
id-expression ::= unqualified-id | qualified-id ;
function-specifier ::= "inline" | "virtual" | "explicit" ;
enumerator-list ::= enumerator-definition | (enumerator-list "," enumerator-definition) ;
member-declarator-list ::= member-declarator | (member-declarator-list "," member-declarator) ;
namespace-definition ::= named-namespace-definition | unnamed-namespace-definition ;
unqualified-id ::= identifier | operator-function-id | conversion-function-id | ("~" class-name) | template-id ;
unary-operator ::= "*" | "&" | "+" | "-" | "!" | "~" ;
statement-seq ::= statement | (statement-seq statement) ;
--------------------cs::csharp-ecma-334-2.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier) | (predefined-type "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "while" | "assembly" | "remove" | "get" | "set" | "field" | "method" | "module" | "param" | "property" | "add" | "volatile" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "param" | "property" | "return" | type ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
selection-statement ::= if-statement | switch-statement ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= array-creation-expression | primary-no-array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= conditional-or-expression | (conditional-or-expression "?" expression ":" expression) ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
struct-type ::= type-name | simple-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= identifier | (namespace-or-type-name "." identifier) ;
--------------------cs::csharp-ecma-334-3.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier type-argument-list?) | (predefined-type "." identifier type-argument-list?) | (qualified-alias-member "." identifier type-argument-list?) ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
unbound-type-name ::= (identifier generic-dimension-specifier?) | (identifier "::" identifier generic-dimension-specifier?) | (unbound-type-name "." identifier generic-dimension-specifier?) ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement | yield-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "volatile" | "while" | "get" | "set" | "yield" | "add" | "remove" | "alias" | "partial" | "where" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= identifier | keyword ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier type-argument-list?) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block catch-clauses? finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
type-parameter-constraints-clauses ::= type-parameter-constraints-clause | (type-parameter-constraints-clauses type-parameter-constraints-clause) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= specific-catch-clauses | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= identifier | keyword ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression right-shift additive-expression) ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
type-parameter-constraints ::= primary-constraint | secondary-constraints | constructor-constraint | (primary-constraint "," secondary-constraints) | (primary-constraint "," constructor-constraint) | (secondary-constraints "," constructor-constraint) | (primary-constraint "," secondary-constraints "," constructor-constraint) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
finalizer-body ::= block | ";" ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression | default-value-expression | anonymous-method-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | right-shift-assignment ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
accessor-modifier ::= "protected" | "internal" | "private" | ("protected" "internal") | ("internal" "protected") ;
null-coalescing-expression ::= conditional-or-expression | (conditional-or-expression "??" null-coalescing-expression) ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" | "static" ;
primary-constraint ::= class-type | "class" | "struct" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
type-arguments ::= type-argument | (type-arguments "," type-argument) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
selection-statement ::= if-statement | switch-statement ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
secondary-constraints ::= interface-type | type-parameter | (secondary-constraints "," interface-type) | (secondary-constraints "," type-parameter) ;
type-parameters ::= (attributes? type-parameter) | (type-parameters "," attributes? type-parameter) ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" unbound-type-name ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
anonymous-method-parameter-list ::= anonymous-method-parameter | (anonymous-method-parameter-list "," anonymous-method-parameter) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= array-creation-expression | primary-no-array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= null-coalescing-expression | (null-coalescing-expression "?" expression ":" expression) ;
commas ::= "," | (commas ",") ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | finalizer-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type | type-parameter ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | right-shift | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
struct-type ::= type-name | simple-type | nullable-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
yield-statement ::= ("yield" "return" expression ";") | ("yield" "break" ";") ;
non-array-type ::= value-type | class-type | interface-type | delegate-type | type-parameter ;
extern-alias-directives ::= extern-alias-directive | (extern-alias-directives extern-alias-directive) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= (identifier type-argument-list?) | qualified-alias-member | (namespace-or-type-name "." identifier type-argument-list?) ;
non-nullable-value-type ::= enum-type | type-name | simple-type ;
--------------------cs::csharp-ecma-334-4.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier type-argument-list?) | (predefined-type "." identifier type-argument-list?) | (qualified-alias-member "." identifier type-argument-list?) ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
unbound-type-name ::= (identifier generic-dimension-specifier?) | (identifier "::" identifier generic-dimension-specifier?) | (unbound-type-name "." identifier generic-dimension-specifier?) ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement | yield-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "volatile" | "while" | "get" | "set" | "yield" | "add" | "remove" | "alias" | "partial" | "where" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= identifier | keyword ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier type-argument-list?) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block catch-clauses? finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
type-parameter-constraints-clauses ::= type-parameter-constraints-clause | (type-parameter-constraints-clauses type-parameter-constraints-clause) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= specific-catch-clauses | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= identifier | keyword ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression right-shift additive-expression) ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
type-parameter-constraints ::= primary-constraint | secondary-constraints | constructor-constraint | (primary-constraint "," secondary-constraints) | (primary-constraint "," constructor-constraint) | (secondary-constraints "," constructor-constraint) | (primary-constraint "," secondary-constraints "," constructor-constraint) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
finalizer-body ::= block | ";" ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression | default-value-expression | anonymous-method-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | right-shift-assignment ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
accessor-modifier ::= "protected" | "internal" | "private" | ("protected" "internal") | ("internal" "protected") ;
null-coalescing-expression ::= conditional-or-expression | (conditional-or-expression "??" null-coalescing-expression) ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" | "static" ;
primary-constraint ::= class-type | "class" | "struct" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
type-arguments ::= type-argument | (type-arguments "," type-argument) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
class-type ::= type-name | "object" | "string" ;
selection-statement ::= if-statement | switch-statement ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
type-parameters ::= (attributes? type-parameter) | (type-parameters "," attributes? type-parameter) ;
secondary-constraints ::= interface-type | type-parameter | (secondary-constraints "," interface-type) | (secondary-constraints "," type-parameter) ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" unbound-type-name ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
anonymous-method-parameter-list ::= anonymous-method-parameter | (anonymous-method-parameter-list "," anonymous-method-parameter) ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= array-creation-expression | primary-no-array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= null-coalescing-expression | (null-coalescing-expression "?" expression ":" expression) ;
commas ::= "," | (commas ",") ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | finalizer-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type | type-parameter ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | right-shift | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
struct-type ::= type-name | simple-type | nullable-type ;
yield-statement ::= ("yield" "return" expression ";") | ("yield" "break" ";") ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
non-array-type ::= value-type | class-type | interface-type | delegate-type | type-parameter ;
extern-alias-directives ::= extern-alias-directive | (extern-alias-directives extern-alias-directive) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= (identifier type-argument-list?) | qualified-alias-member | (namespace-or-type-name "." identifier type-argument-list?) ;
non-nullable-value-type ::= enum-type | type-name | simple-type ;
--------------------cs::csharp-iso-23270-2003.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier) | (predefined-type "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | ("*" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "module" | "param" | "property" | "return" | "type" ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
dim-separators ::= "," | (dim-separators ",") ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
selection-statement ::= if-statement | switch-statement ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= array-creation-expression | primary-no-array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= conditional-or-expression | (conditional-or-expression "?" expression ":" expression) ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
struct-type ::= type-name | simple-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= identifier | (namespace-or-type-name "." identifier) ;
--------------------cs::csharp-iso-23270-2006.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier type-argument-list?) | (predefined-type "." identifier type-argument-list?) | (qualified-alias-member "." identifier type-argument-list?) ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
unbound-type-name ::= (identifier generic-dimension-specifier?) | (identifier "::" identifier generic-dimension-specifier?) | (unbound-type-name "." identifier generic-dimension-specifier?) ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement | yield-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
keyword ::= "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch" | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default" | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit" | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach" | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is" | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator" | "out" | "override" | "params" | "private" | "protected" | "public" | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof" | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw" | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe" | "ushort" | "using" | "virtual" | "void" | "volatile" | "while" | "yield" | "partial" | "add" | "remove" | "get" | "set" | "where" | "alias" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= identifier | keyword ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier type-argument-list?) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block catch-clauses? finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
type-parameter-constraints-clauses ::= type-parameter-constraints-clause | (type-parameter-constraints-clauses type-parameter-constraints-clause) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= specific-catch-clauses | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= identifier | keyword ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression right-shift additive-expression) ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
type-parameter-constraints ::= primary-constraint | secondary-constraints | constructor-constraint | (primary-constraint "," secondary-constraints) | (primary-constraint "," constructor-constraint) | (secondary-constraints "," constructor-constraint) | (primary-constraint "," secondary-constraints "," constructor-constraint) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
finalizer-body ::= block | ";" ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression | default-value-expression | anonymous-method-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | right-shift-assignment ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
accessor-modifier ::= "protected" | "internal" | "private" | ("protected" "internal") | ("internal" "protected") ;
null-coalescing-expression ::= conditional-or-expression | (conditional-or-expression "??" null-coalescing-expression) ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" | "static" ;
primary-constraint ::= class-type | "class" | "struct" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
type-arguments ::= type-argument | (type-arguments "," type-argument) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
selection-statement ::= if-statement | switch-statement ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
secondary-constraints ::= interface-type | type-parameter | (secondary-constraints "," interface-type) | (secondary-constraints "," type-parameter) ;
type-parameters ::= (attributes? type-parameter) | (type-parameters "," attributes? type-parameter) ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" unbound-type-name ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
anonymous-method-parameter-list ::= anonymous-method-parameter | (anonymous-method-parameter-list "," anonymous-method-parameter) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= array-creation-expression | primary-no-array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= null-coalescing-expression | (null-coalescing-expression "?" expression ":" expression) ;
commas ::= "," | (commas ",") ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | finalizer-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type | type-parameter ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | right-shift | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
struct-type ::= type-name | simple-type | nullable-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
yield-statement ::= ("yield" "return" expression ";") | ("yield" "break" ";") ;
non-array-type ::= value-type | class-type | interface-type | delegate-type | type-parameter ;
extern-alias-directives ::= extern-alias-directive | (extern-alias-directives extern-alias-directive) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= (identifier type-argument-list?) | qualified-alias-member | (namespace-or-type-name "." identifier type-argument-list?) ;
non-nullable-value-type ::= enum-type | type-name | simple-type ;
--------------------cs::csharp-msft-ls-1.0.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier) | (predefined-type "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "param" | "property" | "return" | type ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" expression-list "]") ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
member-name ::= identifier | (interface-type "." identifier) ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= "assembly" | "module" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
simple-type ::= numeric-type | "bool" ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
selection-statement ::= if-statement | switch-statement ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
primary-expression ::= primary-no-array-creation-expression | array-creation-expression ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= conditional-or-expression | (conditional-or-expression "?" expression ":" expression) ;
statement-list ::= statement | (statement-list statement) ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
type ::= value-type | reference-type ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
delegate-declaration ::= (attributes? delegate-modifiers? "delegate" return-type identifier) | ("(" formal-parameter-list? ")" ";") ;
struct-type ::= type-name | simple-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
namespace-or-type-name ::= identifier | (namespace-or-type-name "." identifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
--------------------cs::csharp-msft-ls-1.2.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier) | (predefined-type "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "param" | "property" | "return" | type ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" expression-list "]") ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
member-name ::= identifier | (interface-type "." identifier) ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= "assembly" | "module" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
simple-type ::= numeric-type | "bool" ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
selection-statement ::= if-statement | switch-statement ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
primary-expression ::= primary-no-array-creation-expression | array-creation-expression ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= conditional-or-expression | (conditional-or-expression "?" expression ":" expression) ;
statement-list ::= statement | (statement-list statement) ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
type ::= value-type | reference-type ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
delegate-declaration ::= (attributes? delegate-modifiers? "delegate" return-type identifier) | ("(" formal-parameter-list? ")" ";") ;
struct-type ::= type-name | simple-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
namespace-or-type-name ::= identifier | (namespace-or-type-name "." identifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
--------------------cs::csharp-msft-ls-3.0.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
method-header ::= (attributes? method-modifiers? "partial"? return-type member-name type-parameter-list?) | ("(" formal-parameter-list? ")" type-parameter-constraints-clauses?) ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier type-argument-list?) | (predefined-type "." identifier type-argument-list?) | (qualified-alias-member "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
unbound-type-name ::= (identifier generic-dimension-specifier?) | (identifier "::" identifier generic-dimension-specifier?) | (unbound-type-name "." identifier generic-dimension-specifier?) ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement | yield-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
interface-declaration ::= (attributes? interface-modifiers? "partial"? "interface" identifier type-parameter-list?) | (interface-base? type-parameter-constraints-clauses? interface-body ";"?) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "param" | "property" | "return" | type ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
type-parameter-constraints-clauses ::= type-parameter-constraints-clause | (type-parameter-constraints-clauses type-parameter-constraints-clause) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) | ("new" rank-specifier array-initializer) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= "assembly" | "module" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
initializer-value ::= expression | object-or-collection-initializer ;
ordering-direction ::= "ascending" | "descending" ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression right-shift additive-expression) ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
type-parameter-constraints ::= primary-constraint | secondary-constraints | constructor-constraint | (primary-constraint "," secondary-constraints) | (primary-constraint "," constructor-constraint) | (secondary-constraints "," constructor-constraint) | (primary-constraint "," secondary-constraints "," constructor-constraint) ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
object-creation-expression ::= ("new" type "(" argument-list? ")" object-or-collection-initializer?) | ("new" type object-or-collection-initializer) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
anonymous-object-initializer ::= ("{" member-declarator-list? "}") | ("{" member-declarator-list "," "}") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | anonymous-object-creation-expression | typeof-expression | checked-expression | unchecked-expression | default-value-expression | anonymous-method-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
class-declaration ::= (attributes? class-modifiers? "partial"? "class" identifier type-parameter-list?) | (class-base? type-parameter-constraints-clauses? class-body ";"?) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | right-shift-assignment ;
interface-method-declaration ::= (attributes? "new"? return-type identifier type-parameter-list) | ("(" formal-parameter-list? ")" type-parameter-constraints-clauses? ";") ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
query-body-clauses ::= query-body-clause | (query-body-clauses query-body-clause) ;
accessor-modifier ::= "protected" | "internal" | "private" | ("protected" "internal") | ("internal" "protected") ;
null-coalescing-expression ::= conditional-or-expression | (conditional-or-expression "??" null-coalescing-expression) ;
non-assignment-expression ::= conditional-expression | lambda-expression | query-expression ;
expression ::= non-assignment-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
element-initializer ::= non-assignment-expression | ("{" expression-list "}") ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
implicit-anonymous-function-parameter-list ::= implicit-anonymous-function-parameter | (implicit-anonymous-function-parameter-list "," implicit-anonymous-function-parameter) ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" | "static" ;
primary-constraint ::= class-type | "class" | "struct" ;
member-declarator-list ::= member-declarator | (member-declarator-list "," member-declarator) ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
type-arguments ::= type-argument | (type-arguments "," type-argument) ;
struct-declaration ::= (attributes? struct-modifiers? "partial"? "struct" identifier type-parameter-list?) | (struct-interfaces? type-parameter-constraints-clauses? struct-body ";"?) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
member-initializer-list ::= member-initializer | (member-initializer-list "," member-initializer) ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" | "this" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
query-body-clause ::= from-clause | let-clause | where-clause | join-clause | join-into-clause | orderby-clause ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
class-type ::= type-name | "object" | "string" ;
selection-statement ::= if-statement | switch-statement ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
anonymous-function-signature ::= explicit-anonymous-function-signature | implicit-anonymous-function-signature ;
type-parameters ::= (attributes? type-parameter) | (type-parameters "," attributes? type-parameter) ;
secondary-constraints ::= interface-type | type-parameter | (secondary-constraints "," interface-type) | (secondary-constraints "," type-parameter) ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
element-initializer-list ::= element-initializer | (element-initializer-list "," element-initializer) ;
select-or-group-clause ::= select-clause | group-clause ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" unbound-type-name ")") | ("typeof" "(" "void" ")") ;
object-initializer ::= ("{" member-initializer-list? "}") | ("{" member-initializer-list "," "}") ;
object-or-collection-initializer ::= object-initializer | collection-initializer ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
compilation-unit ::= (extern-alias-directives? using-directives? global-attributes?) | (namespace-member-declarations?) ;
implicit-anonymous-function-signature ::= ("(" implicit-anonymous-function-parameter-list? ")") | implicit-anonymous-function-parameter ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
member-declarator ::= simple-name | member-access | (identifier "=" expression) ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= primary-no-array-creation-expression | array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= null-coalescing-expression | (null-coalescing-expression "?" expression ":" expression) ;
commas ::= "," | (commas ",") ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type | type-parameter ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | right-shift | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
collection-initializer ::= ("{" element-initializer-list "}") | ("{" element-initializer-list "," "}") ;
local-variable-initializer ::= expression | array-initializer ;
delegate-declaration ::= (attributes? delegate-modifiers? "delegate" return-type identifier type-parameter-list?) | ("(" formal-parameter-list? ")" type-parameter-constraints-clauses? ";") ;
struct-type ::= type-name | simple-type | nullable-type ;
anonymous-function-parameter-modifier ::= "ref" | "out" ;
yield-statement ::= ("yield" "return" expression ";") | ("yield" "break" ";") ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
extern-alias-directives ::= extern-alias-directive | (extern-alias-directives extern-alias-directive) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
orderings ::= ordering | (orderings "," ordering) ;
explicit-anonymous-function-parameter-list ::= explicit-anonymous-function-parameter | (explicit-anonymous-function-parameter-list "," explicit-anonymous-function-parameter) ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
anonymous-function-body ::= expression | block ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
local-variable-type ::= type | "var" ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= (identifier type-argument-list?) | (namespace-or-type-name "." identifier type-argument-list?) | qualified-alias-member ;
--------------------cs::csharp-msft-ls-4.0.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
method-header ::= (attributes? method-modifiers? "partial"? return-type member-name type-parameter-list?) | ("(" formal-parameter-list? ")" type-parameter-constraints-clauses?) ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier type-argument-list?) | (predefined-type "." identifier type-argument-list?) | (qualified-alias-member "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
unbound-type-name ::= (identifier generic-dimension-specifier?) | (identifier "::" identifier generic-dimension-specifier?) | (unbound-type-name "." identifier generic-dimension-specifier?) ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement | yield-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
interface-declaration ::= (attributes? interface-modifiers? "partial"? "interface") | (identifier variant-type-parameter-list? interface-base?) | (type-parameter-constraints-clauses? interface-body ";"?) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "param" | "property" | "return" | type ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" argument-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
type-parameter-constraints-clauses ::= type-parameter-constraints-clause | (type-parameter-constraints-clauses type-parameter-constraints-clause) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) | ("new" rank-specifier array-initializer) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-target ::= "assembly" | "module" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations "}") ;
initializer-value ::= expression | object-or-collection-initializer ;
ordering-direction ::= "ascending" | "descending" ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression right-shift additive-expression) ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
type-parameter-constraints ::= primary-constraint | secondary-constraints | constructor-constraint | (primary-constraint "," secondary-constraints) | (primary-constraint "," constructor-constraint) | (secondary-constraints "," constructor-constraint) | (primary-constraint "," secondary-constraints "," constructor-constraint) ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
object-creation-expression ::= ("new" type "(" argument-list? ")" object-or-collection-initializer?) | ("new" type object-or-collection-initializer) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
anonymous-object-initializer ::= ("{" member-declarator-list? "}") | ("{" member-declarator-list "," "}") ;
expression-list ::= expression | (expression-list "," expression) ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | anonymous-object-creation-expression | typeof-expression | checked-expression | unchecked-expression | default-value-expression | anonymous-method-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
class-declaration ::= (attributes? class-modifiers? "partial"? "class" identifier type-parameter-list?) | (class-base? type-parameter-constraints-clauses? class-body ";"?) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | right-shift-assignment ;
interface-method-declaration ::= (attributes? "new"? return-type identifier type-parameter-list) | ("(" formal-parameter-list? ")" type-parameter-constraints-clauses? ";") ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
query-body-clauses ::= query-body-clause | (query-body-clauses query-body-clause) ;
accessor-modifier ::= "protected" | "internal" | "private" | ("protected" "internal") | ("internal" "protected") ;
null-coalescing-expression ::= conditional-or-expression | (conditional-or-expression "??" null-coalescing-expression) ;
non-assignment-expression ::= conditional-expression | lambda-expression | query-expression ;
expression ::= non-assignment-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
element-initializer ::= non-assignment-expression | ("{" expression-list "}") ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
implicit-anonymous-function-parameter-list ::= implicit-anonymous-function-parameter | (implicit-anonymous-function-parameter-list "," implicit-anonymous-function-parameter) ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" | "static" ;
primary-constraint ::= class-type | "class" | "struct" ;
member-declarator-list ::= member-declarator | (member-declarator-list "," member-declarator) ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
type-arguments ::= type-argument | (type-arguments "," type-argument) ;
struct-declaration ::= (attributes? struct-modifiers? "partial"? "struct" identifier type-parameter-list?) | (struct-interfaces? type-parameter-constraints-clauses? struct-body ";"?) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
member-initializer-list ::= member-initializer | (member-initializer-list "," member-initializer) ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" | "this" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
query-body-clause ::= from-clause | let-clause | where-clause | join-clause | join-into-clause | orderby-clause ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
class-type ::= type-name | "object" | "dynamic" | "string" ;
selection-statement ::= if-statement | switch-statement ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
anonymous-function-signature ::= explicit-anonymous-function-signature | implicit-anonymous-function-signature ;
argument-value ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
type-parameters ::= (attributes? type-parameter) | (type-parameters "," attributes? type-parameter) ;
secondary-constraints ::= interface-type | type-parameter | (secondary-constraints "," interface-type) | (secondary-constraints "," type-parameter) ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
element-initializer-list ::= element-initializer | (element-initializer-list "," element-initializer) ;
select-or-group-clause ::= select-clause | group-clause ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" unbound-type-name ")") | ("typeof" "(" "void" ")") ;
object-initializer ::= ("{" member-initializer-list? "}") | ("{" member-initializer-list "," "}") ;
object-or-collection-initializer ::= object-initializer | collection-initializer ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
compilation-unit ::= (extern-alias-directives? using-directives? global-attributes?) | (namespace-member-declarations?) ;
implicit-anonymous-function-signature ::= ("(" implicit-anonymous-function-parameter-list? ")") | implicit-anonymous-function-parameter ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
member-declarator ::= simple-name | member-access | (identifier "=" expression) ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= primary-no-array-creation-expression | array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= null-coalescing-expression | (null-coalescing-expression "?" expression ":" expression) ;
commas ::= "," | (commas ",") ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type | type-parameter ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | right-shift | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
collection-initializer ::= ("{" element-initializer-list "}") | ("{" element-initializer-list "," "}") ;
delegate-declaration ::= (attributes? delegate-modifiers? "delegate" return-type) | (identifier variant-type-parameter-list?) | ("(" formal-parameter-list? ")" type-parameter-constraints-clauses? ";") ;
struct-type ::= type-name | simple-type | nullable-type ;
anonymous-function-parameter-modifier ::= "ref" | "out" ;
yield-statement ::= ("yield" "return" expression ";") | ("yield" "break" ";") ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
extern-alias-directives ::= extern-alias-directive | (extern-alias-directives extern-alias-directive) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
orderings ::= ordering | (orderings "," ordering) ;
explicit-anonymous-function-parameter-list ::= explicit-anonymous-function-parameter | (explicit-anonymous-function-parameter-list "," explicit-anonymous-function-parameter) ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
anonymous-function-body ::= expression | block ;
value-type ::= struct-type | enum-type ;
variant-type-parameters ::= (attributes? variance-annotation? type-parameter) | (variant-type-parameters "," attributes? variance-annotation? type-parameter) ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
variance-annotation ::= "in" | "out" ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
local-variable-type ::= type | "var" ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= (identifier type-argument-list?) | (namespace-or-type-name "." identifier type-argument-list?) | qualified-alias-member ;
--------------------cs::csharp-zaytsev.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
specific-catch-clause ::= ("catch" "(" built-in-class-type lex-csharp/identifier? ")" block) | ("catch" "(" qualified-identifier lex-csharp/identifier? ")" block) ;
parameter-modifier ::= "ref" | "out" ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes "get" ";" (attributes "set" ";")?) | (attributes "set" ";" (attributes "get" ";")?) ;
unary-expression ::= (expression-unary-operator unary-expression) | ("(" type ")" unary-expression) | primary-expression ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
enum-body ::= ("{" "}") | ("{" {enum-member-declaration ","}+ ","? "}") ;
array-initializer ::= ("{" "}") | ("{" {variable-initializer ","}+ ","? "}") ;
selection-statement ::= if-statement | switch-statement ;
embedded-statement ::= maybe-empty-block | (statement-expression ";") | selection-statement | iteration-statement | jump-statement | try-statement | ("checked" block) | ("unchecked" block) | lock-statement | using-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
conversion-kind ::= "implicit" | "explicit" ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
expression-shift-operator ::= "<<" | ">>" ;
attribute-target ::= "field" | "event" | "method" | "module" | "param" | "property" | "return" | "type" ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
ref-or-out ::= "ref" | "out" ;
try-statement ::= ("try" block catch-clauses finally-clause?) | ("try" block finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
overloadable-unary-operator ::= lex-csharp-extra/plus | lex-csharp-extra/minus | increment-decrement | "!" | "~" | "true" | "false" ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
expression-unary-operator ::= lex-csharp-extra/plus | lex-csharp-extra/minus | increment-decrement | "!" | "~" | "*" ;
expression-relational-operator ::= lex-csharp-extra/less-than | lex-csharp-extra/greater-than | "<=" | ">=" | "is" | "as" ;
catch-clauses ::= (specific-catch-clause+ general-catch-clause?) | (specific-catch-clause* general-catch-clause) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
resource-acquisition ::= local-variable-declaration | expression ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern") ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
event-declaration ::= (attributes event-modifier* "event" type {variable-declarator ","}+ ";") | (attributes event-modifier* "event" type qualified-identifier "{" event-accessor-declarations "}") ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifier* array-initializer?) | ("new" array-type array-initializer) | lex-csharp/literal | lex-csharp/identifier | ("(" expression ")") | (primary-expression "." lex-csharp/identifier) | (predefined-type "." lex-csharp/identifier) | (primary-expression "(" argument-list ")") | (primary-expression "[" expression-list "]") | "this" | ("base" "." lex-csharp/identifier) | ("base" "[" expression-list "]") | (primary-expression increment-decrement) | ("new" type "(" argument-list ")") | ("typeof" "(" type-or-void ")") | ("checked" "(" expression ")") | ("unchecked" "(" expression ")") ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type qualified-identifier "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
overloadable-binary-operator ::= lex-csharp-extra/plus | lex-csharp-extra/minus | "*" | "/" | "%" | lex-csharp-extra/ampersand | lex-csharp-extra/bar | "^" | "<<" | ">>" | "==" | "!=" | lex-csharp-extra/greater-than | lex-csharp-extra/less-than | ">=" | "<=" ;
statement-expression ::= (primary-expression "(" argument-list ")") | ("new" type "(" argument-list ")") | (unary-expression assignment-operator expression) | (primary-expression increment-decrement) | (increment-decrement primary-expression) ;
increment-decrement ::= "++" | "--" ;
non-array-type ::= qualified-identifier | built-in-type ;
type-or-void ::= type | "void" ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
maybe-empty-block ::= ("{" statement* "}") | ";" ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= lex-csharp/identifier | (lex-csharp/identifier "=" variable-initializer) ;
expression-equality-operator ::= "==" | "!=" ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" expression ":") | ("default" ":") ;
expression ::= (expression "?" expression ":" expression) | (expression "||" expression) | (expression "&&" expression) | (expression lex-csharp-extra/bar expression) | (expression "^" expression) | (expression lex-csharp-extra/ampersand expression) | (expression expression-equality-operator expression) | (expression expression-relational-operator expression) | (expression "is" built-in-type) | (expression expression-shift-operator expression) | (expression lex-csharp-extra/plus expression) | (expression lex-csharp-extra/minus expression) | (expression "*" expression) | (expression "/" expression) | (expression "%" expression) | unary-expression | (unary-expression assignment-operator expression) ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
built-in-type ::= integral-type | built-in-class-type | "bool" | "decimal" | "float" | "double" ;
variable-initializer ::= expression | array-initializer ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list ")") | (":" "this" "(" argument-list ")") ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" ;
built-in-class-type ::= "object" | "string" ;
class-base ::= (":" qualified-identifier-list) | (":" built-in-class-type ("," qualified-identifier-list)?) ;
goto-statement ::= ("goto" lex-csharp/identifier ";") | ("goto" "case" expression ";") | ("goto" "default" ";") ;
--------------------cs::csharp-antoniol.bgf--------------------
not_newline ::= long_comment | (token) ;
line ::= ifdef | ("//"? other_preprocessor_line newline) | ("//"? any_other_line newline) ;
ifdef_token ::= ifdef_line | elsedef_line | elsifdef_line | endifdef_line ;
--------------------cs::csharp-bruneliere.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------cs::csharp-cordy.bgf--------------------
struct_member_declaration ::= constant_declaration | field_declaration | method_declaration | property_declaration | event_declaration | indexer_declaration | operator_declaration | constructor_declaration | static_constructor_declaration | type_declaration ;
input_parameters ::= input_parameter | ("(" {input_parameter ","}* ")") ;
equality_expression ::= relational_expression | (equality_expression "==" relational_expression) | (equality_expression "!=" relational_expression) ;
pointer_type ::= (unmanaged_type "*"*) | ("void" "*" "*"*) ;
class_member_declaration ::= constant_declaration | field_declaration | method_declaration | property_declaration | event_declaration | indexer_declaration | operator_declaration | constructor_declaration | finalizer_declaration | static_constructor_declaration | type_declaration ;
selection_statement ::= if_statement | switch_statement ;
conditional_or_expression ::= conditional_and_expression | (conditional_or_expression "||" conditional_and_expression) ;
static_constructor_body ::= (block NL) | (";" NL) ;
overloadable_binary_operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
type_declaration ::= class_declaration | struct_declaration | interface_declaration | enum_declaration | delegate_declaration ;
shift_expression ::= additive_expression | (shift_expression "<<" additive_expression) | (shift_expression ">>" additive_expression) ;
primary_expression ::= array_creation_expression | primary_no_array_creation_expression | object_initializer_expression ;
non_nullable_value_type ::= enum_type | type_name | simple_type ;
unmanaged_type ::= value_type | reference_type | type_parameter ;
conditional_expression ::= null_coalescing_expression | (null_coalescing_expression "?" expression ":" expression) ;
final_query_clause ::= (NL select_clause) | (NL groupby_clause) ;
statement ::= labeled_statement | declaration_statement | embedded_statement ;
finalizer_body ::= (block NL) | (";" NL) ;
integral_type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
for_initializer ::= local_variable_declaration | statement_expression_list ;
additive_expression ::= multiplicative_expression | (additive_expression "+" multiplicative_expression) | (additive_expression "-" multiplicative_expression) ;
declaration_statement ::= (local_variable_declaration ";" NL) | (local_constant_declaration ";" NL) ;
return_type ::= type | "void" ;
statement_expression ::= primary_no_array_creation_expression | object_creation_expression | assignment | pre_increment_expression | pre_decrement_expression ;
struct_type ::= type_name | simple_type | nullable_type ;
floating_point_type ::= "float" | "double" ;
inclusive_or_expression ::= exclusive_or_expression | (inclusive_or_expression "|" exclusive_or_expression) ;
operator_body ::= (block NL) | (";" NL) ;
resource_acquisition ::= local_variable_declaration | expression ;
null_coalescing_expression ::= conditional_or_expression | (conditional_or_expression "??" null_coalescing_expression) ;
conditional_and_expression ::= inclusive_or_expression | (conditional_and_expression "&&" inclusive_or_expression) ;
assignment_operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
enum_modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
event_declaration ::= (attributes? event_modifiers? "event" type variable_declarators ";" NL) | (attributes? event_modifiers? "event" type member_name "{" NL IN event_accessor_declarations EX "}" NL EX) ;
class_or_interface_type ::= class_type | interface_type ;
using_directive ::= using_alias_directive | using_namespace_directive ;
predefined_type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
accessor_modifier ::= "protected" | "internal" | "private" | ("protected" "internal") | ("internal" "protected") ;
event_accessor_declarations ::= (add_accessor_declaration remove_accessor_declaration) | (remove_accessor_declaration add_accessor_declaration) ;
value_type ::= struct_type | enum_type ;
constructor_body ::= (block NL) | (";" NL) ;
argument_list_or_key ::= argument_list | "in" ;
method_body ::= (block NL) | (";" NL) ;
overloadable_unary_operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
ascending_descending ::= "ascending" | "descending" ;
yield_statement ::= ("yield" "return" expression ";" NL) | ("yield" "break" ";" NL) ;
member_initializer ::= (member_name_equals? expression) | (member_name_equals? array_initializer) ;
argument ::= expression | ("ref" variable_reference) | ("out" variable_reference) ;
primary_constraint ::= class_type | "class" | "struct" ;
namespace_member_declaration ::= (namespace_declaration NL) | (type_declaration NL) ;
query_body_clause ::= (NL from_clause) | (NL join_clause) | (NL let_clause) | (NL where_clause) | (NL orderby_clause) ;
accessor_declarations ::= (get_accessor_declaration set_accessor_declaration?) | (set_accessor_declaration get_accessor_declaration?) ;
global_attribute_target ::= id | key ;
relational_expression ::= shift_expression | (relational_expression "<" shift_expression) | (relational_expression ">" shift_expression) | (relational_expression "<=" shift_expression) | (relational_expression ">=" shift_expression) | (relational_expression "is" type) | (relational_expression "as" type) ;
literal ::= boolean_literal | integer_literal | real_literal | character_literal | string_literal | null_literal ;
reference_type ::= class_type | interface_type | array_type | delegate_type ;
integer_literal ::= decimal_integer_literal | hexadecimal_integer_literal ;
parameter_modifier ::= "ref" | "out" ;
operator_declarator ::= unary_operator_declarator | binary_operator_declarator | conversion_operator_declarator ;
numeric_type ::= integral_type | floating_point_type | "decimal" ;
switch_label ::= ("case" constant_expression ":") | ("default" ":") ;
nested_statement ::= block | (IN NL embedded_statement EX) ;
simple_type ::= numeric_type | "bool" ;
simple_primary_expression ::= literal | simple_name | parenthesized_expression | this_access | base_access | object_or_delegate_creation_expression | typeof_expression | checked_expression | unchecked_expression | default_value_expression | anonymous_method_expression | (predefined_type member_access_operator) | (qualified_alias_member member_access_operator) ;
multiplicative_expression ::= unary_expression | (multiplicative_expression "*" unary_expression) | (multiplicative_expression "/" unary_expression) | (multiplicative_expression "%" unary_expression) ;
class_type ::= type_name | "object" | "string" ;
variable_initializer ::= expression | array_initializer ;
fixed_parameter ::= (attributes? parameter_modifier? type id) | parameter_array ;
jump_statement ::= break_statement | continue_statement | goto_statement | return_statement | throw_statement ;
constructor_initializer ::= (":" "base" "(" argument_list? ")") | (":" "this" "(" argument_list? ")") ;
interface_member_declaration ::= interface_method_declaration | interface_property_declaration | interface_event_declaration | interface_indexer_declaration ;
accessor_body ::= (block NL) | (";" NL) ;
type_parameter_constraint ::= primary_constraint | secondary_constraint | constructor_constraint ;
expression ::= conditional_expression | assignment | query_expression | lambda_expression ;
boolean_literal ::= "true" | "false" ;
fixed_pointer_initializer ::= ("&" variable_reference) | expression ;
attribute_target ::= id | key ;
exclusive_or_expression ::= and_expression | (exclusive_or_expression "^" and_expression) ;
goto_statement ::= ("goto" id ";" NL) | ("goto" "case" constant_expression ";" NL) | ("goto" "default" ";" NL) ;
constant_modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
array_creation_expression ::= ("new" non_array_type "[" expression_list "]" rank_specifiers? array_initializer?) | ("new" array_type array_initializer) ;
base_access ::= ("base" "." id type_argument_list?) | ("base" "[" expression+ "]") ;
non_array_type ::= value_type | class_type | interface_type | delegate_type | type_parameter ;
lambda_expression ::= (input_parameters "=>" expression) | (input_parameters "=>" block) ;
iteration_statement ::= while_statement | do_statement | for_statement | foreach_statement ;
secondary_constraint ::= interface_type | type_parameter ;
interface_accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
typeof_expression ::= ("typeof" "(" type ")") | ("typeof" "(" unbound_type_name ")") | ("typeof" "(" "void" ")") | ("typeof" "(" ")") ;
conversion_operator_declarator ::= ("implicit" "operator" type "(" type id ")") | ("explicit" "operator" type "(" type id ")") ;
attribute_argument ::= positional_argument | named_argument ;
and_expression ::= equality_expression | (and_expression "&" equality_expression) ;
--------------------cs::csharp-ecma-334-1.bgf--------------------
accessor-declarations ::= (get-accessor-declaration set-accessor-declaration?) | (set-accessor-declaration get-accessor-declaration?) ;
relational-expression ::= shift-expression | (relational-expression "<" shift-expression) | (relational-expression ">" shift-expression) | (relational-expression "<=" shift-expression) | (relational-expression ">=" shift-expression) | (relational-expression "is" type) | (relational-expression "as" type) ;
numeric-type ::= integral-type | floating-point-type | "decimal" ;
operator-declarator ::= unary-operator-declarator | binary-operator-declarator | conversion-operator-declarator ;
interface-member-declarations ::= interface-member-declaration | (interface-member-declarations interface-member-declaration) ;
member-access ::= (primary-expression "." identifier) | (predefined-type "." identifier) ;
destructor-body ::= block | ";" ;
unary-expression ::= primary-expression | ("+" unary-expression) | ("-" unary-expression) | ("!" unary-expression) | ("~" unary-expression) | ("*" unary-expression) | pre-increment-expression | pre-decrement-expression | cast-expression ;
enum-body ::= ("{" enum-member-declarations? "}") | ("{" enum-member-declarations "," "}") ;
using-directives ::= using-directive | (using-directives using-directive) ;
embedded-statement ::= block | empty-statement | expression-statement | selection-statement | iteration-statement | jump-statement | try-statement | checked-statement | unchecked-statement | lock-statement | using-statement ;
interface-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
interface-modifiers ::= interface-modifier | (interface-modifiers interface-modifier) ;
indexer-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
fixed-parameters ::= fixed-parameter | (fixed-parameters "," fixed-parameter) ;
attribute-target ::= "field" | "event" | "method" | "module" | "param" | "property" | "return" | type ;
operator-modifier ::= "public" | "static" | "extern" ;
formal-parameter-list ::= fixed-parameters | (fixed-parameters "," parameter-array) | parameter-array ;
constant-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
base-access ::= ("base" "." identifier) | ("base" "[" expression-list "]") ;
member-name ::= identifier | (interface-type "." identifier) ;
for-initializer ::= local-variable-declaration | statement-expression-list ;
try-statement ::= ("try" block catch-clauses) | ("try" block finally-clause) | ("try" block catch-clauses finally-clause) ;
declaration-statement ::= (local-variable-declaration ";") | (local-constant-declaration ";") ;
interface-member-declaration ::= interface-method-declaration | interface-property-declaration | interface-event-declaration | interface-indexer-declaration ;
variable-initializer-list ::= variable-initializer | (variable-initializer-list "," variable-initializer) ;
exclusive-or-expression ::= and-expression | (exclusive-or-expression "^" and-expression) ;
catch-clauses ::= (specific-catch-clauses general-catch-clause?) | (specific-catch-clauses? general-catch-clause) ;
array-creation-expression ::= ("new" non-array-type "[" expression-list "]" rank-specifiers? array-initializer?) | ("new" array-type array-initializer) ;
struct-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
property-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
event-declaration ::= (attributes? event-modifiers? "event" type variable-declarators ";") | (attributes? event-modifiers? "event" type member-name "{" event-accessor-declarations) | "}" ;
shift-expression ::= additive-expression | (shift-expression "<<" additive-expression) | (shift-expression ">>" additive-expression) ;
conversion-operator-declarator ::= ("implicit" "operator" type "(" type identifier ")") | ("explicit" "operator" type "(" type identifier ")") ;
enum-member-declarations ::= enum-member-declaration | (enum-member-declarations "," enum-member-declaration) ;
local-variable-declarator ::= identifier | (identifier "=" local-variable-initializer) ;
if-statement ::= ("if" "(" boolean-expression ")" embedded-statement) | ("if" "(" boolean-expression ")" embedded-statement "else" embedded-statement) ;
indexer-declarator ::= (type "this" "[" formal-parameter-list "]") | (type interface-type "." "this" "[" formal-parameter-list "]") ;
struct-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | static-constructor-declaration | type-declaration ;
interface-type-list ::= interface-type | (interface-type-list "," interface-type) ;
argument ::= expression | ("ref" variable-reference) | ("out" variable-reference) ;
conditional-or-expression ::= conditional-and-expression | (conditional-or-expression "||" conditional-and-expression) ;
integral-type ::= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char" ;
constant-declarators ::= constant-declarator | (constant-declarators "," constant-declarator) ;
switch-labels ::= switch-label | (switch-labels switch-label) ;
return-type ::= type | "void" ;
class-member-declarations ::= class-member-declaration | (class-member-declarations class-member-declaration) ;
statement-expression ::= invocation-expression | object-creation-expression | assignment | post-increment-expression | post-decrement-expression | pre-increment-expression | pre-decrement-expression ;
rank-specifiers ::= rank-specifier | (rank-specifiers rank-specifier) ;
positional-argument-list ::= positional-argument | (positional-argument-list "," positional-argument) ;
attribute-section ::= ("[" attribute-target-specifier? attribute-list "]") | ("[" attribute-target-specifier? attribute-list "," "]") ;
local-variable-declarators ::= local-variable-declarator | (local-variable-declarators "," local-variable-declarator) ;
expression-list ::= expression | (expression-list "," expression) ;
primary-no-array-creation-expression ::= literal | simple-name | parenthesized-expression | member-access | invocation-expression | element-access | this-access | base-access | post-increment-expression | post-decrement-expression | object-creation-expression | delegate-creation-expression | typeof-expression | checked-expression | unchecked-expression ;
enum-modifiers ::= enum-modifier | (enum-modifiers enum-modifier) ;
argument-list ::= argument | (argument-list "," argument) ;
event-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
global-attribute-sections ::= global-attribute-section | (global-attribute-sections global-attribute-section) ;
switch-sections ::= switch-section | (switch-sections switch-section) ;
assignment-operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ;
inclusive-or-expression ::= exclusive-or-expression | (inclusive-or-expression "|" exclusive-or-expression) ;
predefined-type ::= "bool" | "byte" | "char" | "decimal" | "double" | "float" | "int" | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort" ;
expression ::= conditional-expression | assignment ;
constructor-body ::= block | ";" ;
struct-member-declarations ::= struct-member-declaration | (struct-member-declarations struct-member-declaration) ;
operator-modifiers ::= operator-modifier | (operator-modifiers operator-modifier) ;
constant-modifiers ::= constant-modifier | (constant-modifiers constant-modifier) ;
dim-separators ::= "," | (dim-separators ",") ;
variable-declarators ::= variable-declarator | (variable-declarators "," variable-declarator) ;
method-modifiers ::= method-modifier | (method-modifiers method-modifier) ;
jump-statement ::= break-statement | continue-statement | goto-statement | return-statement | throw-statement ;
constructor-initializer ::= (":" "base" "(" argument-list? ")") | (":" "this" "(" argument-list? ")") ;
class-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "abstract" | "sealed" ;
goto-statement ::= ("goto" identifier ";") | ("goto" "case" constant-expression ";") | ("goto" "default" ";") ;
struct-modifiers ::= struct-modifier | (struct-modifiers struct-modifier) ;
property-modifiers ::= property-modifier | (property-modifiers property-modifier) ;
iteration-statement ::= while-statement | do-statement | for-statement | foreach-statement ;
floating-point-type ::= "float" | "double" ;
reference-type ::= class-type | interface-type | array-type | delegate-type ;
parameter-modifier ::= "ref" | "out" ;
qualified-identifier ::= identifier | (qualified-identifier "." identifier) ;
namespace-member-declaration ::= namespace-declaration | type-declaration ;
interface-accessors ::= (attributes? "get" ";") | (attributes? "set" ";") | (attributes? "get" ";" attributes? "set" ";") | (attributes? "set" ";" attributes? "get" ";") ;
specific-catch-clauses ::= specific-catch-clause | (specific-catch-clauses specific-catch-clause) ;
conditional-and-expression ::= inclusive-or-expression | (conditional-and-expression "&&" inclusive-or-expression) ;
simple-type ::= numeric-type | "bool" ;
statement ::= labeled-statement | declaration-statement | embedded-statement ;
multiplicative-expression ::= unary-expression | (multiplicative-expression "*" unary-expression) | (multiplicative-expression "/" unary-expression) | (multiplicative-expression "%" unary-expression) ;
class-type ::= type-name | "object" | "string" ;
array-initializer ::= ("{" variable-initializer-list? "}") | ("{" variable-initializer-list "," "}") ;
selection-statement ::= if-statement | switch-statement ;
constructor-modifiers ::= constructor-modifier | (constructor-modifiers constructor-modifier) ;
field-modifiers ::= field-modifier | (field-modifiers field-modifier) ;
accessor-body ::= block | ";" ;
class-modifiers ::= class-modifier | (class-modifiers class-modifier) ;
type-declaration ::= class-declaration | struct-declaration | interface-declaration | enum-declaration | delegate-declaration ;
attribute-arguments ::= ("(" positional-argument-list? ")") | ("(" positional-argument-list "," named-argument-list ")") | ("(" named-argument-list ")") ;
overloadable-unary-operator ::= "+" | "-" | "!" | "~" | "++" | "--" | "true" | "false" ;
statement-expression-list ::= statement-expression | (statement-expression-list "," statement-expression) ;
typeof-expression ::= ("typeof" "(" type ")") | ("typeof" "(" "void" ")") ;
resource-acquisition ::= local-variable-declaration | expression ;
and-expression ::= equality-expression | (and-expression "&" equality-expression) ;
equality-expression ::= relational-expression | (equality-expression "==" relational-expression) | (equality-expression "!=" relational-expression) ;
static-constructor-modifiers ::= ("extern"? "static") | ("static" "extern"?) ;
constructor-modifier ::= "public" | "protected" | "internal" | "private" | "extern" ;
field-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" ;
using-directive ::= using-alias-directive | using-namespace-directive ;
method-modifier ::= "new" | "public" | "protected" | "internal" | "private" | "static" | "virtual" | "sealed" | "override" | "abstract" | "extern" ;
primary-expression ::= array-creation-expression | primary-no-array-creation-expression ;
attribute-sections ::= attribute-section | (attribute-sections attribute-section) ;
conditional-expression ::= conditional-or-expression | (conditional-or-expression "?" expression ":" expression) ;
class-member-declaration ::= constant-declaration | field-declaration | method-declaration | property-declaration | event-declaration | indexer-declaration | operator-declaration | constructor-declaration | destructor-declaration | static-constructor-declaration | type-declaration ;
statement-list ::= statement | (statement-list statement) ;
type ::= value-type | reference-type ;
additive-expression ::= multiplicative-expression | (additive-expression "+" multiplicative-expression) | (additive-expression "-" multiplicative-expression) ;
overloadable-binary-operator ::= "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" | "<<" | ">>" | "==" | "!=" | ">" | "<" | ">=" | "<=" ;
delegate-modifiers ::= delegate-modifier | (delegate-modifiers delegate-modifier) ;
local-variable-initializer ::= expression | array-initializer ;
struct-type ::= type-name | simple-type ;
attribute-list ::= attribute | (attribute-list "," attribute) ;
indexer-modifiers ::= indexer-modifier | (indexer-modifiers indexer-modifier) ;
operator-body ::= block | ";" ;
enum-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
variable-declarator ::= identifier | (identifier "=" variable-initializer) ;
delegate-modifier ::= "new" | "public" | "protected" | "internal" | "private" ;
switch-label ::= ("case" constant-expression ":") | ("default" ":") ;
named-argument-list ::= named-argument | (named-argument-list "," named-argument) ;
namespace-member-declarations ::= namespace-member-declaration | (namespace-member-declarations namespace-member-declaration) ;
value-type ::= struct-type | enum-type ;
static-constructor-body ::= block | ";" ;
enum-member-declaration ::= (attributes? identifier) | (attributes? identifier "=" constant-expression) ;
variable-initializer ::= expression | array-initializer ;
method-body ::= block | ";" ;
event-accessor-declarations ::= (add-accessor-declaration remove-accessor-declaration) | (remove-accessor-declaration add-accessor-declaration) ;
global-attribute-section ::= ("[" global-attribute-target-specifier attribute-list "]") | ("[" global-attribute-target-specifier attribute-list "," "]") ;
event-modifiers ::= event-modifier | (event-modifiers event-modifier) ;
class-base ::= (":" class-type) | (":" interface-type-list) | (":" class-type "," interface-type-list) ;
namespace-or-type-name ::= identifier | (namespace-or-type-name "." identifier) ;
--------------------dart::spec-0.01.bgf--------------------
mapLiteralEntry ::= (identifier ":" expression) | (stringLiteral ":" expression) ;
argumentList ::= (namedArgument ("," namedArgument)*) | (expressionList ("," namedArgument)*) ;
declaration ::= (constantConstructorSignature (redirection | initializers)?) | (constructorSignature (redirection | initializers)?) | (functionSignature redirection) | (namedConstructorSignature redirection) | ("abstract" getterSignature) | ("abstract" setterSignature) | ("abstract" operatorSignature) | ("abstract" functionSignature) | ("static" "final" type? staticFinalDeclarationList) | ("static"? initializedVariableDeclaration) ;
bitwiseOperator ::= "&" | "^" | "|" ;
NEWLINE ::= "\n" | "\r" ;
STRING_CONTENT_SQ ::= α | ("\" α) | STRING_INTERPOLATION ;
finalVarOrType ::= ("final" type?) | "var" | type ;
postfixExpression ::= (assignableExpression postfixOperator) | (primary selector*) ;
relationalOperator ::= ">=" | ">" | "<=" | "<" ;
simpleFormalParameter ::= declaredIdentifier | identifier ;
booleanLiteral ::= "true" | "false" ;
interfaceMemberDefinition ::= ("static" "final" type? initializedIdentifierList ";") | (functionSignature ";") | (constantConstructorSignature ";") | (namedConstructorSignature ";") | (getterSignature ";") | (setterSignature ";") | (operatorSignature ";") | (variableDeclaration ";") ;
superCallOrFieldInitializer ::= ("super" arguments) | ("super" "." identifier arguments) | fieldInitializer ;
topLevelDefinition ::= classDefinition | interfaceDefinition | functionTypeAlias | (functionSignature functionBody) | (returnType? getOrSet identifier formalParameterList functionBody) | ("final" type? staticFinalDeclarationList ";") | (variableDeclaration ";") ;
BUILT_IN_IDENTIFIER ::= "abstract" | "assert" | "class" | "extends" | "factory" | "get" | "implements" | "import" | "interface" | "is" | "library" | "negate" | "operator" | "set" | "source" | "static" | "typedef" ;
numericLiteral ::= NUMBER | HEX_NUMBER ;
selector ::= assignableSelector | arguments ;
stringLiteral ::= ("@"? MULTI_LINE_STRING) | SINGLE_LINE_STRING ;
constructorSignature ::= (identifier formalParameterList) | namedConstructorSignature ;
methodSignature ::= factoryConstructorSignature | ("static" functionSignature) | getterSignature | setterSignature | operatorSignature | (functionSignature initializers?) | (namedConstructorSignature initializers?) ;
STRING_INTERPOLATION ::= ("$" IDENTIFIER_NO_DOLLAR) | ("$" "{" expression "}") ;
prefixOperator ::= additiveOperator | negateOperator ;
forLoopParts ::= (forInitializerStatement expression? ";" expressionList?) | (declaredIdentifier "in" expression) | (identifier "in" expression) ;
functionExpressionBody ::= ("=>" expression) | block ;
nonLabelledStatement ::= block | (initializedVariableDeclaration ";") | forStatement | whileStatement | doStatement | switchStatement | ifStatement | tryStatement | breakStatement | continueStatement | returnStatement | throwStatement | expressionStatement | assertStatement | (functionSignature functionBody) ;
getOrSet ::= "get" | "set" ;
IDENTIFIER_PART ::= IDENTIFIER_START | DIGIT ;
HEX_DIGIT ::= "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" | DIGIT ;
NUMBER ::= (DIGIT+ ("." DIGIT*)? EXPONENT?) | ("." DIGIT+ EXPONENT?) ;
assignableSelector ::= ("[" expression "]") | ("." identifier) ;
shiftOperator ::= "<<" | ">>>" | ">>" ;
negateOperator ::= "!" | "~" ;
binaryOperator ::= multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | equalityOperator | bitwiseOperator ;
SINGLE_LINE_STRING ::= (""" STRING_CONTENT_DQ* """) | ("'" STRING_CONTENT_SQ* "'") | ("@" "'" α* "'") | ("@" """ α* """) ;
assignableExpression ::= (primary (arguments* assignableSelector)+) | ("super" assignableSelector) | identifier ;
ESCAPE_SEQUENCE ::= ("\" "n") | ("\" "r") | ("\" "f") | ("\" "b") | ("\" "t") | ("\" "v") | ("\" "x" HEX_DIGIT HEX_DIGIT) | ("\" "u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT) | ("\" "u") ;
equalityOperator ::= "==" | "!=" | "===" | "!==" ;
shiftExpression ::= (additiveExpression (shiftOperator additiveExpression)*) | ("super" (shiftOperator additiveExpression)+) ;
formalParameterList ::= ("(" ")") | ("(" normalFormalParameters ("," namedFormalParameters)? ")") | namedFormalParameters ;
incrementOperator ::= "++" | "--" ;
equalityExpression ::= (relationalExpression (equalityOperator relationalExpression)?) | ("super" equalityOperator relationalExpression) ;
literal ::= nullLiteral | booleanLiteral | numericLiteral | stringLiteral | mapLiteral | listLiteral ;
IDENTIFIER_START ::= IDENTIFIER_START_NO_DOLLAR | "$" ;
bitwiseOrExpression ::= (bitwiseXorExpression ("|" bitwiseXorExpression)*) | ("super" ("|" bitwiseXorExpression)+) ;
identifier ::= IDENTIFIER_NO_DOLLAR | IDENTIFIER | BUILT_IN_IDENTIFIER ;
unaryExpression ::= prefixExpression | postfixExpression | (unaryOperator "super") | ("-" "super") | (incrementOperator assignableExpression) ;
IDENTIFIER_START_NO_DOLLAR ::= LETTER | "_" ;
LETTER ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
classMemberDefinition ::= (declaration ";") | (methodSignature functionBody) ;
operator ::= unaryOperator | binaryOperator | "[]" | "[]=" | "negate" ;
bitwiseXorExpression ::= (bitwiseAndExpression ("^" bitwiseAndExpression)*) | ("super" ("^" bitwiseAndExpression)+) ;
STRING_CONTENT_DQ ::= α | ("\" α) | STRING_INTERPOLATION ;
relationalExpression ::= (shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?) | ("super" relationalOperator shiftExpression) ;
bitwiseAndExpression ::= (equalityExpression ("&" equalityExpression)*) | ("super" ("&" equalityExpression)+) ;
compoundAssignmentOperator ::= "*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | (">" ">" ">" "="?) | ("<" "<" "="?) | "&=" | "^=" | "|=" ;
multiplicativeOperator ::= "*" | "/" | "%" | "~/" ;
functionBody ::= ("=>" expression ";") | block ;
expression ::= (assignableExpression assignmentOperator expression) | conditionalExpression ;
MULTI_LINE_STRING ::= (""""" α* """"") | ("'''" α* "'''") ;
forInitializerStatement ::= (initializedVariableDeclaration ";") | (expression? ";") ;
normalFormalParameter ::= functionSignature | fieldFormalParameter | simpleFormalParameter ;
assignmentOperator ::= "=" | compoundAssignmentOperator ;
additiveOperator ::= "+" | "-" ;
multiplicativeExpression ::= (unaryExpression (multiplicativeOperator unaryExpression)*) | ("super" (multiplicativeOperator unaryExpression)+) ;
DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
HEX_NUMBER ::= ("0x" HEX_DIGIT+) | ("0X" HEX_DIGIT+) ;
returnType ::= "void" | type ;
IDENTIFIER_PART_NO_DOLLAR ::= IDENTIFIER_START_NO_DOLLAR | DIGIT ;
additiveExpression ::= (multiplicativeExpression (additiveOperator multiplicativeExpression)*) | ("super" (additiveOperator multiplicativeExpression)+) ;
primary ::= thisExpression | ("super" assignableSelector) | functionExpression | literal | identifier | (newExpression constantObjectExpression) | ("(" expression ")") ;
--------------------dart::google.bgf--------------------
userDefinableOperator ::= multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | bitwiseOperator | "==" | "~" | NEGATE | ("[" "]") | ("[" "]" "=") ;
argumentList ::= (namedArgument ("," namedArgument)*) | (expressionList ("," namedArgument)*) ;
declaration ::= (constantConstructorDeclaration (redirection | initializers)?) | (functionDeclaration redirection) | (namedConstructorDeclaration redirection) | (ABSTRACT specialSignatureDefinition) | (ABSTRACT functionDeclaration) | (STATIC FINAL type? staticFinalDeclarationList) | (STATIC? constInitializedVariableDeclaration) ;
bitwiseOperator ::= "&" | "^" | "|" ;
NEWLINE ::= "\n" | "\r" ;
STRING_CONTENT_SQ ::= α | ("\\" α) ;
finalVarOrType ::= (FINAL type?) | VAR | type ;
postfixExpression ::= (assignableExpression postfixOperator) | (primary selector*) ;
classDefinition ::= (CLASS identifier typeParameters? superclass? interfaces? "{" classMemberDefinition* "}") | (CLASS identifier typeParameters? interfaces? NATIVE STRING "{" classMemberDefinition* "}") ;
relationalOperator ::= ">=" | ">" | "<=" | "<" ;
simpleFormalParameter ::= declaredIdentifier | identifier ;
interfaceMemberDefinition ::= (STATIC FINAL type? initializedIdentifierList ";") | (functionDeclaration ";") | (constantConstructorDeclaration ";") | (namedConstructorDeclaration ";") | (specialSignatureDefinition ";") | (variableDeclaration ";") ;
superCallOrFieldInitializer ::= (SUPER arguments) | (SUPER "." identifier arguments) | fieldInitializer ;
topLevelDefinition ::= classDefinition | interfaceDefinition | functionTypeAlias | (functionDeclaration functionBodyOrNative) | (returnType? getOrSet identifier formalParameterList functionBodyOrNative) | (FINAL type? staticFinalDeclarationList ";") | (constInitializedVariableDeclaration ";") ;
primaryNoFE ::= THIS | (SUPER assignableSelector) | literal | identifier | (CONST? typeArguments? compoundLiteral) | (NEW | CONST type ("." identifier)? arguments) | expressionInParentheses ;
selector ::= assignableSelector | arguments ;
methodDeclaration ::= factoryConstructorDeclaration | (STATIC functionDeclaration) | specialSignatureDefinition | (functionDeclaration initializers?) | (namedConstructorDeclaration initializers?) ;
prefixOperator ::= additiveOperator | negateOperator ;
forLoopParts ::= (forInitializerStatement expression? ";" expressionList?) | (declaredIdentifier IN expression) | (identifier IN expression) ;
functionExpressionBody ::= ("=>" expression) | block ;
nonLabelledStatement ::= block | (initializedVariableDeclaration ";") | iterationStatement | selectionStatement | tryStatement | (BREAK identifier? ";") | (CONTINUE identifier? ";") | (RETURN expression? ";") | (THROW expression? ";") | (expression? ";") | (ASSERT "(" conditionalExpression ")" ";") | (functionDeclaration functionBody) ;
getOrSet ::= GET | SET ;
IDENTIFIER_PART ::= IDENTIFIER_START | DIGIT ;
HEX_DIGIT ::= "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" | DIGIT ;
NUMBER ::= (DIGIT+ NUMBER_OPT_FRACTIONAL_PART EXPONENT? NUMBER_OPT_ILLEGAL_END) | ("." DIGIT+ EXPONENT? NUMBER_OPT_ILLEGAL_END) ;
assignableSelector ::= ("[" expression "]") | ("." identifier) ;
shiftOperator ::= "<<" | ">>>" | ">>" ;
negateOperator ::= "!" | "~" ;
SINGLE_LINE_STRING ::= (""" STRING_CONTENT_DQ* """) | ("\'" STRING_CONTENT_SQ* "\'") | ("@" "\'" α* "\'") | ("@" """ α* """) ;
selectionStatement ::= (IF "(" expression ")" statement (ELSE statement)?) | (SWITCH "(" expression ")" "{" switchCase* defaultCase? "}") ;
primaryFE ::= functionExpression | primaryNoFE ;
assignableExpression ::= (primary (arguments* assignableSelector)+) | (SUPER assignableSelector) | identifier ;
equalityOperator ::= "==" | "!=" | "===" | "!==" ;
shiftExpression ::= (additiveExpression (shiftOperator additiveExpression)*) | (SUPER (shiftOperator additiveExpression)+) ;
formalParameterList ::= ("(" namedFormalParameters? ")") | ("(" normalFormalParameter normalFormalParameterTail? ")") ;
incrementOperator ::= "++" | "--" ;
specialSignatureDefinition ::= (STATIC? returnType? getOrSet identifier formalParameterList) | (returnType? OPERATOR userDefinableOperator formalParameterList) ;
equalityExpression ::= (relationalExpression (equalityOperator relationalExpression)?) | (SUPER equalityOperator relationalExpression) ;
literal ::= NULL | TRUE | FALSE | HEX_NUMBER | NUMBER | STRING ;
bitwiseOrExpression ::= (bitwiseXorExpression ("|" bitwiseXorExpression)*) | (SUPER ("|" bitwiseXorExpression)+) ;
IDENTIFIER_START ::= IDENTIFIER_START_NO_DOLLAR | "$" ;
identifier ::= IDENTIFIER_NO_DOLLAR | IDENTIFIER | ABSTRACT | ASSERT | CLASS | EXTENDS | FACTORY | GET | IMPLEMENTS | IMPORT | INTERFACE | IS | LIBRARY | NATIVE | NEGATE | OPERATOR | SET | SOURCE | STATIC | TYPEDEF ;
unaryExpression ::= postfixExpression | (prefixOperator unaryExpression) | (negateOperator SUPER) | ("-" SUPER) | (incrementOperator assignableExpression) ;
IDENTIFIER_START_NO_DOLLAR ::= LETTER | "_" ;
LETTER ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
classMemberDefinition ::= (declaration ";") | (constructorDeclaration ";") | (methodDeclaration functionBodyOrNative) | (CONST factoryConstructorDeclaration functionNative) ;
NUMBER_OPT_FRACTIONAL_PART ::= ("." DIGIT+) | ε ;
bitwiseXorExpression ::= (bitwiseAndExpression ("^" bitwiseAndExpression)*) | (SUPER ("^" bitwiseAndExpression)+) ;
STRING_CONTENT_DQ ::= α | ("\\" α) ;
constructorDeclaration ::= (identifier formalParameterList (redirection | initializers)?) | (namedConstructorDeclaration (redirection | initializers)?) ;
relationalExpression ::= (shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?) | (SUPER relationalOperator shiftExpression) ;
bitwiseAndExpression ::= (equalityExpression ("&" equalityExpression)*) | (SUPER ("&" equalityExpression)+) ;
functionBody ::= ("=>" expression ";") | block ;
multiplicativeOperator ::= "*" | "/" | "%" | "~/" ;
expression ::= (assignableExpression assignmentOperator expression) | conditionalExpression ;
forInitializerStatement ::= (initializedVariableDeclaration ";") | (expression? ";") ;
MULTI_LINE_STRING ::= (""""" α* """"") | ("\'\'\'" α* "\'\'\'") ;
functionBodyOrNative ::= (NATIVE functionBody) | functionNative | functionBody ;
normalFormalParameter ::= functionDeclaration | fieldFormalParameter | simpleFormalParameter ;
iterationStatement ::= (WHILE "(" expression ")" statement) | (DO statement WHILE "(" expression ")" ";") | (FOR "(" forLoopParts ")" statement) ;
assignmentOperator ::= "=" | "*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | ">>>=" | ">>=" | "&=" | "^=" | "|=" ;
STRING ::= ("@"? MULTI_LINE_STRING) | SINGLE_LINE_STRING ;
additiveOperator ::= "+" | "-" ;
multiplicativeExpression ::= (unaryExpression (multiplicativeOperator unaryExpression)*) | (SUPER (multiplicativeOperator unaryExpression)+) ;
HEX_NUMBER ::= ("0x" HEX_DIGIT+) | ("0X" HEX_DIGIT+) ;
DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
returnType ::= VOID | type ;
additiveExpression ::= (multiplicativeExpression (additiveOperator multiplicativeExpression)*) | (SUPER (additiveOperator multiplicativeExpression)+) ;
compoundLiteral ::= listLiteral | mapLiteral ;
IDENTIFIER_PART_NO_DOLLAR ::= IDENTIFIER_START_NO_DOLLAR | DIGIT ;
declaredIdentifier ::= (FINAL type? identifier) | (VAR identifier) | (type identifier) ;
normalFormalParameterTail ::= ("," namedFormalParameters) | ("," normalFormalParameter normalFormalParameterTail?) ;
primary ::= primaryNoFE | primaryFE ;
--------------------dart::spec-0.05.bgf--------------------
mapLiteralEntry ::= (identifier ":" expression) | (stringLiteral ":" expression) ;
argumentList ::= (namedArgument ("," namedArgument)*) | (expressionList ("," namedArgument)*) ;
declaration ::= (constantConstructorSignature (redirection | initializers)?) | (functionSignature redirection) | (namedConstructorSignature redirection) | ("abstract" getterSignature) | ("abstract" setterSignature) | ("abstract" operatorSignature) | ("abstract" functionSignature) | ("static" "final" type? staticFinalDeclarationList) | ("static"? initializedVariableDeclaration) ;
bitwiseOperator ::= "&" | "^" | "|" ;
NEWLINE ::= "\n" | "\r" ;
STRING_CONTENT_SQ ::= ("~" "\\" | "\'" | "$" | NEWLINE) | ("\\" "~" NEWLINE) | STRING_INTERPOLATION ;
finalVarOrType ::= ("final" type?) | "var" | type ;
postfixExpression ::= (assignableExpression postfixOperator) | (primary selector*) ;
relationalOperator ::= ">=" | ">" | "<=" | "<" ;
simpleFormalParameter ::= declaredIdentifier | identifier ;
booleanLiteral ::= "true" | "false" ;
interfaceMemberDefinition ::= ("static" "final" type? initializedIdentifierList ";") | (functionSignature ";") | (constantConstructorSignature ";") | (namedConstructorSignature ";") | (getterSignature ";") | (setterSignature ";") | (operatorSignature ";") | (variableDeclaration ";") ;
superCallOrFieldInitializer ::= ("super" arguments) | ("super" "." identifier arguments) | fieldInitializer ;
topLevelDefinition ::= classDefinition | interfaceDefinition | functionTypeAlias | (functionSignature functionBody) | (returnType? getOrSet identifier formalParameterList functionBody) | ("final" type? staticFinalDeclarationList ";") | (variableDeclaration ";") ;
BUILT_IN_IDENTIFIER ::= "abstract" | "assert" | "Dynamic" | "factory" | "get" | "implements" | import | "interface" | "library" | "negate" | operator | "set" | "source" | "static" | "typedef" ;
numericLiteral ::= NUMBER | HEX_NUMBER ;
selector ::= assignableSelector | arguments ;
stringLiteral ::= ("@"? MULTI_LINE_STRING) | SINGLE_LINE_STRING ;
constructorSignature ::= (identifier formalParameterList) | namedConstructorSignature ;
methodSignature ::= factoryConstructorSignature | ("static" functionSignature) | getterSignature | setterSignature | operatorSignature | (functionSignature initializers?) | (namedConstructorSignature initializers?) ;
STRING_INTERPOLATION ::= ("$" IDENTIFIER_NO_DOLLAR) | ("$" "{" "Expression" "}") ;
prefixOperator ::= "-" | negateOperator ;
forLoopParts ::= (forInitializerStatement expression? ";" expressionList?) | (declaredIdentifier "in" expression) | (identifier "in" expression) ;
functionExpressionBody ::= ("=>" expression) | block ;
nonLabelledStatement ::= block | (initializedVariableDeclaration ";") | forStatement | whileStatement | doStatement | switchStatement | ifStatement | tryStatement | breakStatement | continueStatement | returnStatement | throwStatement | expressionStatement | assertStatement | (functionSignature functionBody) ;
getOrSet ::= "get" | "set" ;
IDENTIFIER_PART ::= IDENTIFIER_START | DIGIT ;
HEX_DIGIT ::= ("a" "." "." "f") | ("A" "." "." "F") | DIGIT ;
NUMBER ::= ("+"? DIGIT+ ("." DIGIT+)? EXPONENT?) | ("+"? "." DIGIT+ EXPONENT?) ;
assignableSelector ::= ("[" expression "]") | ("." identifier) ;
shiftOperator ::= "<<" | ">>>" | ">>" ;
negateOperator ::= "!" | "~" ;
binaryOperator ::= multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | equalityOperator | bitwiseOperator ;
SINGLE_LINE_STRING ::= (""" STRING_CONTENT_DQ* """) | ("'" STRING_CONTENT_SQ* "'") | ("@' ' '" ("~" "'" | NEWLINE)* "'") | ("@" """ ("~" """ | NEWLINE)* """) ;
assignableExpression ::= (primary (arguments* assignableSelector)+) | ("super" assignableSelector) | identifier ;
ESCAPE_SEQUENCE ::= "\n" | "\r" | "\f" | "\b" | "\t" | "\v" | ("\x" HEX_DIGIT HEX_DIGIT) | ("\u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT) | ("\u{" HEX_DIGIT_SEQUENCE "}") ;
equalityOperator ::= "==" | "!=" | "===" | "!==" ;
shiftExpression ::= (additiveExpression (shiftOperator additiveExpression)*) | ("super" (shiftOperator additiveExpression)+) ;
formalParameterList ::= ("(" ")") | ("(" normalFormalParameters ("," namedFormalParameters)? ")") | ("(" namedFormalParameters ")") ;
incrementOperator ::= "++" | "--" ;
equalityExpression ::= (relationalExpression (equalityOperator relationalExpression)?) | ("super" equalityOperator relationalExpression) ;
literal ::= nullLiteral | booleanLiteral | numericLiteral | stringLiteral | mapLiteral | listLiteral ;
IDENTIFIER_START ::= IDENTIFIER_START_NO_DOLLAR | "$" ;
bitwiseOrExpression ::= (bitwiseXorExpression ("|" bitwiseXorExpression)*) | ("super" ("|" bitwiseXorExpression)+) ;
identifier ::= IDENTIFIER_NO_DOLLAR | IDENTIFIER | BUILT_IN_IDENTIFIER ;
unaryExpression ::= (prefixOperator unaryExpression) | postfixExpression | (unaryOperator "super") | ("-" "super") | (incrementOperator assignableExpression) ;
IDENTIFIER_START_NO_DOLLAR ::= "LETTER" | "_" ;
classMemberDefinition ::= (declaration ";") | (methodSignature functionBody) ;
operator ::= unaryOperator | binaryOperator | ("[" "]") | ("[" "]" "=") | "negate" ;
bitwiseXorExpression ::= (bitwiseAndExpression ("^" bitwiseAndExpression)*) | ("super" ("^" bitwiseAndExpression)+) ;
STRING_CONTENT_DQ ::= ("~" "\\" | """ | "$" | NEWLINE) | ("\\" "~" NEWLINE) | STRING_INTERPOLATION ;
relationalExpression ::= (shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?) | ("super" relationalOperator shiftExpression) ;
bitwiseAndExpression ::= (equalityExpression ("&" equalityExpression)*) | ("super" ("&" equalityExpression)+) ;
compoundAssignmentOperator ::= "*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | ">>>=" | ">>=" | "&=" | "^=" | "|=" ;
multiplicativeOperator ::= "*" | "/" | "%" | "~/" ;
functionBody ::= ("=>" expression ";") | block ;
expression ::= (assignableExpression assignmentOperator expression) | conditionalExpression ;
forInitializerStatement ::= (initializedVariableDeclaration ";") | (expression? ";") ;
MULTI_LINE_STRING ::= (""""" ("~" """"")* """"") | ("'''" ("~" "'''")* "'''") ;
normalFormalParameter ::= functionSignature | fieldFormalParameter | simpleFormalParameter ;
assignmentOperator ::= "=" | compoundAssignmentOperator ;
additiveOperator ::= "+" | "-" ;
multiplicativeExpression ::= (unaryExpression (multiplicativeOperator unaryExpression)*) | ("super" (multiplicativeOperator unaryExpression)+) ;
DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
HEX_NUMBER ::= ("0x" HEX_DIGIT+) | ("0X" HEX_DIGIT+) ;
returnType ::= "void" | type ;
IDENTIFIER_PART_NO_DOLLAR ::= IDENTIFIER_START_NO_DOLLAR | DIGIT ;
additiveExpression ::= (multiplicativeExpression (additiveOperator multiplicativeExpression)*) | ("super" (additiveOperator multiplicativeExpression)+) ;
primary ::= thisExpression | ("super" assignableSelector) | functionExpression | literal | identifier | newExpression | constantObjectExpression | ("(" expression ")") ;
--------------------eiffel::bezault.bgf--------------------
Header_mark ::= "deferred" | "expanded" | "separate" ;
Integer ::= (Decimal_digit+) | (Decimal_digit (Decimal_digit Decimal_digit?)? ("_" Decimal_digit Decimal_digit Decimal_digit)+) ;
Call ::= Qualified_call | Precursor ;
Sign ::= "+" | "-" ;
Routine_body ::= Effective | Deferred ;
Boolean_constant ::= "True" | "False" ;
Type ::= Class_type | Class_type_expanded | Class_type_separate | Anchored | Bit_type ;
Feature_set ::= Feature_list | "all" ;
Expression ::= "Current" | "Result" | Call | Operator_expression | Equality | Manifest_array | Old | Strip | Boolean_constant | Bit_constant | Integer | Real | Manifest_string | Character_constant | Wide_character_constant | Wide_manifest_string | Hexadecimal_constant ;
Address_mark ::= Feature_name | "Current" | "Result" ;
Bit_length ::= Integer_constant | Attribute ;
Anchor ::= Identifier | "Current" ;
Manifest_constant ::= Boolean_constant | Character_constant | Integer_constant | Real_constant | Manifest_string | Bit_constant | Wide_character_constant | Wide_manifest_string | Hexadecimal_constant ;
Feature_name ::= Identifier | Prefix | Infix ;
Operator_expression ::= Parenthesized | Unary_expression | Binary_expression ;
Infix_operator ::= Binary | Free_operator ;
Call_target ::= Parenthesized | "Result" | "Current" | Precursor ;
Unlabeled_assertion_clause ::= Boolean_expression | Comment ;
Prefix_operator ::= Unary | Free_operator ;
Unary ::= "not" | "+" | "-" ;
Actual ::= Expression | Address ;
Instruction ::= Creation | Call | Assignment | Assignment_attempt | Conditional | Multi_branch | Loop | Debug | Check | Retry | Null_instruction ;
Comparison ::= "=" | "/=" ;
Routine_mark ::= "do" | "once" ;
Feature_value ::= Manifest_constant | Unique | Routine ;
Effective ::= Internal | External ;
Index_value ::= Identifier | Manifest_constant ;
Choice_constant ::= Integer_constant | Character_constant | Attribute ;
Choice ::= Choice_constant | Interval ;
Binary ::= "+" | "-" | "*" | "/" | "<" | ">" | "<=" | ">=" | "//" | "\\" | "^" | "and" | "or" | "xor" | ("and" "then") | ("or" "else") | "implies" ;
Writable ::= Identifier | "Result" ;
--------------------eiffel::cordy.bgf--------------------
Creation ::= ("!!" Writable Creation_call?) | ("!" Type? "!" Writable Creation_call?) ;
Header_mark ::= "deferred" | "expanded" ;
Restricted_type ::= Restricted_class_type | Formal_generic_name ;
Sign ::= "+" | "-" ;
Routine_body ::= Effective | Deferred ;
Boolean_constant ::= "true" | "false" ;
Type ::= Class_type | Class_type_expanded | Formal_generic_name | Anchored | Bit_type ;
Feature_set ::= Feature_list | "all" ;
Address_mark ::= Feature_name | "Current" | "Result" ;
Feature_declaration_Separator ::= (Feature_declaration Separator) | (Routine_feature_declaration Separator) ;
Read_only ::= Formal | "Current" ;
Anchor ::= Identifier | "Current" ;
Manifest_constant ::= Boolean_constant | Character_constant | Integer_constant | Real_constant | Manifest_string | Bit_constant ;
Feature_name ::= Identifier | Prefix | Infix ;
Infix_operator ::= Binary | Free_operator ;
Operator_expression ::= Parenthesized | Binary_expression ;
Prefix_operator ::= Unary | Free_operator ;
Unlabeled_assertion_clause ::= Boolean_expression | Comment ;
Primitive_expression ::= Call | Manifest_constant | Manifest_array | Old | Strip | Parenthesized ;
Unary ::= "not" | "+" | "-" ;
Actual ::= Expression | Address ;
Instruction ::= Creation | Call | Assignment | Assignment_attempt | Conditional | Multi_branch | Loop | Debug | Check | Retry | Null ;
Local ::= Identifier | "Result" ;
Comparison ::= "=" | "/=" ;
Routine_mark ::= "do" | "once" ;
Feature_value ::= Manifest_constant | Unique ;
Effective ::= Internal | External ;
Constant ::= Manifest_constant | Constant_attribute ;
Index_value ::= (Identifier+) | Manifest_constant ;
Entity ::= Writable | Read_only ;
Choice ::= Constant | Interval ;
Binary ::= "+" | "-" | "*" | "/" | "<" | ">" | "<=" | ">=" | "//" | "\\" | "^" | "and" | "or" | "xor" | ("and" "then") | ("or" "else") | "implies" ;
Writable ::= Attribute | Local ;
--------------------eiffel::iso-25436-2006.bgf--------------------
Special_expression ::= Manifest_constant | Manifest_tuple | Agent | Object_test | Once_string | Address ;
Call ::= Object_call | Non_object_call ;
Call_agent_body ::= Agent_qualified | Agent_unqualified ;
Boolean_constant ::= "True" | "False" ;
Alias_name ::= Operator | Bracket ;
Feature_set ::= Feature_list | "all" ;
Expression ::= Basic_expression | Special_expression ;
Integer_base_letter ::= "b" | "c" | "x" | "B" | "C" | "X" ;
Operator_expression ::= Unary_expression | Binary_expression ;
Target ::= Local | Read_only | Call | Parenthesized_target ;
Unlabeled_assertion_clause ::= Boolean_expression | Comment ;
Boolean_expression ::= Basic_expression | Boolean_constant | Object_test ;
Instruction ::= Creation_instruction | Call | Assignment | Assigner_call | Conditional | Multi_branch | Loop | Debug | Precursor | Check | Retry ;
External_language ::= Unregistered_language | Registered_language ;
Agent_target ::= Entity | Parenthesized | Manifest_type ;
Feature_body ::= Deferred | Effective_routine | Attribute ;
Comparison ::= "=" | "/=" | "~" | "/~" ;
Basic_expression ::= Read_only | Local | Call | Precursor | Equality | Parenthesized | Old | Operator_expression | Bracket_expression | Creation_expression ;
Bracket_target ::= Target | Once_string | Manifest_constant | Manifest_tuple ;
Agent_actual ::= Expression | Placeholder ;
Agent ::= Call_agent | Inline_agent ;
Constraining_types ::= Single_constraint | Multiple_constraint ;
Tuple_parameters ::= Type_list | Entity_declaration_list ;
Binary ::= "+" | "-" | "*" | "/" | "//" | "\\" | "^" | ".." | "<" | ">" | "<=" | ">=" | "and" | "or" | "xor" | ("and" "then") | ("or" "else") | "implies" | Free_binary ;
Note_item ::= Identifier | Manifest_constant ;
Header_mark ::= "deferred" | "expanded" | "frozen" ;
Sign ::= "+" | "-" ;
Variable ::= Variable_attribute | Local ;
Type ::= Class_or_tuple_type | Formal_generic_name | Anchored ;
Registered_language ::= C_external | CPP_external | DLL_external ;
Read_only ::= Formal | Constant_attribute | "Current" ;
Anchor ::= Feature_name | "Current" ;
Open_bracket ::= "[" | "{" ;
External_file ::= External_user_file | External_system_file ;
Unary ::= "not" | "+" | "-" | Free_unary ;
Digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" | "_" ;
Effective_routine ::= Internal | External ;
Local ::= Identifier | "Result" ;
Attachment_mark ::= "?" | "!" ;
Routine_mark ::= "do" | Once ;
Class_or_tuple_type ::= Class_type | Tuple_type ;
Constant ::= Manifest_constant | Constant_attribute ;
Operator ::= Unary | Binary ;
Entity ::= Variable | Read_only ;
Close_bracket ::= "]" | "}" ;
Manifest_string ::= Basic_manifest_string | Verbatim_string ;
Manifest_value ::= Boolean_constant | Character_constant | Integer_constant | Real_constant | Manifest_string | Manifest_type ;
Choice ::= Constant | Manifest_type | Constant_interval | Type_interval ;
Converter ::= Conversion_procedure | Conversion_query ;
--------------------fortran::derricks.bgf--------------------
RdIoCtlSpecList ::= (UnitIdentifier "," IoControlSpec) | (UnitIdentifier "," FormatIdentifier) | IoControlSpec | (RdIoCtlSpecList "," IoControlSpec) ;
AllocateObject ::= VariableName | (AllocateObject FieldSelector) ;
CharLength ::= ("(" TypeParamValue ")") | ScalarIntLiteralConstant ;
FunctionArgList ::= FunctionArg | (FunctionArgList "," FunctionArg) | (SectionSubscriptList "," FunctionArg) ;
InquireStmt ::= (LblDef "inquire" "(" InquireSpecList ")" EOS) | (LblDef "inquire" "(" "iolength" "=" ScalarVariable ")" OutputItemList EOS) ;
SubroutineRange ::= (SubroutineParList? EOS Body? EndSubroutineStmt) | (SubroutineParList EOS InternalSubProgPart EndSubroutineStmt) ;
LoopControl ::= ("while" "(" Expr ")") | (VariableName "=" Int-Real-Dp-Expression "," Int-Real-Dp-Expression ("," Int-Real-Dp-Expression)?) ;
ModuleSubprogram ::= FunctionSubprogram | SubroutineSubprogram ;
InquireSpec ::= ("unit" "=" UnitIdentifier) | ("file" "=" CExpr) | ("iostat" "=" ScalarVariable) | ("err" "=" LblRef) | ("exist" "=" ScalarVariable) | ("opened" "=" ScalarVariable) | ("number" "=" ScalarVariable) | ("named" "=" ScalarVariable) | ("name" "=" ScalarVariable) | ("access" "=" ScalarVariable) | ("sequential" "=" ScalarVariable) | ("direct" "=" ScalarVariable) | ("form" "=" ScalarVariable) | ("formatted" "=" ScalarVariable) | ("unformatted" "=" ScalarVariable) | ("recl" "=" Expr) | ("nextrec" "=" ScalarVariable) | ("blank" "=" ScalarVariable) | ("position" "=" ScalarVariable) | ("action" "=" ScalarVariable) | ("read" "=" ScalarVariable) | ("write" "=" ScalarVariable) | ("readwrite" "=" ScalarVariable) | ("delim" "=" ScalarVariable) | ("pad" "=" ScalarVariable) ;
StructureComponent ::= (VariableName FieldSelector) | (StructureComponent FieldSelector) ;
SFExpr ::= SFTerm | (Sign AddOperand) | (SFExpr AddOp AddOperand) ;
CaseBodyConstruct ::= CaseStmt | ExecutionPartConstruct ;
MainRange ::= (BodyConstruct+ EndProgramStmt) | (InternalSubProgPart EndProgramStmt) | EndProgramStmt ;
Primary ::= ArrayConstructor | UnsignedArithmeticConstant | Name | DataRef | FunctionReference | ("(" Expr ")") | Scon | LogicalConstant ;
BlockDoConstruct ::= (LblDef "do" LblRef EOS) | (LblDef "do" LoopControl EOS) | (LblDef "do" EOS) | (LblDef Name ":" "do" LblRef LoopControl EOS) | (LblDef Name ":" "do" LblRef EOS) | (LblDef Name ":" "do" LoopControl EOS) | (LblDef Name ":" "do" EOS) ;
DataStmtValue ::= Constant | (NamedConstantUse "*" Constant) ;
TypeParamValue ::= SpecificationExpr | "*" ;
PointerField ::= (Name "(" SFExprList ")" "%" Name) | (Name "(" SFDummyArgNameList ")" "%" Name) | (Name "%" Name) | (PointerField FieldSelector) ;
InputItem ::= Name | DataRef | InputImpliedDo ;
Sign ::= "+" | "-" ;
AssignedGotoStmt ::= (LblDef GoToKw VariableName EOS) | (LblDef GoToKw VariableName ","? "(" LblRef ("," LblRef)* ")" EOS) ;
FieldSelector ::= ("(" SectionSubscriptList ")" "%" Name) | ("%" Name) ;
OutputItem ::= Expr | OutputImpliedDo ;
ComponentDefStmt ::= (LblDef TypeSpec ("," ComponentAttrSpecList)? ":" ":" ComponentDeclList EOS) | (LblDef TypeSpec ComponentDeclList EOS) ;
UseStmt ::= (LblDef "use" Name ("," RenameList)? EOS) | (LblDef "use" Name "," "only" ":" OnlyList? EOS) ;
PositionEditDescr ::= ("T" Icon) | ("TL" Icon) | ("TR" Icon) | (Icon "X") ;
Only ::= GenericSpec | ((Ident "=>")? UseName) ;
FormatItem ::= (Icon? DataEditDescr) | ControlEditDescr | CharStringEditDescr | (Icon? "(" FormatItemList ")") | (FormatItem ":" FormatItem) ;
InputImpliedDo ::= ("(" InputItemList "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" InputItemList "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") ;
ActualArg ::= ((Name "=")? Expr) | ((Name "=")? "*" LblRef) ;
BackspaceStmt ::= (LblDef "backspace" UnitIdentifier EOS) | (LblDef "backspace" "(" PositionSpec ("," PositionSpec)* ")" EOS) ;
DeallocateStmt ::= (LblDef "deallocate" "(" AllocateObjectList "," "stat" "=" Variable ")" EOS) | (LblDef "deallocate" "(" AllocateObjectList ")" EOS) ;
SectionSubscript ::= Expr | SubscriptTriplet ;
AllocateStmt ::= (LblDef "allocate" "(" AllocationList "," "stat" "=" Variable ")" EOS) | (LblDef "allocate" "(" AllocationList ")" EOS) ;
RdCtlSpec ::= RdUnitId | ("(" RdIoCtlSpecList ")") ;
Constant ::= NamedConstantUse | UnsignedArithmeticConstant | ("+" UnsignedArithmeticConstant) | ("-" UnsignedArithmeticConstant) | Scon | LogicalConstant | (Icon "_" Scon) | (NamedConstantUse "_" Scon) | StructureConstructor | BozLiteralConstant ;
AccessId ::= GenericName | GenericSpec ;
CaseValueRange ::= Expr | (Expr ":") | (":" Expr) | (Expr ":" Expr) ;
PointerObject ::= Name | PointerField ;
SignEditDescr ::= "S" | "SP" | "SS" ;
CloseSpec ::= UnitIdentifier | ("unit" "=" UnitIdentifier) | ("iostat" "=" ScalarVariable) | ("err" "=" LblRef) | ("status" "=" CExpr) ;
KindSelector ::= ("(" ("kind" "=")? Expr ")") | ("*" Icon) ;
PointerAssignmentStmt ::= (LblDef Name "=>" Target EOS) | (LblDef Name "%" Name "=>" Target EOS) | (LblDef Name "%" DataRef "=>" Target EOS) | (LblDef Name "(" SFExprList ")" "%" Name "=>" Target EOS) | (LblDef Name "(" SFExprList ")" "%" DataRef "=>" Target EOS) | (LblDef Name "(" SFDummyArgNameList ")" "%" Name "=>" Target EOS) | (LblDef Name "(" SFDummyArgNameList ")" "%" DataRef "=>" Target EOS) ;
EndProgramStmt ::= (LblDef "end" EOS) | (LblDef "end" "program" EndName? EOS) ;
RdUnitId ::= ("(" UFExpr ")") | ("(" "*" ")") ;
InternalSubProgPart ::= (Body ContainsStmt InternalSubprogram) | (ContainsStmt InternalSubprogram) | (InternalSubProgPart InternalSubprogram) ;
CharStringEditDescr ::= Scon | (Icon "H" Character+) ;
LogicalConstant ::= (".true." "_" KindParam) | (".false." "_" KindParam) | ".true." | ".false." ;
DefinedOperator ::= Dop | PowerOp | MultOp | AddOp | ConcatOp | RelOp | NotOp | AndOp | OrOp | EquivOp ;
InquireSpecList ::= (UnitIdentifier "," InquireSpec ("," InquireSpec)*) | (InquireSpec ("," InquireSpec)*) ;
FunctionPrefix ::= ("recursive" "function") | ("recursive" TypeSpec "function") | (TypeSpec "recursive" "function") | (TypeSpec? "function") ;
ScalarVariable ::= VariableName | ArrayElement ;
TypeDeclarationStmt ::= (LblDef TypeSpec ("," AttrSpec)* ":" ":" EntityDecl ("," EntityDecl)* EOS) | (LblDef TypeSpec EntityDecl ("," EntityDecl)* EOS) ;
SFExprList ::= (SFExpr ":" Expr ":" Expr) | (SFExpr ":" ":" Expr) | (":" Expr ":" Expr) | (":" ":" Expr) | ":" | (":" Expr) | SFExpr | (SFExpr ":") | (SFExpr ":" Expr) | (SFExprList "," SectionSubscript) | (SFDummyArgNameList "," ":") | (SFDummyArgNameList "," ":" Expr) | (SFDummyArgNameList "," SFExpr ":") | (SFDummyArgNameList "," SFExpr ":" Expr) ;
ConnectSpec ::= UnitIdentifier | ("unit" "=" UnitIdentifier) | ("iostat" "=" ScalarVariable) | ("err" "=" LblRef) | ("file" "=" CExpr) | ("status" "=" CExpr) | ("access" "=" CExpr) | ("form" "=" CExpr) | ("recl" "=" Expr) | ("blank" "=" CExpr) | ("position" "=" CExpr) | ("action" "=" CExpr) | ("delim" "=" CExpr) | ("pad" "=" CExpr) ;
PositionSpec ::= ("unit="? UnitIdentifier) | ("iostat=" ScalarVariable) | ("err=" LblRef) ;
IntentStmt ::= (LblDef "intent" "(" IntentSpec ")" ":" ":" IntentParList EOS) | (LblDef "intent" "(" IntentSpec ")" IntentParList EOS) ;
ReadStmt ::= (LblDef "read" RdCtlSpec InputItemList? EOS) | (LblDef "read" RdFmtId EOS) | (LblDef "read" RdFmtId "," InputItemList EOS) ;
UFTerm ::= UFFactor | (UFTerm MultOp UFFactor) | (UFTerm ConcatOp UFPrimary) ;
DeclarationConstruct ::= TypeDeclarationStmt | SpecificationStmt | DerivedTypeDef | InterfaceBlock ;
FunctionInterfaceRange ::= (FunctionParList EOS SubprogramInterfaceBody EndFunctionStmt) | (FunctionParList EOS EndFunctionStmt) ;
Variable ::= VariableName | (VariableName "(" Subscript ("," Subscript)* ")") | (VariableName SubstringRange) | (VariableName "(" Subscript ("," Subscript)* ")" SubstringRange) ;
IntentSpec ::= "in" | "out" | ("in" "out") ;
EquivOp ::= ".eqv." | ".neqv." ;
AssumedSizeSpec ::= ((LowerBound ":")? "*") | (ExplicitShapeSpecList "," "*") | (ExplicitShapeSpecList "," LowerBound ":" "*") ;
ArraySpec ::= AssumedShapeSpecList | DeferredShapeSpecList | ExplicitShapeSpecList | AssumedSizeSpec ;
IoControlSpec ::= ("unit" "=" UnitIdentifier) | ("fmt" "=" FormatIdentifier) | ("nml" "=" NamelistGroupName) | ("rec" "=" Expr) | ("iostat" "=" ScalarVariable) | ("err" "=" LblRef) | ("end" "=" LblRef) | ("advance" "=" CExpr) | ("size" "=" Variable) | ("eor" "=" LblRef) ;
DataStmtObject ::= Variable | DataImpliedDo ;
BlankInterpEditDescr ::= "BN" | "BZ" ;
ExecutableConstruct ::= ActionStmt | DoConstruct | IfConstruct | CaseConstruct | WhereConstruct | EndDoStmt ;
Module ::= (ModuleStmt ModuleBody EndModuleStmt) | (ModuleStmt EndModuleStmt) ;
DataIDoObject ::= ArrayElement | DataImpliedDo | StructureComponent ;
PointerStmt ::= (LblDef "pointer" ":" ":" PointerStmtObjectList EOS) | (LblDef "pointer" PointerStmtObjectList EOS) ;
ArrayElement ::= (StructureComponent "(" SectionSubscriptList ")") | (VariableName "(" SectionSubscriptList ")") ;
SFFactor ::= SFPrimary | (SFPrimary PowerOp MultOperand) ;
AssumedShapeSpecList ::= (LowerBound ":") | (DeferredShapeSpecList "," LowerBound ":") | (AssumedShapeSpecList "," AssumedShapeSpec) ;
InterfaceStmt ::= (LblDef "interface" GenericName EOS) | (LblDef "interface" GenericSpec EOS) | (LblDef "interface" EOS) ;
SubprogramInterfaceBody ::= SpecificationPartConstruct | (SubprogramInterfaceBody SpecificationPartConstruct) ;
CharSelector ::= ("(" "len" "=" TypeParamValue "," "kind" "=" Expr ")") | ("(" "len" "=" TypeParamValue "," Expr ")") | ("(" "len" "=" TypeParamValue ")") | ("(" ("kind" "=")? Expr ")") ;
EndModuleStmt ::= (LblDef "end" EOS) | (LblDef "end" "module" EndName? EOS) ;
UnitIdentifier ::= UFExpr | "*" ;
DataEditDescr ::= ("I" Icon ("." Icon)?) | ("O" Icon ("." Icon)?) | ("B" Icon ("." Icon)?) | ("Z" Icon ("." Icon)?) | ("F" Icon "." Icon) | ("E" Icon "." Icon ("E" Icon)?) | ("EN" Icon "." Icon ("E" Icon)?) | ("ES" Icon "." Icon ("E" Icon)?) | ("G" Icon "." Icon ("E" Icon)?) | ("L" Icon) | ("A" Icon?) | ("D" Icon "." Icon) ;
ImplicitStmt ::= (LblDef "implicit" "none" EOS) | (LblDef "implicit" ImplicitSpec ("," ImplicitSpec)* EOS) ;
DoConstruct ::= BlockDoConstruct | LabelDoStmt ;
AccessStmt ::= (LblDef AccessSpec ":" ":" AccessIdList EOS) | (LblDef AccessSpec AccessIdList? EOS) ;
AttrSpec ::= "parameter" | AccessSpec | "allocatable" | ("dimension" "(" ArraySpec ")") | "external" | ("intent" "(" IntentSpec ")") | "intrinsic" | "optional" | "pointer" | "save" | "target" ;
EquivalenceObject ::= ArrayName | Variable ;
DataRef ::= (Name "%" Name) | (DataRef "%" Name) | (Name "(" SectionSubscriptList ")") | (DataRef "(" SectionSubscriptList ")") ;
OptionalStmt ::= (LblDef "optional" ":" ":" OptionalParList EOS) | (LblDef "optional" OptionalParList EOS) ;
CaseConstruct ::= (LblDef Name ":" "select" "case" "(" Expr ")" EOS SelectCaseRange) | (LblDef "select" "case" "(" Expr ")" EOS SelectCaseRange) ;
CallStmt ::= (LblDef "call" SubroutineNameUse EOS) | (LblDef "call" SubroutineNameUse "(" (ActualArg ("," ActualArg)*)? ")" EOS) ;
Level2Expr ::= ((Level2Expr AddOp)? AddOperand) | (Sign AddOperand) ;
UnsignedArithmeticConstant ::= (Icon "_" KindParam) | (Rcon "_" KindParam) | Icon | Rcon | ComplexConst ;
SFTerm ::= SFFactor | (SFTerm MultOp MultOperand) ;
AccessSpec ::= "public" | "private" ;
SubroutinePar ::= DummyArgName | "*" ;
BlockDataSubprogram ::= (BlockDataStmt BlockDataBody EndBlockDataStmt) | (BlockDataStmt EndBlockDataStmt) ;
InterfaceBody ::= (LblDef FunctionPrefix FunctionName FunctionInterfaceRange) | (LblDef "subroutine" SubroutineName SubroutineInterfaceRange) ;
ControlEditDescr ::= PositionEditDescr | (Icon? "/") | ":" | SignEditDescr | (("-" | "+")? Icon "P" (Icon? DataEditDescr)?) | BlankInterpEditDescr ;
ComponentArraySpec ::= ExplicitShapeSpecList | DeferredShapeSpecList ;
RdFmtId ::= LblRef | "*" | COperand | (COperand ConcatOp CPrimary) | (RdFmtIdExpr ConcatOp CPrimary) ;
AssignmentStmt ::= (LblDef Name "%" Name "=" Expr EOS) | (LblDef Name "%" DataRef "=" Expr EOS) | (LblDef Name "(" SFExprList ")" "%" Name "=" Expr EOS) | (LblDef Name "(" SFExprList ")" "%" DataRef "=" Expr EOS) | (LblDef Name "(" SFDummyArgNameList ")" "%" Name "=" Expr EOS) | (LblDef Name "(" SFDummyArgNameList ")" "%" DataRef "=" Expr EOS) | (LblDef Name "=" Expr EOS) | (LblDef Name "(" SFExprList ")" "=" Expr EOS) | (LblDef Name "(" SFExprList ")" SubstringRange "=" Expr EOS) ;
MultOp ::= "*" | "/" ;
IoControlSpecList ::= (UnitIdentifier "," FormatIdentifier?) | (UnitIdentifier "," IoControlSpec) | IoControlSpec | (IoControlSpecList "," IoControlSpec) ;
TargetObject ::= ObjectName | (ObjectName "(" ArraySpec ")") ;
CaseSelector ::= ("(" CaseValueRange ("," CaseValueRange)* ")") | "default" ;
AcValue ::= Expr | AcImpliedDo ;
ModuleBody ::= SpecificationPartConstruct | ModuleSubprogramPartConstruct | (ModuleBody SpecificationPartConstruct) | (ModuleBody ModuleSubprogramPartConstruct) ;
EntityDecl ::= (ObjectName "=" Expr) | (ObjectName "(" ArraySpec ")" "=" Expr) | (ObjectName "*" CharLength "=" Expr) | (ObjectName "*" CharLength "(" ArraySpec ")" "=" Expr) | ObjectName | (ObjectName "*" CharLength) | (ObjectName "(" ArraySpec ")") | (ObjectName "(" ArraySpec ")" "*" CharLength) ;
SpecificationStmt ::= AccessStmt | AllocatableStmt | CommonStmt | DataStmt | DimensionStmt | EquivalenceStmt | ExternalStmt | IntrinsicStmt | SaveStmt | IntentStmt | NamelistStmt | OptionalStmt | PointerStmt | TargetStmt ;
AllocatableStmt ::= (LblDef "allocatable" ":" ":" ArrayAllocationList EOS) | (LblDef "allocatable" ArrayAllocationList EOS) ;
ComponentAttrSpec ::= "pointer" | ("dimension" "(" ComponentArraySpec ")") ;
SubroutineInterfaceRange ::= (SubroutineParList EOS SubprogramInterfaceBody EndSubroutineStmt) | (SubroutineParList EOS EndSubroutineStmt) ;
EndBlockDataStmt ::= (LblDef "end" "block" "data" EndName? EOS) | (LblDef "end" EOS) ;
RewindStmt ::= (LblDef "rewind" UnitIdentifier EOS) | (LblDef "rewind" "(" PositionSpec ("," PositionSpec)* ")" EOS) ;
AddOp ::= "+" | "-" ;
UFFactor ::= UFPrimary | (UFPrimary PowerOp UFFactor) ;
DerivedTypeStmt ::= (LblDef "type" TypeName EOS) | (LblDef "type" ":" ":" TypeName EOS) | (LblDef "type" "," AccessSpec ":" ":" TypeName EOS) ;
CPrimary ::= COperand | ("(" CExpr ")") ;
ActionStmt ::= AllocateStmt | CycleStmt | DeallocateStmt | ExitStmt | NullifyStmt | PointerAssignmentStmt | WhereStmt | ArithmeticIfStmt | AssignmentStmt | AssignStmt | BackspaceStmt | CallStmt | CloseStmt | ContinueStmt | EndfileStmt | GotoStmt | ComputedGotoStmt | AssignedGotoStmt | IfStmt | InquireStmt | OpenStmt | PauseStmt | PrintStmt | ReadStmt | ReturnStmt | RewindStmt | StopStmt | WriteStmt ;
EntryStmt ::= (LblDef "entry" EntryName SubroutineParList EOS) | (LblDef "entry" EntryName SubroutineParList "result" "(" Name ")" EOS) ;
RelOp ::= "==" | "/=" | "<" | "<=" | ">" | ">=" | ".eq." | ".ne." | ".lt." | ".le." | ".gt." | ".ge." ;
KindParam ::= Icon | NamedConstantUse ;
TypeSpec ::= ("integer" KindSelector) | ("real" KindSelector) | ("double" "precision") | ("complex" KindSelector) | ("character" CharSelector) | ("logical" KindSelector) | ("type" "(" TypeName ")") | "integer" | "real" | "complex" | "logical" | "character" | ("character" LengthSelector) ;
BodyConstruct ::= SpecificationPartConstruct | ExecutableConstruct ;
OutputImpliedDo ::= ("(" OutputItemList "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" OutputItemList "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") ;
SelectCaseRange ::= (SelectCaseBody EndSelectStmt) | EndSelectStmt ;
UFPrimary ::= Icon | Scon | Name | FunctionReference | DataRef | ("(" UFExpr ")") ;
AcImpliedDo ::= ("(" Expr "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" Expr "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") | ("(" AcImpliedDo "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" AcImpliedDo "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") ;
SFPrimary ::= ArrayConstructor | Icon | Name | DataRef | FunctionReference | ("(" Expr ")") ;
DimensionStmt ::= (LblDef "dimension" ":" ":" ArrayDeclaratorList EOS) | (LblDef "dimension" ArrayDeclaratorList EOS) ;
PrivateSequenceStmt ::= (LblDef "private" EOS) | (LblDef "sequence" EOS) ;
SavedEntity ::= VariableName | ("/" CommonBlockName "/") ;
UFExpr ::= UFTerm | (Sign UFTerm) | (UFExpr AddOp UFTerm) ;
FunctionRange ::= (FunctionParList EOS Body? EndFunctionStmt) | (FunctionParList "result" "(" Name ")" EOS InternalSubProgPart EndFunctionStmt) | (FunctionParList "result" "(" Name ")" EOS Body EndFunctionStmt) | (FunctionParList "result" "(" Name ")" EOS EndFunctionStmt) | (FunctionParList EOS InternalSubProgPart EndFunctionStmt) ;
PointerStmtObject ::= ObjectName | (ObjectName "(" DeferredShapeSpecList ")") ;
CommonBlockObject ::= VariableName | ArrayDeclarator ;
FormatIdentifier ::= LblRef | CExpr | "*" ;
EndfileStmt ::= (LblDef "end" "file" UnitIdentifier EOS) | (LblDef "end" "file" "(" PositionSpec ("," PositionSpec)* ")" EOS) ;
EndFunctionStmt ::= (LblDef "end" EOS) | (LblDef "end" "function" EndName? EOS) ;
DerivedTypeBody ::= PrivateSequenceStmt | ComponentDefStmt ;
TargetStmt ::= (LblDef "target" ":" ":" TargetObjectList EOS) | (LblDef "target" TargetObjectList EOS) ;
ModuleSubprogramPartConstruct ::= ContainsStmt | ModuleSubprogram ;
GenericSpec ::= ("operator" "(" DefinedOperator ")") | ("assignment" "(" "=" ")") ;
ExecutionPartConstruct ::= ExecutableConstruct | FormatStmt | DataStmt | EntryStmt ;
ProgramUnit ::= MainProgram | FunctionSubprogram | SubroutineSubprogram | Module | BlockDataSubprogram ;
EndSubroutineStmt ::= (LblDef "end" "subroutine" EndName? EOS) | (LblDef "end" EOS) ;
InterfaceBlockPart ::= InterfaceBody | ModuleProcedureStmt ;
COperand ::= Scon | Name | DataRef | FunctionReference ;
BozLiteralConstant ::= BinaryConstant | OctalConstant | HexConstant ;
SaveStmt ::= (LblDef "save" ":" ":" SavedEntityList EOS) | (LblDef "save" SavedEntityList? EOS) ;
LengthSelector ::= ("(" TypeParamValue ")") | ("*" CharLength) ;
InternalSubprogram ::= FunctionSubprogram | SubroutineSubprogram ;
SpecificationPartConstruct ::= ImplicitStmt | ParameterStmt | FormatStmt | EntryStmt | DeclarationConstruct | UseStmt ;
--------------------fortran::waite-cordy.bgf--------------------
EndSelectStmt ::= (LblDef "endselect" EndName? EOS) | (LblDef "end" "select" EndName? EOS) ;
Comlist ::= (Comblock? CommonBlockObject) | (Comlist "," Comblock? CommonBlockObject) | (Comlist Comblock CommonBlockObject) ;
NamelistGroups ::= ("/" NamelistGroupName "/" NamelistGroupObject) | (NamelistGroups "/" NamelistGroupName "/" NamelistGroupObject) | (NamelistGroups "," "/" NamelistGroupName "/" NamelistGroupObject) | (NamelistGroups "," NamelistGroupObject) ;
EndTypeStmt ::= (LblDef "endtype" TypeName EOS) | (LblDef "endtype" EOS) | (LblDef "end" "type" TypeName EOS) | (LblDef "end" "type" EOS) ;
FunctionArgList ::= FunctionArg | (FunctionArgList "," FunctionArg) | (SectionSubscriptList "," FunctionArg) ;
AllocateObject ::= VariableName | (AllocateObject FieldSelector) ;
RdIoCtlSpecList ::= (UnitIdentifier "," IoControlSpec) | (UnitIdentifier "," FormatIdentifier) | IoControlSpec | (RdIoCtlSpecList "," IoControlSpec) ;
CharLength ::= ("(" TypeParamValue ")") | Constant ;
ArrayAllocation ::= ArrayName | (ArrayName "(" DeferredShapeSpecList ")") ;
BlockDataBody ::= BlockDataBodyConstruct | (BlockDataBody BlockDataBodyConstruct) ;
SubprogramInterfaceBody ::= SpecificationPartConstruct | (SubprogramInterfaceBody SpecificationPartConstruct) ;
CharSelector ::= ("(" "len=" TypeParamValue "," "kind=" Expr ")") | ("(" "len=" TypeParamValue "," Expr ")") | ("(" "len=" TypeParamValue ")") | ("(" "kind=" Expr ")") | ("(" Expr ")") ;
PrintStmt ::= (LblDef "print" FormatIdentifier "," OutputItemList EOS) | (LblDef "print" FormatIdentifier EOS) ;
EditElement ::= Fcon | MislexedFcon | Scon | Hcon | Ident | ("(" FmtSpec ")") ;
ModuleSubprogram ::= FunctionSubprogram | SubroutineSubprogram ;
EndModuleStmt ::= (LblDef "endmodule" EndName? EOS) | (LblDef "end" "module" EndName? EOS) | (LblDef "end" EOS) ;
UnitIdentifier ::= UFExpr | "*" ;
AccessStmt ::= (LblDef AccessSpec ColonColon? AccessIdList EOS) | (LblDef AccessSpec EOS) ;
AttrSpec ::= "parameter" | AccessSpec | "allocatable" | ("dimension" "(" ArraySpec ")") | "external" | ("intent" "(" IntentSpec ")") | "intrinsic" | "optional" | "pointer" | "save" | "target" ;
StructureComponent ::= (VariableName FieldSelector) | (StructureComponent FieldSelector) ;
Datalist ::= DataStmtSet | (Datalist? ","? DataStmtSet) ;
CaseConstruct ::= (LblDef Name ":" "selectcase" "(" Expr ")" EOS SelectCaseRange) | (LblDef "selectcase" "(" Expr ")" EOS SelectCaseRange) | (LblDef Name ":" "select" "case" "(" Expr ")" EOS SelectCaseRange) | (LblDef "select" "case" "(" Expr ")" EOS SelectCaseRange) ;
Formatsep ::= "/" | ":" ;
CallStmt ::= (LblDef "call" SubroutineNameUse EOS) | (LblDef "call" SubroutineNameUse "(" SubroutineArgList ")" EOS) ;
CaseBodyConstruct ::= CaseStmt | ExecutionPartConstruct ;
ImplicitSpec ::= (TypeSpec ImplicitRanges) | (TypeSpec "(" ImplicitRanges ")") ;
AccessSpec ::= "public" | "private" ;
DataStmtValue ::= Constant | (Constant "*" Constant) | (NamedConstantUse "*" Constant) ;
OutputItemList1 ::= (Expr "," Expr) | (Expr "," OutputImpliedDo) | OutputImpliedDo | (OutputItemList1 "," Expr) | (OutputItemList1 "," OutputImpliedDo) ;
TypeParamValue ::= Expr | "*" ;
PointerField ::= (Name SFExprListRef? "%" Name) | (PointerField FieldSelector) ;
Sign ::= "+" | "-" ;
InputItem ::= NameDataRef | InputImpliedDo ;
SubroutinePar ::= DummyArgName | "*" ;
InterfaceBody ::= (LblDef FunctionPrefix FunctionName FunctionInterfaceRange) | (LblDef "subroutine" SubroutineName SubroutineInterfaceRange) ;
BlockDataSubprogram ::= (BlockDataStmt BlockDataBody EndBlockDataStmt) | (BlockDataStmt EndBlockDataStmt) ;
FieldSelector ::= ("(" SectionSubscriptList ")" "%" Name) | ("%" Name) ;
AssignedGotoStmt ::= (LblDef GoToKw VariableName EOS) | (LblDef GoToKw VariableName "(" LblRefList ")" EOS) | (LblDef GoToKw VariableComma "(" LblRefList ")" EOS) ;
ComponentArraySpec ::= ExplicitShapeSpecList | DeferredShapeSpecList ;
PlusMinus ::= "+" | "-" ;
RdFmtId ::= LblRef | "*" | COperand | (COperand ConcatOp CPrimary) | (RdFmtIdExpr ConcatOp CPrimary) ;
EndWhereStmt ::= (LblDef "endwhere" EOS) | (LblDef "end" "where" EOS) ;
AttrSpecSeq ::= ("," AttrSpec) | (AttrSpecSeq "," AttrSpec) ;
MultOp ::= "*" | "/" ;
WhereConstruct ::= (Where EndWhereStmt) | (ElseWhere EndWhereStmt) ;
TargetObject ::= ObjectName | (ObjectName "(" ArraySpec ")") ;
ComponentDefStmt ::= (LblDef TypeSpec "," ComponentAttrSpecList "::" ComponentDeclList EOS) | (LblDef TypeSpec "::" ComponentDeclList EOS) | (LblDef TypeSpec ComponentDeclList EOS) ;
IoControlSpecList ::= (UnitIdentifier "$" ",") | (UnitIdentifier "," FormatIdentifier) | (UnitIdentifier "," IoControlSpec) | IoControlSpec | (IoControlSpecList "," IoControlSpec) ;
UseStmt ::= (LblDef "use" Name EOS) | (LblDef "use" Name "," "only" ":" EOS) | (LblDef "use" Name "," RenameList EOS) | (LblDef "use" Name "," "only" ":" OnlyList EOS) ;
CaseSelector ::= ("(" CaseValueRangeList ")") | "default" ;
ModuleBody ::= SpecificationPartConstruct | ModuleSubprogramPartConstruct | (ModuleBody SpecificationPartConstruct) | (ModuleBody ModuleSubprogramPartConstruct) ;
ComplexComponent ::= (Sign? Icon) | RDcon | Name ;
Only ::= GenericSpec | (Ident "=>" UseName) | UseName ;
Comblock ::= ("/" SPOFF "/" SPON) | ("/" CommonBlockName "/") ;
ComponentAttrSpec ::= "pointer" | ("dimension" "(" ComponentArraySpec ")") ;
FmtSpec ::= Formatedit | Formatsep | (Formatsep Formatedit) | (FmtSpec Formatsep) | (FmtSpec Formatsep Formatedit) | (FmtSpec "," Formatedit) | (FmtSpec "," Formatsep) | (FmtSpec "," Formatsep Formatedit) ;
Where ::= WhereConstructStmt | (Where AssignmentStmt) ;
BackspaceStmt ::= (LblDef "backspace" UnitIdentifier EOS) | (LblDef "backspace" "(" PositionSpecList ")" EOS) ;
FunctionParList ::= ("(" FunctionPars ")") | ε ;
DeallocateStmt ::= (LblDef "deallocate" "(" AllocateObjectList "," "stat=" Variable ")" EOS) | (LblDef "deallocate" "(" AllocateObjectList ")" EOS) ;
SectionSubscript ::= (Expr SubscriptTripletTail?) | SubscriptTripletTail ;
AllocateStmt ::= (LblDef "allocate" "(" AllocationList "," "stat=" Variable ")" EOS) | (LblDef "allocate" "(" AllocationList ")" EOS) ;
AssumedShapeSpec ::= (LowerBound ":") | ":" ;
AcValueList1 ::= (Expr "," Expr) | (Expr "," AcImpliedDo) | AcImpliedDo | (AcValueList1 "," Expr) | (AcValueList1 "," AcImpliedDo) ;
RdCtlSpec ::= RdUnitId | ("(" RdIoCtlSpecList ")") ;
RewindStmt ::= (LblDef "rewind" UnitIdentifier EOS) | (LblDef "rewind" "(" PositionSpecList ")" EOS) ;
AddOp ::= "+" | "-" ;
UFFactor ::= UFPrimary | (UFPrimary PowerOp UFFactor) ;
AccessId ::= GenericName | GenericSpec ;
DerivedTypeStmt ::= (LblDef "type" TypeName EOS) | (LblDef "type" "::" TypeName EOS) | (LblDef "type" "," AccessSpec "::" TypeName EOS) ;
CPrimary ::= COperand | ("(" CExpr ")") ;
DerivedTypeBodyConstruct ::= PrivateSequenceStmt | ComponentDefStmt ;
CaseValueRange ::= Expr | (Expr ":") | (":" Expr) | (Expr ":" Expr) ;
PointerObject ::= Name | PointerField ;
BodyPlusInternals ::= (Body ContainsStmt InternalSubprogram) | (ContainsStmt InternalSubprogram) | (BodyPlusInternals InternalSubprogram) ;
KindParam ::= Icon | NamedConstantUse ;
CaseStmt ::= (LblDef "case" CaseSelector EOS) | (LblDef "case" CaseSelector Name EOS) ;
InterfaceBlockBody ::= InterfaceBodyPartConstruct | (InterfaceBlockBody InterfaceBodyPartConstruct) ;
BodyConstruct ::= SpecificationPartConstruct | ExecutableConstruct ;
KindSelector ::= ("(" "kind=" Expr ")") | ("(" Expr ")") ;
CloseSpec ::= ("unit=" UnitIdentifier) | ("err=" LblRef) | ("status=" CExpr) | ("iostat=" ScalarVariable) ;
PointerAssignmentStmt ::= (LblDef Name "=>" Target EOS) | (LblDef Name SFExprListRef? "%" NameDataRef "=>" Target EOS) ;
OutputImpliedDo ::= ("(" Expr "," ImpliedDoVariable "=" Expr "," Expr CommaExpr? ")") | ("(" OutputItemList1 "," ImpliedDoVariable "=" Expr "," Expr CommaExpr? ")") ;
CommentOrNewline ::= comment | newline ;
SelectCaseRange ::= (SelectCaseBody EndSelectStmt) | EndSelectStmt ;
AcImpliedDo ::= ("(" Expr "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" Expr "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") | ("(" AcImpliedDo "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" AcImpliedDo "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") ;
UFPrimary ::= Icon | Scon | NameDataRef | FunctionReference | ("(" UFExpr ")") ;
RdUnitId ::= ("(" UFExpr ")") | ("(" "*" ")") ;
SelectCaseBody ::= CaseStmt | (SelectCaseBody CaseBodyConstruct) ;
DefinedOperator ::= Dop | PowerOp | MultOp | AddOp | RelOp | ConcatOp | NotOp | AndOp | OrOp | EquivOp ;
PrivateSequenceStmt ::= (LblDef "private" EOS) | (LblDef "sequence" EOS) ;
IconOrScon ::= Icon | Scon ;
SavedEntity ::= VariableName | SavedCommonBlock ;
DataImpliedDo ::= ("(" DataIDoObjectList "," ImpliedDoVariable "=" Expr "," Expr ")") | ("(" DataIDoObjectList "," ImpliedDoVariable "=" Expr "," Expr "," Expr ")") ;
ScalarVariable ::= VariableName | ArrayElement ;
ComponentDecl ::= (ComponentName "(" ComponentArraySpec ")" "*" CharLength) | (ComponentName "(" ComponentArraySpec ")") | (ComponentName "*" CharLength) | ComponentName ;
EndInterfaceStmt ::= (LblDef "endinterface" EOS) | (LblDef "end" "interface" EOS) ;
UFExpr ::= UFTerm | (Sign UFTerm) | (UFExpr AddOp UFTerm) ;
PointerStmtObject ::= ObjectName | (ObjectName "(" DeferredShapeSpecList ")") ;
PositionSpec ::= ("unit=" UnitIdentifier) | ("err=" LblRef) | ("iostat=" ScalarVariable) ;
MislexedFcon ::= (RDcon SPOFF RDcon SPON) | (Ident SPOFF RDcon SPON) ;
Formatedit ::= EditElement | (Icon EditElement) | Xcon | Pcon | (Pcon EditElement) | (Pcon Icon EditElement) ;
CommonBlockObject ::= VariableName | ArrayDeclarator ;
FormatIdentifier ::= LblRef | CExpr | "*" ;
ReadStmt ::= (LblDef "read" RdCtlSpec InputItemList? EOS) | (LblDef "read" RdFmtId CommaInputItemList? EOS) ;
UFTerm ::= UFFactor | (UFTerm MultOp UFFactor) | (UFTerm ConcatOp UFPrimary) ;
SubroutineParList ::= ("(" SubroutinePars ")") | ε ;
DerivedTypeBody ::= DerivedTypeBodyConstruct | (DerivedTypeBody DerivedTypeBodyConstruct) ;
IntentSpec ::= "in" | "out" | "inout" ;
EquivOp ::= (SP ".eqv." SP) | (SP ".neqv." SP) ;
ModuleSubprogramPartConstruct ::= ContainsStmt | ModuleSubprogram ;
AssumedSizeSpec ::= "*" | (LowerBound ":" "*") | (ExplicitShapeSpecList "," "*") | (ExplicitShapeSpecList "," LowerBound ":" "*") ;
GenericSpec ::= ("operator" "(" DefinedOperator ")") | ("assignment" "(" "=" ")") ;
OutputItemList ::= Expr | OutputItemList1 ;
DataStmtObject ::= Variable | DataImpliedDo ;
LblDef ::= ε | (TAB_2 Label TAB_7) ;
EndDoStmt ::= (LblDef "enddo" EndName? EOS) | (LblDef "end" "do" EndName? EOS) ;
ElseWhere ::= (Where ElsewhereStmt) | (ElseWhere AssignmentStmt) ;
AcValueList ::= Expr | AcValueList1 ;
Module ::= (ModuleStmt ModuleBody EndModuleStmt) | (ModuleStmt EndModuleStmt) ;
InterfaceBodyPartConstruct ::= InterfaceBody | ModuleProcedureStmt ;
ExplicitShapeSpec ::= (LowerBound ":" UpperBound) | UpperBound ;
BozLiteralConstant ::= Bcon | Ocon | Zcon ;
COperand ::= Scon | NameDataRef | FunctionReference ;
AssumedShapeSpecList ::= (LowerBound ":") | (DeferredShapeSpecList "," LowerBound ":") | (AssumedShapeSpecList "," AssumedShapeSpec) ;
InterfaceStmt ::= (LblDef "interface" GenericName EOS) | (LblDef "interface" GenericSpec EOS) | (LblDef "interface" EOS) ;
InternalSubprogram ::= FunctionSubprogram | SubroutineSubprogram ;
Allocation ::= AllocateObject | (AllocateObject AllocatedShape) ;
--------------------java::jdt.bgf--------------------
AssignementOperatorKind ::= (RIGHT_SHIFT_SIGNED_ASSIGN::ε) | (BIT_XOR_ASSIGN::ε) | (TIMES_ASSIGN::ε) | (LEFT_SHIFT_ASSIGN::ε) | (MINUS_ASSIGN::ε) | (BIT_OR_ASSIGN::ε) | (PLUS_ASSIGN::ε) | (ASSIGN::ε) | (RIGHT_SHIFT_UNSIGNED_ASSIGN::ε) | (REMAINDER_ASSIGN::ε) | (DIVIDE_ASSIGN::ε) | (BIT_AND_ASSIGN::ε) ;
PrefixExpresssionOperatorKind ::= (MINUS::ε) | (NOT::ε) | (DECREMENT::ε) | (COMPLEMENT::ε) | (INCREMENT::ε) | (PLUS::ε) ;
PostfixExpresssionOperatorKind ::= (INCREMENT::ε) | (DECREMENT::ε) ;
Boolean ::= "true" | "false" ;
InfixExpressionOperatorKind ::= (GREATER_EQUALS::ε) | (OR::ε) | (RIGHT_SHIFT_SIGNED::ε) | (MINUS::ε) | (XOR::ε) | (LESS_EQUALS::ε) | (EQUALS::ε) | (NOT_EQUALS::ε) | (AND::ε) | (PLUS::ε) | (GREATER::ε) | (CONDITIONAL_OR::ε) | (REMAINDER::ε) | (LESS::ε) | (LEFT_SHIFT::ε) | (RIGHT_SHIFT_UNSIGNED::ε) | (CONDITIONAL_AND::ε) | (TIMES::ε) | (DIVIDE::ε) ;
--------------------java::java-5-habelitz.bgf--------------------
ESCAPE_SEQUENCE ::= ("\\" "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | UNICODE_ESCAPE | OCTAL_ESCAPE ;
annotationScopeDeclarations ::= (modifierList type (IDENT LPAREN RPAREN annotationDefaultValue? SEMI) | (classFieldDeclaratorList SEMI)) | typeDeclaration ;
JAVA_ID_START ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
type ::= simpleType | objectType ;
primaryExpression ::= parenthesizedExpression | literal | newExpression | qualifiedIdentExpression | (genericTypeArgumentListSimplified (SUPER arguments | (DOT IDENT arguments)) | (IDENT arguments) | (THIS arguments)) | (THIS arguments?) | (SUPER arguments) | (SUPER DOT IDENT arguments | ε) | (primitiveType arrayDeclarator* DOT CLASS) | (VOID DOT CLASS) ;
JAVA_ID_PART ::= JAVA_ID_START | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
forInit ::= localVariableDeclaration | expressionList | ε ;
modifier ::= PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP | localModifier ;
classScopeDeclarations ::= block | (STATIC block) | (modifierList (genericTypeParameterList? (type IDENT formalParameterList arrayDeclaratorList? throwsClause? block | SEMI) | (VOID IDENT formalParameterList throwsClause? block | SEMI) | (ident::IDENT formalParameterList throwsClause? block)) | (type classFieldDeclaratorList SEMI)) | typeDeclaration | SEMI ;
OCTAL_ESCAPE ::= ("0" | "1" | "2" | "3" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") | ("\\" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") | ("\\" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ;
INTEGER_TYPE_SUFFIX ::= "l" | "L" ;
interfaceScopeDeclarations ::= (modifierList (genericTypeParameterList? (type IDENT formalParameterList arrayDeclaratorList? throwsClause? SEMI) | (VOID IDENT formalParameterList throwsClause? SEMI)) | (type interfaceFieldDeclaratorList SEMI)) | typeDeclaration | SEMI ;
FLOAT_TYPE_SUFFIX ::= "f" | "F" | "d" | "D" ;
typeDecls ::= typeDeclaration | SEMI ;
statement ::= block | (ASSERT expr1::expression (COLON expr2::expression SEMI) | SEMI) | (IF parenthesizedExpression ifStat::statement (ELSE elseStat::statement) | ε) | (FOR LPAREN (forInit SEMI forCondition SEMI forUpdater RPAREN statement) | (localModifierList type IDENT COLON expression RPAREN statement)) | (WHILE parenthesizedExpression statement) | (DO statement WHILE parenthesizedExpression SEMI) | (TRY block (catches finallyClause?) | finallyClause) | (SWITCH parenthesizedExpression LCURLY switchBlockLabels RCURLY) | (SYNCHRONIZED parenthesizedExpression block) | (RETURN expression? SEMI) | (THROW expression SEMI) | (BREAK IDENT? SEMI) | (CONTINUE IDENT? SEMI) | (IDENT COLON statement) | (expression SEMI) | SEMI ;
literal ::= HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | FLOATING_POINT_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | TRUE | FALSE | NULL ;
genericTypeArgument ::= type | (QUESTION genericWildcardBoundType?) ;
unaryExpressionNotPlusMinus ::= (NOT unaryExpression) | (LOGICAL_NOT unaryExpression) | (LPAREN type RPAREN unaryExpression) | postfixedExpression ;
newArrayConstruction ::= (arrayDeclaratorList arrayInitializer) | (LBRACK expression RBRACK (LBRACK expression RBRACK)* arrayDeclaratorList?) ;
HEX_DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;
FLOATING_POINT_LITERAL ::= (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ (DOT ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? FLOAT_TYPE_SUFFIX?) | (EXPONENT FLOAT_TYPE_SUFFIX?) | FLOAT_TYPE_SUFFIX) | (DOT ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? FLOAT_TYPE_SUFFIX?) ;
unaryExpression ::= (PLUS unaryExpression) | (MINUS unaryExpression) | (INC postfixedExpression) | (DEC postfixedExpression) | unaryExpressionNotPlusMinus ;
genericTypeListClosing ::= GREATER_THAN | SHIFT_RIGHT | BIT_SHIFT_RIGHT | ε ;
genericTypeArgumentSimplified ::= type | QUESTION ;
variableInitializer ::= arrayInitializer | expression ;
annotationElementValue ::= annotationElementValueExpression | annotation | annotationElementValueArrayInitializer ;
localModifier ::= FINAL | annotation ;
blockStatement ::= (localVariableDeclaration SEMI) | typeDeclaration | statement ;
primitiveType ::= BOOLEAN | CHAR | BYTE | SHORT | INT | LONG | FLOAT | DOUBLE ;
annotationInitializers ::= (annotationInitializer (COMMA annotationInitializer)*) | annotationElementValue ;
--------------------java::jvm-level0.bgf--------------------
Instruction ::= (fieldRef::(opcode::integer() owner::string() name::string() description::string())) | (increment::(index::integer() amount::integer())) | (instruction::(opcode::integer())) | (integer::(opcode::integer() operand::integer())) | (jump::(opcode::integer() labelIndex::integer())) | (label::(index::integer())) | (lineNumber::(line::integer() labelIndex::integer())) | (localVariable::(opcode::integer() index::integer())) | (loadConstantString::(stringValue::string())) | (loadConstantInteger::(integerValue::integer())) | (loadConstantLong::(longValue::integer())) | (loadConstantFloat::(floatValue::integer())) | (loadConstantDouble::(doubleValue::integer())) | (lookupSwitch::(defaultLabelIndex::integer() keys::(integer()*) cases::(integer()*))) | (method::(opcode::integer() owner::string() name::string() description::string())) | (multiANewArray::(description::string() dimensions::integer())) | (tableSwitch::(minIndex::integer() maxIndex::integer() defaultLabelIndex::integer() cases::(integer()*))) | (type::(opcode::integer() description::string())) ;
TryCatchBlock ::= (tryCatchBlock::(startLabelIndex::integer() endLabelIndex::integer() handlerLabelIndex::integer() type::string())) | (finallyBlock::(startLabelIndex::integer() endLabelIndex::integer() handlerLabelIndex::integer())) ;
Field ::= (field::(access::integer() name::string() description::string() signature::string() value::α)) | (field::(access::integer() name::string() description::string() signature::string())) ;
Class ::= (class::(version::integer() access::integer() name::string() signature::string() superName::string() interfaces::(string()*) sourceFile::string() sourceDebug::string() outerClass::string() outerMethod::string() outerMethodDescription::string() innerClasses::(InnerClass*) fields::(Field*) methods::(Method*))) | (class::(version::integer() access::integer() name::string() signature::string() superName::string() interfaces::(string()*) innerClasses::(InnerClass*) fields::(Field*) methods::(Method*))) ;
InnerClass ::= (innerClass::(name::string() outerName::string() innerName::string() access::integer())) | (innerClass::(name::string() access::integer())) ;
--------------------java::java-5-parr.bgf--------------------
interfaceBodyDeclaration ::= (modifiers interfaceMemberDecl) | ";" ;
interfaceMemberDecl ::= interfaceMethodOrFieldDecl | interfaceGenericMethodDecl | ("void" Identifier voidInterfaceMethodDeclaratorRest) | interfaceDeclaration | classDeclaration ;
type ::= (classOrInterfaceType ("[" "]")*) | (primitiveType ("[" "]")*) ;
forInit ::= localVariableDeclaration | expressionList ;
castExpression ::= ("(" primitiveType ")" unaryExpression) | ("(" type | expression ")" unaryExpressionNotPlusMinus) ;
classOrInterfaceModifier ::= annotation | "public" | "protected" | "private" | "abstract" | "static" | "final" | "strictfp" ;
variableModifier ::= "final" | annotation ;
HexDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;
interfaceMethodOrFieldRest ::= (constantDeclaratorsRest ";") | interfaceMethodDeclaratorRest ;
literal ::= integerLiteral | FloatingPointLiteral | CharacterLiteral | StringLiteral | booleanLiteral | "null" ;
statement ::= block | (ASSERT expression (":" expression)? ";") | ("if" parExpression statement ("else" statement)?) | ("for" "(" forControl ")" statement) | ("while" parExpression statement) | ("do" statement "while" parExpression ";") | ("try" block (catches "finally" block) | catches | ("finally" block)) | ("switch" parExpression "{" switchBlockStatementGroups "}") | ("synchronized" parExpression block) | ("return" expression? ";") | ("throw" expression ";") | ("break" Identifier? ";") | ("continue" Identifier? ";") | ";" | (statementExpression ";") | (Identifier ":" statement) ;
creator ::= (nonWildcardTypeArguments createdName classCreatorRest) | (createdName arrayCreatorRest | classCreatorRest) ;
superSuffix ::= arguments | ("." Identifier arguments?) ;
annotationMethodOrConstantRest ::= annotationMethodRest | annotationConstantRest ;
unaryExpressionNotPlusMinus ::= ("~" unaryExpression) | ("!" unaryExpression) | castExpression | (primary selector* ("++" | "--")?) ;
IntegerTypeSuffix ::= "l" | "L" ;
relationalOp ::= (t1::"<" t2::("="?)) | (t1::">" t2::("="?)) | "<" | ">" ;
booleanLiteral ::= "true" | "false" ;
annotationTypeElementRest ::= (type annotationMethodOrConstantRest ";") | (normalClassDeclaration ";"?) | (normalInterfaceDeclaration ";"?) | (enumDeclaration ";"?) | (annotationTypeDeclaration ";"?) ;
unaryExpression ::= ("+" unaryExpression) | ("-" unaryExpression) | ("++" unaryExpression) | ("--" unaryExpression) | unaryExpressionNotPlusMinus ;
compilationUnit ::= (annotations (packageDeclaration importDeclaration* typeDeclaration*) | (classOrInterfaceDeclaration typeDeclaration*)) | (packageDeclaration? importDeclaration* typeDeclaration*) ;
memberDecl ::= genericMethodOrConstructorDecl | memberDeclaration | ("void" Identifier voidMethodDeclaratorRest) | (Identifier constructorDeclaratorRest) | interfaceDeclaration | classDeclaration ;
formalParameterDeclsRest ::= (variableDeclaratorId ("," formalParameterDecls)?) | ("..." variableDeclaratorId) ;
blockStatement ::= localVariableDeclarationStatement | classOrInterfaceDeclaration | statement ;
classDeclaration ::= normalClassDeclaration | enumDeclaration ;
typeDeclaration ::= classOrInterfaceDeclaration | ";" ;
switchLabel ::= ("case" constantExpression ":") | ("case" enumConstantName ":") | ("default" ":") ;
classBodyDeclaration ::= ";" | ("static"? block) | (modifiers memberDecl) ;
selector ::= ("." Identifier arguments?) | ("." "this") | ("." "super" superSuffix) | ("." "new" innerCreator) | ("[" expression "]") ;
identifierSuffix ::= (("[" "]")+ "." "class") | (("[" expression "]")+) | arguments | ("." "class") | ("." explicitGenericInvocation) | ("." "this") | ("." "super" arguments) | ("." "new" innerCreator) ;
modifier ::= annotation | "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "transient" | "volatile" | "strictfp" ;
typeArgument ::= type | ("?" ("extends" | "super" type)?) ;
explicitConstructorInvocation ::= (nonWildcardTypeArguments? "this" | "super" arguments ";") | (primary "." nonWildcardTypeArguments? "super" arguments ";") ;
elementValue ::= conditionalExpression | annotation | elementValueArrayInitializer ;
forControl ::= enhancedForControl | (forInit? ";" expression? ";" forUpdate?) ;
createdName ::= classOrInterfaceType | primitiveType ;
genericMethodOrConstructorRest ::= (type | "void" Identifier methodDeclaratorRest) | (Identifier constructorDeclaratorRest) ;
integerLiteral ::= HexLiteral | OctalLiteral | DecimalLiteral ;
assignmentOperator ::= "=" | "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "^=" | "%=" | (t1::"<" t2::"<" t3::"=") | (t1::">" t2::">" t3::">" t4::("="?)) | (t1::">" t2::">" t3::"=") ;
JavaIDDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
OctalEscape ::= ("\\" "0" | "1" | "2" | "3" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") | ("\\" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") | ("\\" "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ;
FloatTypeSuffix ::= "f" | "F" | "d" | "D" ;
variableInitializer ::= arrayInitializer | expression ;
Letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
FloatingPointLiteral ::= (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* Exponent? FloatTypeSuffix?) | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ Exponent? FloatTypeSuffix?) | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ Exponent FloatTypeSuffix?) | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ FloatTypeSuffix) ;
shiftOp ::= (t1::"<" t2::("<"?)) | (t1::">" t2::">" t3::">") | (t1::">" t2::(">"?)) ;
EscapeSequence ::= ("\\" "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | UnicodeEscape | OctalEscape ;
primary ::= parExpression | ("this" ("." Identifier)* identifierSuffix?) | ("super" superSuffix) | literal | ("new" creator) | (Identifier ("." Identifier)* identifierSuffix?) | (primitiveType ("[" "]")* "." "class") | ("void" "." "class") ;
interfaceDeclaration ::= normalInterfaceDeclaration | annotationTypeDeclaration ;
primitiveType ::= "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double" ;
--------------------java::java-5-stahl.bgf--------------------
typeArgumentsEnd ::= GT | SR | BSR ;
annotationInit ::= (lp::LPAREN (annotationMemberInit (COMMA annotationMemberInit)*) | annotationMemberValue | ε RPAREN) | ε ;
builtInType ::= "void" | "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" ;
typeArguments ::= (lt::LT typeArgument (COMMA typeArgument)* typeArgumentsEnd?) | ε ;
type ::= classOrInterfaceType | builtInType ;
primaryExpression ::= (identPrimary (DOT "class")?) | constant | "true" | "false" | "null" | newExpression | "this" | "super" | (LPAREN assignmentExpression RPAREN) | (builtInType (lbt::LBRACK RBRACK)* DOT "class") ;
modifier ::= "private" | "public" | "protected" | "static" | "transient" | "final" | "abstract" | "native" | "threadsafe" | "synchronized" | "volatile" | "strictfp" ;
typeArgument ::= (q::QUESTION (("extends" referenceTypeSpec) | ("super" referenceTypeSpec))?) | referenceTypeSpec ;
NUM_INT ::= ("." ("." ".") | ((("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? (f1::FLOAT_SUFFIX)?)?)) | (("0" (("x" | "X" HEX_DIGIT+) | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+) | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+))?) | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*) ("l" | "L" | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? (f2::FLOAT_SUFFIX)?) | (EXPONENT (f3::FLOAT_SUFFIX)?) | (f4::FLOAT_SUFFIX))?) ;
typeSpec ::= classTypeSpec | builtInTypeSpec ;
innerTypeDef ::= (ed::enumDefinition) | (cd::classDefinition) | (id::interfaceDefinition) | (ad::annotationTypeDefinition) ;
FLOAT_SUFFIX ::= "f" | "F" | "d" | "D" ;
argList ::= expressionList | ε ;
enumConstInit ::= (lp::LPAREN argList RPAREN) | ε ;
statement ::= compoundStatement | (declaration SEMI) | (expression SEMI) | (m::modifiers enumDefinition | classDefinition) | (IDENT c::COLON statement) | ("if" LPAREN expression RPAREN statement ("else" statement)?) | ("for" LPAREN (parameterDeclaration COLON expression) | (forInit SEMI forCond SEMI forIter) RPAREN statement) | ("while" LPAREN expression RPAREN statement) | ("do" statement "while" LPAREN expression RPAREN SEMI) | ("break" IDENT? SEMI) | ("continue" IDENT? SEMI) | ("return" expression? SEMI) | ("switch" LPAREN expression RPAREN LCURLY casesGroup* RCURLY) | tryBlock | ("throw" expression SEMI) | ("synchronized" LPAREN expression RPAREN compoundStatement) | (ASSERT expression (COLON expression)? SEMI) | (s::SEMI) ;
typeDefinition ::= (m::modifiers classDefinition | enumDefinition | interfaceDefinition | annotationTypeDefinition) | SEMI ;
NUM_DOUBLE ::= ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? "d" | "D") | ("0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ "." | EXPONENT | "d" | "D") | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* (("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? "d" | "D") | EXPONENT) ;
unaryExpressionNotPlusMinus ::= (BNOT unaryExpression) | (LNOT unaryExpression) | (lpb::LPAREN builtInTypeSpec RPAREN unaryExpression) | (lp::LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus) | postfixExpression ;
HEX_DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
annotationMemberValue ::= annotation | conditionalExpression | annotationMemberArrayInitializer ;
unaryExpression ::= (INC unaryExpression) | (DEC unaryExpression) | (MINUS unaryExpression) | (PLUS unaryExpression) | unaryExpressionNotPlusMinus ;
typeParameters ::= (lt::LT typeParameter (COMMA typeParameter)* typeArgumentsEnd?) | ε ;
constant ::= NUM_INT | CHAR_LITERAL | STRING_LITERAL | NUM_FLOAT | NUM_LONG | NUM_DOUBLE ;
NUM_FLOAT ::= ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? "f" | "F") | ("0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ "." | EXPONENT | "f" | "F") | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* (("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? "f" | "F") | EXPONENT) ;
initializer ::= expression | arrayInitializer ;
classField ::= (mods::modifiers (it::innerTypeDef) | (tp::typeParameters (h::ctorHead s::constructorBody) | (md::memberDef))) | ("static" s3::compoundStatement) | (s4::compoundStatement) ;
referenceTypeSpec ::= classTypeSpec | arrayTypeSpec ;
--------------------java::java-5-studman.bgf--------------------
builtInType ::= "void" | "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" ;
primaryExpression ::= (identPrimary (DOT "class")?) | constant | "true" | "false" | "null" | newExpression | "this" | "super" | (LPAREN assignmentExpression RPAREN) | (builtInType (lbt::LBRACK RBRACK)* DOT "class") ;
type ::= classOrInterfaceType | builtInType ;
annotationMemberValueInitializer ::= conditionalExpression | annotation | annotationMemberArrayInitializer ;
modifier ::= "private" | "public" | "protected" | "static" | "transient" | "final" | "abstract" | "native" | "threadsafe" | "synchronized" | "volatile" | "strictfp" ;
typeArgument ::= typeArgumentSpec | wildcardType ;
NUM_INT ::= ("." ((("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? (f1::FLOAT_SUFFIX)?) | "..")?) | (("0" (("x" | "X" HEX_DIGIT+) | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+) | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+))?) | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*) ("l" | "L" | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? (f2::FLOAT_SUFFIX)?) | (EXPONENT (f3::FLOAT_SUFFIX)?) | (f4::FLOAT_SUFFIX))?) ;
enumConstantField ::= (mods::modifiers (td::typeDefinitionInternal) | ((tp::typeParameters)? t::typeSpec (IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets (tc::throwsClause)? (s2::compoundStatement) | SEMI) | (v::variableDefinitions SEMI))) | (s4::compoundStatement) ;
typeSpec ::= classTypeSpec | builtInTypeSpec ;
FLOAT_SUFFIX ::= "f" | "F" | "d" | "D" ;
argList ::= expressionList | ε ;
typeArgumentsOrParametersEnd ::= GT | SR | BSR ;
typeArgumentSpec ::= classTypeSpec | builtInTypeArraySpec ;
statement ::= compoundStatement | (declaration SEMI) | (expression SEMI) | (m::modifiers classDefinition) | (IDENT c::COLON statement) | ("if" LPAREN expression RPAREN statement ("else" statement)?) | forStatement | ("while" LPAREN expression RPAREN statement) | ("do" statement "while" LPAREN expression RPAREN SEMI) | ("break" IDENT? SEMI) | ("continue" IDENT? SEMI) | ("return" expression? SEMI) | ("switch" LPAREN expression RPAREN LCURLY casesGroup* RCURLY) | tryBlock | ("throw" expression SEMI) | ("synchronized" LPAREN expression RPAREN compoundStatement) | ("assert" expression (COLON expression)? SEMI) | (s::SEMI) ;
typeDefinition ::= (m::modifiers typeDefinitionInternal) | SEMI ;
typeDefinitionInternal ::= classDefinition | interfaceDefinition | enumDefinition | annotationDefinition ;
unaryExpressionNotPlusMinus ::= (BNOT unaryExpression) | (LNOT unaryExpression) | (lpb::LPAREN builtInTypeSpec RPAREN unaryExpression) | (lp::LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus) | postfixExpression ;
NUM_DOUBLE ::= ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? "d" | "D") | ("0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ "." | EXPONENT | "d" | "D") | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* (("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? "d" | "D") | EXPONENT) ;
HEX_DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
unaryExpression ::= (INC unaryExpression) | (DEC unaryExpression) | (MINUS unaryExpression) | (PLUS unaryExpression) | unaryExpressionNotPlusMinus ;
annotationArguments ::= annotationMemberValueInitializer | anntotationMemberValuePairs ;
constant ::= NUM_INT | CHAR_LITERAL | STRING_LITERAL | NUM_FLOAT | NUM_LONG | NUM_DOUBLE ;
NUM_FLOAT ::= ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? "f" | "F") | ("0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ "." | EXPONENT | "f" | "F") | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* (("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? "f" | "F") | EXPONENT) ;
initializer ::= expression | arrayInitializer ;
classField ::= (mods::modifiers (td::typeDefinitionInternal) | ((tp::typeParameters)? (h::ctorHead s::constructorBody) | (t::typeSpec (IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets (tc::throwsClause)? (s2::compoundStatement) | SEMI) | (v::variableDefinitions SEMI)))) | ("static" s3::compoundStatement) | (s4::compoundStatement) ;
annotationMemberArrayValueInitializer ::= conditionalExpression | annotation ;
--------------------java::java-1-cordy-guo.bgf--------------------
add_op ::= "+" | "-" ;
variable_initializer ::= expression | array_initializer ;
shift_op ::= "<<" | ">>" | ">>>" ;
component ::= dot_id | method_argument | subscript ;
relational_op_shift_expression ::= (relational_op shift_expression) | ("instanceof" type_specifier) ;
relational_op ::= "<" | ">" | "<=" | ">=" ;
type_specifier ::= type_name | array_type_specifier ;
boolean_literal ::= "true" | "false" ;
declaration_or_statement ::= local_variable_declaration | class_declaration | statement ;
method_or_constructor_declaration ::= method_declaration | constructor_declaration ;
modifier ::= "abstract" | "final" | "public" | "protected" | "private" | "static" | "transient" | "volatile" | "native" | "synchronized" | "strictfp" ;
assignment_operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" ;
member_declaration ::= method_or_constructor_declaration | type_declaration ;
type_declaration ::= (class_declaration NL NL) | (interface_declaration NL NL) ;
primitive_type ::= "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double" | "void" ;
unary_op ::= "+" | "-" | "~" | "!" ;
mult_op ::= "*" | "/" | "%" ;
type_name ::= primitive_type | qualified_name ;
literal ::= numeric_literal | character_literal | string_literal | boolean_literal | null_literal ;
statement ::= label_statement | empty_statement | expression_statement | if_statement | switch_statement | while_statement | do_statement | for_statement | break_statement | continue_statement | return_statement | throw_statement | synchronized_statement | try_statement | block ;
assignment_expression ::= conditional_expression | (unary_expression assignment_operator assignment_expression) ;
switch_label ::= ("case" constant_expression ":") | ("default" ":") ;
unary_expression ::= (pre_inc_dec unary_expression) | (unary_op unary_expression) | postfix_expression | cast_expression ;
equality_op ::= "==" | "!=" ;
for_init ::= ({expression ","}* ";") | local_variable_declaration ;
pre_inc_dec ::= "++" | "--" ;
class_body_declaration ::= empty_declaration | member_declaration | instance_initializer | static_initializer | field_declaration ;
primary ::= literal | reference | ("(" expression ")" component*) | class_instance_creation_expression | array_creation_expression ;
post_inc_dec ::= "++" | "--" ;
method_body ::= (block NL NL) | (";" NL NL) ;
--------------------java::java-1-jouault.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------java::java-3-bruneliere.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------java::java-5-cordy-guo-dean.bgf--------------------
wildcard_type ::= ("?" wildcard_type_bound?) | (id wildcard_type_bound?) ;
add_op ::= "+" | "-" ;
wildcard_type_bound ::= ("extends" type_specifier) | ("super" type_specifier) ;
shift_op ::= "<<" | (SPOFF ">" ">" SPON) | (SPOFF ">" ">" ">" SPON) ;
component ::= dot_id | method_argument | subscript | (generic_argument) | (class_instance_creation_expression) | (dimension) ;
argument ::= expression | type_specifier ;
annotation_value_list ::= (single_annotation_value) | ({keyed_annotation_value ","}*) ;
relational_op_shift_expression ::= (relational_op shift_expression) | ("instanceof" type_specifier) ;
declaration ::= local_variable_declaration | class_declaration ;
relational_op ::= "<" | ">" | "<=" | ">=" ;
type_specifier ::= type_name | array_type_specifier ;
declaration_or_statement ::= declaration | statement ;
single_annotation_value ::= (expression) | nested_annotation | ("{" {expression_or_nested_annotation ","}* "}") ;
class_instance_declaration ::= class_instance_creation_expression | "class" ;
method_or_constructor_declaration ::= method_declaration | constructor_declaration ;
type_declaration ::= (class_declaration NL NL) | (interface_declaration NL NL) | (enum_declaration NL) ;
unary_op ::= "+" | "-" | "~" | "!" ;
annotation_default ::= ("default" expression) | ("default" array_initializer) ;
type_name ::= primitive_type | qualified_name ;
literal ::= numeric_literal | character_literal | string_literal | boolean_literal | null_literal ;
statement ::= label_statement | empty_statement | expression_statement | if_statement | switch_statement | while_statement | do_statement | for_statement | (for_in_statement) | break_statement | continue_statement | return_statement | throw_statement | synchronized_statement | try_statement | (assert_statement) | block ;
switch_label ::= ("case" constant_expression ":") | ("default" ":") ;
unary_expression ::= (pre_inc_dec unary_expression) | (unary_op unary_expression) | postfix_expression | cast_expression ;
type_argument ::= type_specifier | wildcard_type ;
expression_or_nested_annotation ::= expression | nested_annotation ;
import_declaration ::= ("import" "static"? imported_name ";" NL NL) | (";" NL) ;
variable_initializer ::= expression | array_initializer ;
boolean_literal ::= "true" | "false" ;
modifier ::= "abstract" | "final" | "public" | "protected" | "private" | "static" | "transient" | "volatile" | "native" | "synchronized" | ("strictfp") | (annotation) ;
assignment_operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | (SPOFF ">" ">=" SPON) | (SPOFF ">" ">" ">=" SPON) | "&=" | "^=" | "|=" ;
member_declaration ::= method_or_constructor_declaration | (type_declaration) ;
primitive_type ::= "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double" | "void" ;
dot_id ::= ("." generic_argument? id) | ("." "class") | ("." class_instance_declaration) ;
mult_op ::= "*" | "/" | "%" ;
reference ::= (id component*) | (primitive_type component*) ;
assignment_expression ::= conditional_expression | (unary_expression assignment_operator assignment_expression) ;
equality_op ::= "==" | "!=" ;
for_init ::= ({expression ","}* ";") | local_variable_declaration ;
pre_inc_dec ::= "++" | "--" ;
class_body_declaration ::= empty_declaration | member_declaration | instance_initializer | static_initializer | field_declaration ;
class_or_interface_component ::= (dot_id) | generic_argument ;
post_inc_dec ::= "++" | "--" ;
primary ::= (literal component*) | reference | ("(" expression ")" component*) | (class_instance_creation_expression component*) | (array_creation_expression component*) ;
method_body ::= (block NL NL) | (annotation_default? ";" NL NL) ;
--------------------java::java-5-giquel.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------java::jvm-level1.bgf--------------------
ClassModifier ::= (access::(access::AccessModifier)) | (final::ε) | (super::ε) | (interface::ε) | (abstract::ε) | (synthetic::ε) | (annotation::ε) | (enum::ε) | (deprecated::ε) ;
Instruction ::= (getStatic::(owner::string() name::string() description::string())) | (putStatic::(owner::string() name::string() description::string())) | (getField::(owner::string() name::string() description::string())) | (putField::(owner::string() name::string() description::string())) | (increment::(index::integer() amount::integer())) | (nop::ε) | (aConstNull::ε) | (iConstM1::ε) | (iConst0::ε) | (iConst1::ε) | (iConst2::ε) | (iConst3::ε) | (iConst4::ε) | (iConst5::ε) | (lConst0::ε) | (lConst1::ε) | (fConst0::ε) | (fConst1::ε) | (fConst2::ε) | (dConst0::ε) | (dConst1::ε) | (iaLoad::ε) | (laLoad::ε) | (faLoad::ε) | (daLoad::ε) | (aaLoad::ε) | (baLoad::ε) | (caLoad::ε) | (saLoad::ε) | (iaStore::ε) | (laStore::ε) | (faStore::ε) | (daStore::ε) | (aaStore::ε) | (baStore::ε) | (caStore::ε) | (saStore::ε) | (pop::ε) | (pop2::ε) | (dup::ε) | (dupX1::ε) | (dupX2::ε) | (dup2::ε) | (dup2X1::ε) | (dup2X2::ε) | (swap::ε) | (iAdd::ε) | (lAdd::ε) | (fAdd::ε) | (dAdd::ε) | (iSub::ε) | (lSub::ε) | (fSub::ε) | (dSub::ε) | (iMul::ε) | (lMul::ε) | (fMul::ε) | (dMul::ε) | (iDiv::ε) | (lDiv::ε) | (fDiv::ε) | (dDiv::ε) | (iRem::ε) | (lRem::ε) | (fRem::ε) | (dRem::ε) | (iNeg::ε) | (lNeg::ε) | (fNeg::ε) | (dNeg::ε) | (iShl::ε) | (lShl::ε) | (iShr::ε) | (lShr::ε) | (iuShr::ε) | (luShr::ε) | (iAnd::ε) | (lAnd::ε) | (iOr::ε) | (lOr::ε) | (iXor::ε) | (lXor::ε) | (i2l::ε) | (i2f::ε) | (i2d::ε) | (l2i::ε) | (l2f::ε) | (l2d::ε) | (f2i::ε) | (f2l::ε) | (f2d::ε) | (d2i::ε) | (d2l::ε) | (d2f::ε) | (i2b::ε) | (i2c::ε) | (i2s::ε) | (lCmp::ε) | (fCmpL::ε) | (fCmpG::ε) | (dCmpL::ε) | (dCmpH::ε) | (iReturn::ε) | (lReturn::ε) | (fReturn::ε) | (dReturn::ε) | (aReturn::ε) | (return::ε) | (arrayLength::ε) | (aThrow::ε) | (monitorEnter::ε) | (monitorExit::ε) | (biPush::(operand::integer())) | (siPush::(operand::integer())) | (newArray::(operand::integer())) | (ifEq::(label::integer())) | (ifNe::(label::integer())) | (ifLt::(label::integer())) | (ifGe::(label::integer())) | (ifGt::(label::integer())) | (ifLe::(label::integer())) | (ifICmpEq::(label::integer())) | (ifICmpNe::(label::integer())) | (ifICmpLt::(label::integer())) | (ifICmpGe::(label::integer())) | (ifICmpGt::(label::integer())) | (ifICmpLe::(label::integer())) | (ifACmpEq::(label::integer())) | (ifACmpNe::(label::integer())) | (goto::(label::integer())) | (jsr::(label::integer())) | (ifNull::(label::integer())) | (ifNonNull::(label::integer())) | (label::(index::integer())) | (lineNumber::(line::integer() labelIndex::integer())) | (localVariable::(opcode::integer() index::integer())) | (iLoad::(index::integer())) | (lLoad::(index::integer())) | (fLoad::(index::integer())) | (dLoad::(index::integer())) | (aLoad::(index::integer())) | (iStore::(index::integer())) | (lStore::(index::integer())) | (fStore::(index::integer())) | (dStore::(index::integer())) | (aStore::(index::integer())) | (ret::(index::integer())) | (ldcString::(string::string())) | (ldcInt::(int::integer())) | (ldcLong::(long::integer())) | (ldcFloat::(float::integer())) | (ldcDouble::(double::integer())) | (lookupSwitch::(defaultLabel::integer() keys::(integer()*) cases::(integer()*))) | (invokeVirtual::(owner::string() name::string() description::string())) | (invokeSpecial::(owner::string() name::string() description::string())) | (invokeStatic::(owner::string() name::string() description::string())) | (invokeInterface::(owner::string() name::string() description::string())) | (invokeDynamic::(owner::string() name::string() description::string())) | (multiANewArray::(description::string() dimensions::integer())) | (tableSwitch::(min::integer() max::integer() defaultLabel::integer() cases::(integer()*))) | (new::(internalName::string())) | (aNewArray::(internalName::string())) | (checkCast::(internalName::string())) | (instanceOf::(internalName::string())) ;
TypeSignature ::= (primitive::(type::PrimitiveTypeDescriptor)) | (fieldType::(sig::FieldTypeSignature)) ;
TryCatchBlock ::= (tryCatchBlock::(startLabelIndex::integer() endLabelIndex::integer() handlerLabelIndex::integer() type::string())) | (finallyBlock::(startLabelIndex::integer() endLabelIndex::integer() handlerLabelIndex::integer())) ;
TypeArg ::= (type::(fieldType::FieldTypeSignature)) | (wildcard::ε) | (extends::(fieldType::FieldTypeSignature)) | (super::(fieldType::FieldTypeSignature)) ;
AccessModifier ::= (public::ε) | (private::ε) | (protected::ε) ;
Field ::= (field::(modifiers::(FieldModifier*) name::string() description::string() signature::string() value::α)) | (field::(modifiers::(FieldModifier*) name::string() description::string() signature::string())) ;
TypeDescriptor ::= (primitive::(type::PrimitiveTypeDescriptor)) | (object::(internalName::string())) | (array::(type::TypeDescriptor)) ;
MethodModifier ::= (access::(access::AccessModifier)) | (static::ε) | (final::ε) | (synchronized::ε) | (bridge::ε) | (varags::ε) | (native::ε) | (abstract::ε) | (strict::ε) | (synthetic::ε) ;
Class ::= (class::(version::integer() modifiers::(ClassModifier*) name::string() signature::string() superName::string() interfaces::(string()*) sourceFile::string() sourceDebug::string() outerClass::string() outerMethod::string() outerMethodDescription::string() innerClasses::(InnerClass*) fields::(Field*) methods::(Method*))) | (class::(version::integer() modifiers::(ClassModifier*) name::string() signature::string() superName::string() interfaces::(string()*) innerClasses::(InnerClass*) fields::(Field*) methods::(Method*))) ;
ClassTypeSignature ::= (topLevel::(internalName::string() args::(TypeArg*))) | (inner::(class::ClassTypeSignature name::string() args::(TypeArg*))) ;
FieldTypeSignature ::= (classType::(class::ClassTypeSignature)) | (array::(type::TypeSignature)) | (typeVar::(name::string())) ;
InnerClass ::= (innerClass::(name::string() outerName::string() innerName::string() modifiers::(ClassModifier*))) | (innerClass::(name::string() modifiers::(ClassModifier*))) ;
FieldModifier ::= (access::(access::AccessModifier)) | (static::ε) | (final::ε) | (volatile::ε) | (transient::ε) | (synthetic::ε) | (enum::ε) ;
PrimitiveTypeDescriptor ::= (boolean::ε) | (char::ε) | (byte::ε) | (short::ε) | (int::ε) | (float::ε) | (long::ε) | (double::ε) ;
--------------------modula::sdf.bgf--------------------
Selector ::= "^" | ("." Id) | ("[" Expr ("," Expr)* "]") | ("(" (Actual ("," Actual)*)? ")") ;
Id ::= "NOT" | "ROOT" ;
Type ::= TypeLiteral | QualId ;
Relop ::= "=" | "#" | "<" | "<=" | ">" | ">=" | "IN" ;
Field ::= (IdList ":" Type ":=" Expr) | (IdList ":" Type) | (IdList ":=" Expr) ;
Interface ::= ("INTERFACE" Id ";" Import* Decl* "END" Id ".") | ("INTERFACE" Id "=" Id GenActls "END" Id ".") ;
ImportItem ::= Id | (Id "AS" Id) ;
TypeLiteral ::= ArrayType | PackedType | EnumType | ObjectType | ProcedureType | RecordType | RefType | SetType | SubrangeType | ("(" Type ")") | TypeName ;
Expr ::= (Expr "OR" Expr) | (Expr "AND" Expr) | ("NOT" Expr) | (Expr Relop Expr) | (Expr Addop Expr) | (Expr Mulop Expr) | ("+" Expr) | ("-" Expr) | (Expr Selector) | Id | Literal | Constructor | ("(" Expr ")") ;
Ancestor ::= TypeName | ObjectType | QualId ;
Formal ::= (Mode? IdList ":" Type ":=" Expr) | (Mode? IdList ":" Type) | (Mode? IdList ":=" Expr) ;
Actual ::= TypeLiteral | ((Id ":=")? Expr) ;
Elt ::= (Expr ".." Expr) | Expr | (Id ":=" Expr) ;
Module ::= ("MODULE" Id ("EXPORTS" IdList)? ";" Import* Block Id ".") | ("MODULE" Id ("EXPORTS" IdList)? "=" Id GenActls "END" Id ".") ;
Decl ::= ("CONST" (ConstDecl ";")*) | ("TYPE" (TypeDecl ";")*) | ("EXCEPTION" (ExceptionDecl ";")*) | ("VAR" (VariableDecl ";")*) | (ProcedureHead ("=" Block Id)? ";") | ("REVEAL" (QualId "=" | "<:" Type ";")*) ;
Stmt ::= AssignStmt | Block | CallStmt | CaseStmt | ExitStmt | EvalStmt | ForStmt | IfStmt | LockStmt | LoopStmt | RaiseStmt | RepeatStmt | ReturnStmt | TryFinStmt | TryXptStmt | TCaseStmt | WhileStmt | WithStmt ;
Raises ::= ("{" (QualId ("," QualId)*)? "}") | "ANY" ;
VariableDecl ::= (IdList ":" Type ":=" Expr) | (IdList ":" Type) | (IdList ":=" Expr) ;
Mulop ::= "*" | "/" | "DIV" | "MOD" ;
TypeName ::= "ROOT" | ("UNTRACED" "ROOT") ;
Import ::= AsImport | FromImport ;
Mode ::= "VALUE" | "VAR" | "READONLY" ;
Addop ::= "+" | "-" | "&" ;
--------------------modula::src-052.bgf--------------------
Selector ::= "^" | ("." Ident) | ("[" Expr ("," Expr)* "]") | ("(" (Actual ("," Actual)*)? ")") ;
Relop ::= "=" | "#" | "<" | "<=" | ">" | ">=" | "IN" ;
Type ::= TypeName | ArrayType | PackedType | EnumType | ObjectType | ProcedureType | RecordType | RefType | SetType | SubrangeType | ("(" Type ")") ;
Declaration ::= ("CONST" (ConstDecl ";")*) | ("TYPE" (TypeDecl ";")*) | ("EXCEPTION" (ExceptionDecl ";")*) | ("VAR" (VariableDecl ";")*) | (ProcedureHead ("=" Block Ident)? ";") | ("REVEAL" (TypeID "=" | "<:" Type ";")*) ;
E8 ::= Ident | Number | CharLiteral | TextLiteral | Constructor | ("(" Expr ")") ;
Ancestor ::= TypeName | ObjectType | "UNTRACED" ;
HexDigit ::= Digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
ExtendedChar ::= " " | "¡" | "¢" | "£" | "¤" | "¥" | "¦" | "§" | "¨" | "©" | "ª" | "«" | "¬" | "­" | "®" | "¯" | "°" | "±" | "²" | "³" | "´" | "µ" | "¶" | "·" | "¸" | "¹" | "º" | "»" | "¼" | "½" | "¾" | "¿" | "À" | "Á" | "Â" | "Ã" | "Ä" | "Å" | "Æ" | "Ç" | "È" | "É" | "Ê" | "Ë" | "Ì" | "Í" | "Î" | "Ï" | "Ð" | "Ñ" | "Ò" | "Ó" | "Ô" | "Õ" | "Ö" | "×" | "Ø" | "Ù" | "Ú" | "Û" | "Ü" | "Ý" | "Þ" | "ß" | "à" | "á" | "â" | "ã" | "ä" | "å" | "æ" | "ç" | "è" | "é" | "ê" | "ë" | "ì" | "í" | "î" | "ï" | "ð" | "ñ" | "ò" | "ó" | "ô" | "õ" | "ö" | "÷" | "ø" | "ù" | "ú" | "û" | "ü" | "ý" | "þ" | "ÿ" ;
Literal ::= Number | CharLiteral | TextLiteral ;
Actual ::= ((Ident ":=")? Expr) | Type ;
Digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
PrintingChar ::= Letter | Digit | UtherChar ;
Number ::= (Digit+) | (Digit+ "_" HexDigit+) | (Digit+ "." Digit+ Exponent?) ;
Stmt ::= AssignStmt | Block | CallStmt | CaseStmt | ExitStmt | EvalStmt | ForStmt | IfStmt | LockStmt | LoopStmt | RaiseStmt | RepeatStmt | ReturnStmt | TryFinStmt | TryXptStmt | TCaseStmt | WhileStmt | WithStmt ;
OtherChar ::= " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "]" | "^" | "_" | "‘" | "{" | "|" | "}" | "~" | ExtendedChar ;
Letter ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
TypeName ::= (Ident ("." Ident)?) | "ROOT" | ("UNTRACED" "ROOT") ;
Mulop ::= "*" | "/" | "DIV" | "MOD" ;
Operator ::= "+" | "-" | "*" | "/" | "." | "^" | (":" "=") | "=" | "$" | "<" | ("<" "=") | (">" "=") | ">" | "&" | ("<" ":") | ("=" ">") | "," | ";" | "|" | ":" | ("." ".") | "(" | ")" | "{" | "}" | "[" | "]" ;
OctalDigit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" ;
Addop ::= "+" | "-" | "&" ;
Escape ::= ("\" "n") | ("\" "t") | ("\" "r") | ("\" "f") | ("\" "\") | ("\" "’") | ("\" """) | ("\" OctalDigit OctalDigit OctalDigit) ;
--------------------modula::dagenais-cordy.bgf--------------------
Selector ::= ("." id) | ("[" Expr ComaExpr* "]") | ("(" {Actual ","}* ")") | "^" ;
SignOp ::= "+" | "-" ;
AnyCons ::= SetCons | RecordCons | ArrayCons ;
Type ::= TypeName | ArrayType | EnumerationType | RecordType | ObjectType | ProcedureType | RefType | SetType | SubrangeType | PackedType | ("(" Type ")") ;
RelOp ::= "=" | "#" | "<" | "<=" | ">" | ">=" | "IN" ;
RevealDecl ::= (QualId "=" Type ";" NL) | (QualId "<:" Type ";" NL) ;
E8 ::= id | Number | charlit | stringlit | ("(" Expr ")") | Constructor ;
Actual ::= Type | Expr | (id ":=" Expr) ;
Decl ::= (ProcedureHead EqualBlock? ";" NL NL) | ("VAR" IN NL VariableDecl* EX) | ("TYPE" IN NL TypeDecl* EX NL) | ("CONST" IN NL ConstDecl* EX NL) | ("EXCEPTION" IN NL ExceptionDecl* EX NL) | ("REVEAL" IN NL RevealDecl* EX NL) ;
Stmt ::= IfStmt | ForStmt | ReturnStmt | WhileStmt | AssignStmt | CallStmt | Block | CaseStmt | ExitStmt | EvalStmt | LockStmt | LoopStmt | RaiseStmt | RepeatStmt | TypecaseStmt | TryStmt | WithStmt ;
ExceptOrFinally ::= ("EXCEPT" NL Handler? VerticalHandler* ElseStmts?) | ("FINALLY" Stmts) ;
ObjectOrTypeName ::= TypeName | ObjectType ;
TypeName ::= QualId | "ROOT" | ("UNTRACED" "ROOT") ;
MulOp ::= "*" | "/" | "DIV" | "MOD" ;
RaisesList ::= ("{" {QualId ","}* "}") | "ANY" ;
Import ::= AsImport | (FromImport NL NL) ;
TypeDecl ::= (id "=" Type ";" NL) | (id "<:" Type ";" NL) ;
program ::= Interface | Module | GInterface | GModule | IInterface | IModule ;
Mode ::= "VALUE" | "VAR" | "READONLY" ;
AddOp ::= "+" | "-" | "&" ;
--------------------xpath::w3c-xpath1.bgf--------------------
NameTest ::= [NT-NameTest] "*" | (NCName ":" "*") | QName ;
AxisSpecifier ::= [NT-AxisSpecifier] (AxisName "::") | AbbreviatedAxisSpecifier ;
NodeType ::= [NT-NodeType] "comment" | "text" | "processing-instruction" | "node" ;
RelationalExpr ::= [NT-RelationalExpr] AdditiveExpr | (RelationalExpr "<" AdditiveExpr) | (RelationalExpr ">" AdditiveExpr) | (RelationalExpr "<=" AdditiveExpr) | (RelationalExpr ">=" AdditiveExpr) ;
PathExpr ::= [NT-PathExpr] LocationPath | FilterExpr | (FilterExpr "/" RelativeLocationPath) | (FilterExpr "//" RelativeLocationPath) ;
LocationPath ::= [NT-LocationPath] RelativeLocationPath | AbsoluteLocationPath ;
OrExpr ::= [NT-OrExpr] AndExpr | (OrExpr "or" AndExpr) ;
PrimaryExpr ::= [NT-PrimaryExpr] VariableReference | ("(" Expr ")") | Literal | Number | FunctionCall ;
NodeTest ::= [NT-NodeTest] NameTest | (NodeType "(" ")") | ("processing-instruction" "(" Literal ")") ;
AbsoluteLocationPath ::= [NT-AbsoluteLocationPath] ("/" RelativeLocationPath?) | AbbreviatedAbsoluteLocationPath ;
OperatorName ::= [NT-OperatorName] "and" | "or" | "mod" | "div" ;
EqualityExpr ::= [NT-EqualityExpr] RelationalExpr | (EqualityExpr "=" RelationalExpr) | (EqualityExpr "!=" RelationalExpr) ;
FilterExpr ::= [NT-FilterExpr] PrimaryExpr | (FilterExpr Predicate) ;
AndExpr ::= [NT-AndExpr] EqualityExpr | (AndExpr "and" EqualityExpr) ;
AxisName ::= [NT-AxisName] "ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-sibling" | "namespace" | "parent" | "preceding" | "preceding-sibling" | "self" ;
Step ::= [NT-Step] (AxisSpecifier NodeTest Predicate*) | AbbreviatedStep ;
MultiplicativeExpr ::= [NT-MultiplicativeExpr] UnaryExpr | (MultiplicativeExpr MultiplyOperator UnaryExpr) | (MultiplicativeExpr "div" UnaryExpr) | (MultiplicativeExpr "mod" UnaryExpr) ;
Number ::= [NT-Number] (Digits ("." Digits?)?) | ("." Digits) ;
RelativeLocationPath ::= [NT-RelativeLocationPath] Step | (RelativeLocationPath "/" Step) | AbbreviatedRelativeLocationPath ;
AbbreviatedStep ::= [NT-AbbreviatedStep] "." | ".." ;
Operator ::= [NT-Operator] OperatorName | MultiplyOperator | "/" | "//" | "|" | "+" | "-" | "=" | "!=" | "<" | "<=" | ">" | ">=" ;
ExprToken ::= [NT-ExprToken] "(" | ")" | "[" | "]" | "." | ".." | "@" | "," | "::" | NameTest | NodeType | Operator | FunctionName | AxisName | Literal | Number | VariableReference ;
UnaryExpr ::= [NT-UnaryExpr] UnionExpr | ("-" UnaryExpr) ;
UnionExpr ::= [NT-UnionExpr] PathExpr | (UnionExpr "|" PathExpr) ;
AdditiveExpr ::= [NT-AdditiveExpr] MultiplicativeExpr | (AdditiveExpr "+" MultiplicativeExpr) | (AdditiveExpr "-" MultiplicativeExpr) ;
--------------------assembly::delphi.bgf--------------------
asm_primary ::= ("[" asm_expr "]") | ("(" asm_expr ")") | asm_register | id | anynumber | charlit | stringlit | asmhex | (SP asmlabel) ;
asm_infixop ::= "." | "+" | "-" | "*" | "/" | "ptr" | "mod" | "xor" | "and" | "or" | "shr" | "shl" ;
asm_directive ::= "DB" | "DW" | "DD" | "DQ" ;
asmlabel ::= (SPOFF asmid+ SPON) | label_id ;
asm_prefixop ::= "high" | "low" | "offset" | "dmtindex" | "vmtoffset" | "type" | "not" | "&" | sign | "@" ;
asm_register ::= ("ST" "(" integernumber ")") | ("ST") | "FS" | ("GS") | "EAX" | "EBX" | "ECX" | ("EDX") | "ESP" | "EBP" | "ESI" | ("EDI") | "AX" | "BX" | "CX" | ("DX") | "SP" | "BP" | "SI" | ("DI") | "AL" | "BL" | "CL" | ("DL") | "CS" | "DS" | "SS" | ("ES") | "AH" | "BH" | "CH" | ("DH") | ("CS" segmt_overr?) | ("DS" segmt_overr?) | ("SS" segmt_overr?) | ("FS" segmt_overr?) | ("GS" segmt_overr?) | ("ES" segmt_overr?) ;
asm_unlabeledstm ::= (asm_directive {asm_directive_arg ","}*) | (asm_opcode_prefix? asm_opcode {asm_expr ","}*) ;
asmid ::= ("@"* asmlbl) | ("@+"* id) | ("@+"* anynumber) | ("@+"* key) ;
asm_postfixop ::= ("[" asm_expr "]") | ("." asm_expr) ;
asm_directive_arg ::= charlit | (sign? anynumber) | asm_expr ;
asm_opcode ::= "adc" | "add" | "and" | "bswap" | "bt" | "btr" | "bts" | "call" | "cdq" | "cld" | "cmp" | "dec" | "div" | "f2xm1" | "fabs" | "fadd" | "faddp" | "fbstp" | "fchs" | "fclex" | "fcom" | "fcomp" | "fcos" | "fdiv" | "fdivp" | "fdivrp" | "ffree" | "fiadd" | "fidiv" | "fild" | "fimul" | "fistp" | "fld" | "fld1" | "fldcw" | "fldl2e" | "fldlg2" | "fldln2" | "fldz" | "fmul" | "fmulp" | "fnclex" | "fninit" | "fnstcw" | "fnstsw" | "fpatan" | "fprem" | "fptan" | "frndint" | "fscale" | "fsin" | "fsincos" | "fsqrt" | "fstcw" | "fstp" | "fstsw" | "fsub" | "fsubp" | "fsubr" | "fwait" | "fxch" | "fxtract" | "fyl2x" | "fyl2xp1" | "imul" | "inc" | "int" | "ja" | "jae" | "jb" | "jbe" | "jc" | "je" | "jecxz" | "jg" | "jge" | "jl" | "jle" | "jmp" | "jnc" | "jne" | "jnl" | "jns" | "jnz" | "jo" | "jp" | "js" | "jz" | "lea" | "leave" | "lodsb" | "lodsw" | "loop" | "mov" | "movsb" | "movsx" | "movzx" | "mul" | "neg" | "not" | "or" | "pop" | "popfd" | "push" | "pushfd" | "rcl" | "rcr" | "rep" | "repe" | "repne" | "ret" | "rol" | "ror" | "sahf" | "sar" | "sbb" | "seto" | "shl" | "shld" | "shr" | "shrd" | "std" | "stosb" | "stosd" | "stosw" | "sub" | "test" | "wait" | "xadd" | "xchg" | "xor" ;
--------------------basic::vb6-cordy.bgf--------------------
while_or_until_clause ::= while_clause | until_clause ;
charpos ::= expn | ";" ;
compare_mode ::= "binary" | "text" | "database" ;
spc_tab ::= ("spc" "(" expn? ")") | ("tab" "(" expn? ")") ;
declaration ::= variable_declaration | implements_declaration | subprogram_declaration | constant_declaration | class_declaration | declare_subprogram_declaration | defletter_declaration | enum_declaration | type_declaration ;
variable_description ::= array_description | single_var_description ;
declaration_or_statement ::= (declaration eol) | (statement eol) | eol ;
to_or_downto ::= "to" | "downto" ;
sub_or_function ::= "sub" | "function" ;
optional_expn ::= expn | (ε SP) ;
def_keyword ::= "defbool" | "defbyte" | "defcur" | "defdate" | "defdbl" | "defdec" | "defint" | "deflng" | "defobj" | "defsng" | "defstr" | "defvar" ;
statement ::= label_statement | assignment_statement | app_activate_statement | attribute_statement | beep_statement | call_statement | chdir_statement | chdrive_statement | close_statement | date_statement | deletesetting_statement | do_statement | end_statement | erase_statement | error_statement | event_statement | exit_statement | filecopy_statement | for_each_statement | for_next_statement | get_statement | gosub_statement | return_statement | goto_statement | if_statement | input_statement | kill_statement | line_input_statement | load_statement | lock_statement | lset_statement | mid_statement | mkdir_statement | name_statement | on_error_statement | open_statement | option_statement | preprocessor_if_statement | print_statement | property_statement | put_statement | randomize_statement | reset_statement | resume_statement | rmdir_statement | rset_statement | savepicture_statement | savesetting_statement | select_case_statement | set_statement | stop_statement | time_statement | unload_statement | unlock_statement | while_statement | with_statement | width_statement | write_statement ;
prefix_op ::= "+" | "-" | "not" | "typeof" | "addressof" ;
on_error_action ::= ("resume" "next") | ("goto" expn) ;
optional_subscript ::= (expn to_expn?) | (SP ε) ;
lock ::= "shared" | ("lock" "read") | ("lock" "write") | ("lock" "read" "write") ;
for_each_statement ::= full_for_each_statement | short_for_each_statement ;
option_statement ::= ("option" "base" number) | ("option" "compare" compare_mode) | ("option" "explicit") | ("option" "private" "module") ;
print_item ::= (spc_tab? expn charpos?) | spc_tab ;
mode ::= "append" | "binary" | "input" | "output" | "random" ;
filepath ::= (drive? id slash_id*) | stringlit ;
op ::= "^" | "*" | "/" | "\" | "mod" | "+" | "-" | "&" | "=" | "<>" | "<=" | ">=" | ":=" | ">" | "<" | "!" | "is" | "not" | "and" | "or" | "xor" | "eqv" | "imp" | "like" ;
component_selector ::= ("." id) | ("." key) | subscript ;
variable_declaration_keyword ::= "dim" | "redim" | access_modifier ;
access_mode ::= "read" | "write" | ("read" "write") ;
resume_statement ::= ("resume" "next") | ("resume" number?) ;
slash_id ::= ("\" id) | ("/" id) ;
enum_member_definition ::= (id "=" expn eol) | eol ;
for_next_statement ::= full_for_next_statement | short_for_next_statement ;
get_let_set ::= "get" | "let" | "set" ;
exit_what_indicator ::= "do" | "for" | "function" | "property" | "sub" ;
set_object_expn ::= ("new"? expn) | "nothing" ;
type_member_definition ::= (id parens? as_type? eol) | eol ;
access_modifier ::= "public" | "private" | "friend" | "static" ;
byref_or_byval ::= "byref" | "byval" ;
class_begin_item ::= assignment_statement | class_begin_block | eol ;
single_declaration_or_statement ::= (declaration colon_declaration_or_statement*) | (statement colon_declaration_or_statement*) ;
if_statement ::= full_if_statement | short_if_statement ;
reference ::= ("."? "!"? id component_selector*) | ("." key component_selector*) ;
eol ::= (tab_vbcomment? newline) | ":" ;
primary ::= reference | stringlit | number | hexnumber | octnumber | datelit | returncode | filenumber | (prefix_op primary) | ("(" {expn ","}* ")") ;
--------------------basic::vb-glineur.bgf--------------------
obeo/psm/vb/projects/VB_1/enumerations/VisibilityEnum ::= (private::ε) | (protected::ε) | (public::ε) ;
obeo/psm/vb/projects/VB_1/enumerations/EnablementEnum ::= (Off::ε) | (On::ε) ;
Boolean ::= "true" | "false" ;
obeo/psm/vb/projects/VB_1/enumerations/NameEnum ::= (trueLit::ε) | (falseLit::ε) | (nothing::ε) ;
obeo/psm/vb/projects/VB_1/enumerations/Qualifier_2Enum ::= (static::ε) | (const::ε) | (dim::ε) ;
obeo/psm/vb/projects/VB_1/enumerations/QualifierEnum ::= (byRef::ε) | (byVal::ε) ;
--------------------bibtex::bibtex-1.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------bibtex::bql.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------dot::doux.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------dot::palies.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------dot::rascal-abstract.bgf--------------------
Stm ::= (N::(id::Id attrs::Attrs)) | (N::(id::Id)) | (N::(nid::NodeId attrs::Attrs)) | (N::(nid::NodeId)) | (E::(from::Id to::Id attrs::Attrs)) | (E::(from::Id to::Id)) | (E::(nfrom::NodeId to::Id attrs::Attrs)) | (E::(nfrom::NodeId to::Id)) | (E::(sfrom::Stm to::Id attrs::Attrs)) | (E::(sfrom::Stm to::Id)) | (E::(from::Id nto::NodeId attrs::Attrs)) | (E::(from::Id nto::NodeId)) | (E::(nfrom::NodeId nto::NodeId attrs::Attrs)) | (E::(nfrom::NodeId nto::NodeId)) | (E::(sfrom::Stm nto::NodeId attrs::Attrs)) | (E::(sfrom::Stm nto::NodeId)) | (E::(from::Id sto::Stm attrs::Attrs)) | (E::(from::Id sto::Stm)) | (E::(nfrom::NodeId sto::Stm attrs::Attrs)) | (E::(nfrom::NodeId sto::Stm)) | (E::(sfrom::Stm sto::Stm attrs::Attrs)) | (E::(sfrom::Stm sto::Stm)) | (S::(id::Id stms::Stms)) | (S::(stms::Stms)) | (A::(prop::Id val::Id)) | (GRAPH::(attrs::Attrs)) | (NODE::(attrs::Attrs)) | (EDGE::(attrs::Attrs)) ;
CompassPt ::= (N::ε) | (NE::ε) | (E::ε) | (SE::ε) | (S::ε) | (SW::ε) | (W::ε) | (NW::ε) | (C::ε) | (_::ε) ;
DotGraph ::= (graph::(id::Id stmts::Stms)) | (digraph::(id::Id stmts::Stms)) ;
--------------------html::allilaire.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------html::clark-basic.bgf--------------------
InputType.class ::= "text" | "password" | "checkbox" | "radio" | "submit" | "reset" | "hidden" ;
Heading.class ::= h1 | h2 | h3 | h4 | h5 | h6 ;
Formctrl.class ::= input | label | select | textarea ;
List.class ::= ul | ol | dl ;
--------------------html::clark.bgf--------------------
Heading.class ::= h1 | h2 | h3 | h4 | h5 | h6 ;
dir.attrib ::= dir::("ltr" | "rtl") ;
Script.class ::= noscript | script ;
Edit.class ::= del | ins ;
--------------------html::cordy.bgf--------------------
singleton_id ::= "br" | "hr" | ("|" "img") | "meta" | "base" | "basefont" | x_id | "dt" ;
attribute_value ::= stringlit | number | id | url | fileref ;
attribute_id ::= id | x_id ;
comment_text ::= (punctuation SP) | token ;
element ::= singleton_tag | tag | text | comment_tag | tag_beg | tag_end ;
text_unit ::= (punctuation SP) | (")" SP) | (SP "(") | token | ("<" number) ;
singleton_tag ::= ("<" singleton_id attributes ">" singleton_tag_end? NL) | ("<" id attributes "/>" NL) ;
--------------------html::guyard.bgf--------------------
CellHAlign ::= (left::ε) | (center::ε) | (right::ε) | (justify::ε) | (char::ε) ;
Direction ::= (ltr::ε) | (rtl::ε) ;
ButtonType ::= (button::ε) | (submit::ε) | (reset::ε) ;
ValueType ::= (data::ε) | (ref::ε) | (object::ε) ;
TFrame ::= (void::ε) | (above::ε) | (below::ε) | (hsides::ε) | (lhs::ε) | (rhs::ε) | (vsides::ε) | (box::ε) | (border::ε) ;
Boolean ::= "true" | "false" ;
Scope ::= (row::ε) | (col::ε) | (rowgroup::ε) | (colgroup::ε) ;
InputType ::= (text::ε) | (password::ε) | (checkbox::ε) | (radio::ε) | (submit::ε) | (reset::ε) | (file::ε) | (hidden::ε) | (image::ε) | (button::ε) ;
TRules ::= (none::ε) | (groups::ε) | (rows::ε) | (cols::ε) | (all::ε) ;
FomeMethod ::= (get::ε) | (post::ε) ;
CellVAlign ::= (top::ε) | (middle::ε) | (bottom::ε) | (baseline::ε) ;
Shape ::= (rect::ε) | (circle::ε) | (poly::ε) | (default::ε) ;
--------------------html::clark-strict.bgf--------------------
Heading.class ::= h1 | h2 | h3 | h4 | h5 | h6 ;
dir.attrib ::= dir::("ltr" | "rtl") ;
List.class ::= ul | ol | dl ;
Script.class ::= noscript | script ;
Edit.class ::= del | ins ;
--------------------javascript::synytskyy-cordy.bgf--------------------
js_property_name ::= id | js_string_literal | number ;
js_additive_op ::= "+" | "-" ;
js_assignment_op ::= "=" | "*=" | ("/" SPOFF "=" SPON) | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" ;
js_case_clause_value ::= ("case" js_expn ":") | ("default" ":") ;
js_statement ::= (js_compound_statement ";"?) | (js_expression_statement ";"?) | (js_if_statement ";"?) | (js_for_statement ";"?) | (js_while_statement ";"?) | (js_break_statement ";"?) | (js_continue_statement ";"?) | (js_return_statement ";"?) | (js_with_statement ";"?) | (js_switch_statement ";"?) | (js_do_statement ";"?) | (js_try_catch_statement ";"?) | (js_throw_statement ";"?) | (js_debugger_statement ";"?) | js_empty_statement ;
js_literal ::= "null" | "true" | "false" | js_numeric_literal | js_string_literal | js_regular_expn_literal ;
js_string_literal ::= stringlit | charlit ;
js_selector ::= js_arguments | js_subscripts | js_field_selector ;
js_shift_op ::= "<<" | ">>" | ">>>" ;
js_multiplicative_op ::= "*" | "/" | "%" ;
js_equality_op ::= "==" | "!=" | "===" | "!==" | "in" | "instanceof" ;
js_declaration_or_statement ::= (js_declaration NL) | (js_label? js_statement NL) | (comment NL) ;
js_declaration_or_statement_no_nl ::= (js_declaration) | js_statement ;
js_numeric_literal ::= number | js_hex_number ;
js_unary_op ::= "delete" | "void" | "typeof" | "++" | "--" | "+" | "-" | "~" | "!" ;
js_primary_expn ::= "this" | "class" | id | js_literal | js_array_literal | js_object_literal | js_function_expn | ("(" js_expn ")") ;
js_declaration ::= (js_variable_declaration ";"?) | (js_constant_declaration ";"?) | (js_function_declaration ";"?) ;
js_for_statement ::= ("for" "(" {js_declaration_or_statement_no_nl ","}* ";" js_expn? ";" js_expn? ")" js_statement) | ("for" "each"? "(" js_declaration_or_statement_no_nl "in" js_expn ")" js_statement) ;
js_relational_op ::= "<" | ">" | "<=" | ">=" ;
js_property_assignment ::= (js_property_name ":" js_expn) | ("get" js_property_name "(" ")" "{" js_subscope "}") | ("set" js_property_name "(" js_property_set_parameter ")" "{" js_subscope "}") ;
js_postfix_op ::= "++" | "--" ;
--------------------occam::mu-mitchell.bgf--------------------
operator ::= "new" | "delete" | ("new" "[]") | ("delete" "[]") | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "()" | "[]" ;
assignment-operator ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
unary-operator ::= "*" | "&" | "+" | "-" | "!" | "~" ;
--------------------occam::mu-srour.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------occam::srour.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------odf::opendoc-1.0-strict.bgf--------------------
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
text-note-class ::= text:note-class::("footnote" | "endnote") ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
types ::= "submit" | "reset" | "push" | "url" ;
table-rows ::= table-table-rows | (table-table-row+) ;
lineMode ::= "continuous" | "skip-white-space" ;
fontVariant ::= "normal" | "small-caps" ;
anim-animate-transform-attlist ::= svg:type::("translate" | "scale" | "rotate" | "skewX" | "skewY") ;
presentation-animation-elements ::= presentation-show-shape | presentation-show-text | presentation-hide-shape | presentation-hide-text | presentation-dim | presentation-play ;
presentation-classes ::= "title" | "outline" | "subtitle" | "text" | "graphic" | "object" | "chart" | "table" | "orgchart" | "page" | "notes" | "handout" | "header" | "footer" | "date-time" | "page-number" ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
common-num-format-attlist ::= (style:num-format::("1" | "i" | "I" | string | ε)) | (style:num-format::("a" | "A") style-num-letter-sync-attlist) | ε ;
fontPitch ::= "fixed" | "variable" ;
any-date ::= number-day | number-month | number-year | number-era | number-day-of-week | number-week-of-year | number-quarter | number-hours | number-am-pm | number-minutes | number-seconds ;
table-data-pilot-subtotal-attlist ::= table:function::("auto" | "average" | "count" | "countnums" | "max" | "min" | "product" | "stdev" | "stdevp" | "sum" | "var" | "varp" | string) ;
table-cut-offs ::= table:cut-offs::((table-movement-cut-off+) | (table-insertion-cut-off table-movement-cut-off*)) ;
text-bibliography-types ::= "article" | "book" | "booklet" | "conference" | "custom1" | "custom2" | "custom3" | "custom4" | "custom5" | "email" | "inbook" | "incollection" | "inproceedings" | "journal" | "manual" | "mastersthesis" | "misc" | "phdthesis" | "proceedings" | "techreport" | "unpublished" | "www" ;
form-property-value-and-type-attlist ::= common-value-and-type-attlist | (office:value-type::"void") ;
text-table-of-content-children ::= text-index-entry-chapter | text-index-entry-page-number | text-index-entry-text | text-index-entry-span | text-index-entry-tab-stop | text-index-entry-link-start | text-index-entry-link-end ;
change-marks ::= (text:change::change-mark-attr) | (text:change-start::change-mark-attr) | (text:change-end::change-mark-attr) ;
boolean ::= "true" | "false" ;
table-rows-no-group ::= (table-rows (table-table-header-rows table-rows?)?) | (table-table-header-rows table-rows?) ;
index-content-main ::= text-content | text-index-title ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
draw-glue-points-attlist ::= draw:escape-direction::("auto" | "left" | "right" | "up" | "down" | "horizontal" | "vertical") ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
common-draw-style-name-attlist ::= ((draw:style-name::styleNameRef)? (draw:class-names::styleNameRefs)?) | ((presentation:style-name::styleNameRef)? (presentation:class-names::styleNameRefs)?) ;
common-value-and-type-attlist ::= (office:value-type::"float" office:value::double) | (office:value-type::"percentage" office:value::double) | (office:value-type::"currency" office:value::double (office:currency::string)?) | (office:value-type::"date" office:date-value::dateOrDateTime) | (office:value-type::"time" office:time-value::duration) | (office:value-type::"boolean" office:boolean-value::boolean) | (office:value-type::"string" (office:string-value::string)?) ;
table-columns ::= table-table-columns | (table-table-column+) ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
office-text-content-main ::= (text-content*) | (text-page-sequence (draw-a | shape)*) ;
text-content ::= text-h | text-p | text-list | text-numbered-paragraph | table-table | draw-a | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | shape | change-marks ;
styleNameRef ::= string() | ε ;
text-list-level-style-image-attr ::= common-draw-data-attlist | office-binary-data ;
table-movement-cut-off-attlist ::= (table:position::integer) | (table:start-position::integer table:end-position::integer) ;
table-visibility-value ::= "visible" | "collapse" | "filter" ;
gradient-style ::= "linear" | "axial" | "radial" | "ellipsoid" | "square" | "rectangular" ;
form-property-type-and-value-list ::= (office:value-type::"float" (form:list-value::(office:value::double))*) | (office:value-type::"percentage" (form:list-value::(office:value::double))*) | (office:value-type::"currency" (form:list-value::(office:value::double (office:currency::string)?))*) | (office:value-type::"date" (form:list-value::(office:date-value::dateOrDateTime))*) | (office:value-type::"time" (form:list-value::(office:time-value::duration))*) | (office:value-type::"boolean" (form:list-value::(office:boolean-value::boolean))*) | (office:value-type::"string" (form:list-value::(office:string-value::string))*) | (office:value-type::"void") ;
navigation ::= "none" | "current" | "parent" ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
any-time ::= number-hours | number-am-pm | number-minutes | number-seconds ;
common-table-range-attlist ::= common-table-cell-address-attlist | common-table-cell-range-address-attlist ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
any-number ::= number-number | number-scientific-number | number-fraction ;
horizontal-mirror ::= "horizontal" | "horizontal-on-odd" | "horizontal-on-even" ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
header-footer-content ::= (text-decls (text-h | text-p | text-list | table-table | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | text-index-title | change-marks)*) | (style-region-left? style-region-center? style-region-right?) ;
common-form-relative-image-position-attlist ::= ((form:image-position::"center")?) | (form:image-position::("start" | "end" | "top" | "bottom") (form:image-align::("start" | "center" | "end"))?) ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
tab-cycles ::= "records" | "current" | "page" ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
table-highlighted-range ::= table:highlighted-range::(table-highlighted-range-attlist | table-highlighted-range-attlist-invalid) ;
shapes3d ::= dr3d-scene | dr3d-extrude | dr3d-sphere | dr3d-rotate | dr3d-cube ;
states ::= "unchecked" | "checked" | "unknown" ;
custom-shape-type ::= "non-primitive" | string ;
table-columns-no-group ::= (table-columns (table-table-header-columns table-columns?)?) | (table-table-header-columns table-columns?) ;
--------------------odf::opendoc-1.0.bgf--------------------
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
text-note-class ::= text:note-class::("footnote" | "endnote") ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
types ::= "submit" | "reset" | "push" | "url" ;
table-rows ::= table-table-rows | (table-table-row+) ;
lineMode ::= "continuous" | "skip-white-space" ;
fontVariant ::= "normal" | "small-caps" ;
anim-animate-transform-attlist ::= svg:type::("translate" | "scale" | "rotate" | "skewX" | "skewY") ;
presentation-animation-elements ::= presentation-show-shape | presentation-show-text | presentation-hide-shape | presentation-hide-text | presentation-dim | presentation-play ;
presentation-classes ::= "title" | "outline" | "subtitle" | "text" | "graphic" | "object" | "chart" | "table" | "orgchart" | "page" | "notes" | "handout" | "header" | "footer" | "date-time" | "page-number" ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
common-num-format-attlist ::= (style:num-format::("1" | "i" | "I" | string | ε)) | (style:num-format::("a" | "A") style-num-letter-sync-attlist) | ε ;
fontPitch ::= "fixed" | "variable" ;
any-date ::= number-day | number-month | number-year | number-era | number-day-of-week | number-week-of-year | number-quarter | number-hours | number-am-pm | number-minutes | number-seconds ;
table-data-pilot-subtotal-attlist ::= table:function::("auto" | "average" | "count" | "countnums" | "max" | "min" | "product" | "stdev" | "stdevp" | "sum" | "var" | "varp" | string) ;
table-cut-offs ::= table:cut-offs::((table-movement-cut-off+) | (table-insertion-cut-off table-movement-cut-off*)) ;
text-bibliography-types ::= "article" | "book" | "booklet" | "conference" | "custom1" | "custom2" | "custom3" | "custom4" | "custom5" | "email" | "inbook" | "incollection" | "inproceedings" | "journal" | "manual" | "mastersthesis" | "misc" | "phdthesis" | "proceedings" | "techreport" | "unpublished" | "www" ;
form-property-value-and-type-attlist ::= common-value-and-type-attlist | (office:value-type::"void") ;
text-table-of-content-children ::= text-index-entry-chapter | text-index-entry-page-number | text-index-entry-text | text-index-entry-span | text-index-entry-tab-stop | text-index-entry-link-start | text-index-entry-link-end ;
change-marks ::= (text:change::change-mark-attr) | (text:change-start::change-mark-attr) | (text:change-end::change-mark-attr) ;
boolean ::= "true" | "false" ;
table-rows-no-group ::= (table-rows (table-table-header-rows table-rows?)?) | (table-table-header-rows table-rows?) ;
index-content-main ::= text-content | text-index-title ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
draw-glue-points-attlist ::= draw:escape-direction::("auto" | "left" | "right" | "up" | "down" | "horizontal" | "vertical") ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
common-draw-style-name-attlist ::= ((draw:style-name::styleNameRef)? (draw:class-names::styleNameRefs)?) | ((presentation:style-name::styleNameRef)? (presentation:class-names::styleNameRefs)?) ;
common-value-and-type-attlist ::= (office:value-type::"float" office:value::double) | (office:value-type::"percentage" office:value::double) | (office:value-type::"currency" office:value::double (office:currency::string)?) | (office:value-type::"date" office:date-value::dateOrDateTime) | (office:value-type::"time" office:time-value::duration) | (office:value-type::"boolean" office:boolean-value::boolean) | (office:value-type::"string" (office:string-value::string)?) ;
table-columns ::= table-table-columns | (table-table-column+) ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
office-text-content-main ::= (text-content*) | (text-page-sequence (draw-a | shape)*) ;
text-content ::= text-h | text-p | text-list | text-numbered-paragraph | table-table | draw-a | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | shape | change-marks ;
styleNameRef ::= string() | ε ;
text-list-level-style-image-attr ::= common-draw-data-attlist | office-binary-data ;
table-movement-cut-off-attlist ::= (table:position::integer) | (table:start-position::integer table:end-position::integer) ;
table-visibility-value ::= "visible" | "collapse" | "filter" ;
gradient-style ::= "linear" | "axial" | "radial" | "ellipsoid" | "square" | "rectangular" ;
form-property-type-and-value-list ::= (office:value-type::"float" (form:list-value::(office:value::double))*) | (office:value-type::"percentage" (form:list-value::(office:value::double))*) | (office:value-type::"currency" (form:list-value::(office:value::double (office:currency::string)?))*) | (office:value-type::"date" (form:list-value::(office:date-value::dateOrDateTime))*) | (office:value-type::"time" (form:list-value::(office:time-value::duration))*) | (office:value-type::"boolean" (form:list-value::(office:boolean-value::boolean))*) | (office:value-type::"string" (form:list-value::(office:string-value::string))*) | (office:value-type::"void") ;
navigation ::= "none" | "current" | "parent" ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
any-time ::= number-hours | number-am-pm | number-minutes | number-seconds ;
common-table-range-attlist ::= common-table-cell-address-attlist | common-table-cell-range-address-attlist ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
any-number ::= number-number | number-scientific-number | number-fraction ;
horizontal-mirror ::= "horizontal" | "horizontal-on-odd" | "horizontal-on-even" ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
header-footer-content ::= (text-decls (text-h | text-p | text-list | table-table | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | text-index-title | change-marks)*) | (style-region-left? style-region-center? style-region-right?) ;
common-form-relative-image-position-attlist ::= ((form:image-position::"center")?) | (form:image-position::("start" | "end" | "top" | "bottom") (form:image-align::("start" | "center" | "end"))?) ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
tab-cycles ::= "records" | "current" | "page" ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
table-highlighted-range ::= table:highlighted-range::(table-highlighted-range-attlist | table-highlighted-range-attlist-invalid) ;
shapes3d ::= dr3d-scene | dr3d-extrude | dr3d-sphere | dr3d-rotate | dr3d-cube ;
states ::= "unchecked" | "checked" | "unknown" ;
custom-shape-type ::= "non-primitive" | string ;
table-columns-no-group ::= (table-columns (table-table-header-columns table-columns?)?) | (table-table-header-columns table-columns?) ;
--------------------odf::opendoc-1.1-strict.bgf--------------------
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
text-note-class ::= text:note-class::("footnote" | "endnote") ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
types ::= "submit" | "reset" | "push" | "url" ;
table-rows ::= table-table-rows | ((text-soft-page-break? table-table-row)+) ;
lineMode ::= "continuous" | "skip-white-space" ;
fontVariant ::= "normal" | "small-caps" ;
anim-animate-transform-attlist ::= svg:type::("translate" | "scale" | "rotate" | "skewX" | "skewY") ;
presentation-animation-elements ::= presentation-show-shape | presentation-show-text | presentation-hide-shape | presentation-hide-text | presentation-dim | presentation-play ;
presentation-classes ::= "title" | "outline" | "subtitle" | "text" | "graphic" | "object" | "chart" | "table" | "orgchart" | "page" | "notes" | "handout" | "header" | "footer" | "date-time" | "page-number" ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
common-num-format-attlist ::= (style:num-format::("1" | "i" | "I" | string | ε)) | (style:num-format::("a" | "A") style-num-letter-sync-attlist) | ε ;
fontPitch ::= "fixed" | "variable" ;
any-date ::= number-day | number-month | number-year | number-era | number-day-of-week | number-week-of-year | number-quarter | number-hours | number-am-pm | number-minutes | number-seconds ;
table-data-pilot-subtotal-attlist ::= table:function::("auto" | "average" | "count" | "countnums" | "max" | "min" | "product" | "stdev" | "stdevp" | "sum" | "var" | "varp" | string) ;
table-cut-offs ::= table:cut-offs::((table-movement-cut-off+) | (table-insertion-cut-off table-movement-cut-off*)) ;
text-bibliography-types ::= "article" | "book" | "booklet" | "conference" | "custom1" | "custom2" | "custom3" | "custom4" | "custom5" | "email" | "inbook" | "incollection" | "inproceedings" | "journal" | "manual" | "mastersthesis" | "misc" | "phdthesis" | "proceedings" | "techreport" | "unpublished" | "www" ;
form-property-value-and-type-attlist ::= common-value-and-type-attlist | (office:value-type::"void") ;
text-table-of-content-children ::= text-index-entry-chapter | text-index-entry-page-number | text-index-entry-text | text-index-entry-span | text-index-entry-tab-stop | text-index-entry-link-start | text-index-entry-link-end ;
change-marks ::= (text:change::change-mark-attr) | (text:change-start::change-mark-attr) | (text:change-end::change-mark-attr) ;
boolean ::= "true" | "false" ;
table-rows-no-group ::= (table-rows (table-table-header-rows table-rows?)?) | (table-table-header-rows table-rows?) ;
index-content-main ::= text-content | text-index-title ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
draw-glue-points-attlist ::= draw:escape-direction::("auto" | "left" | "right" | "up" | "down" | "horizontal" | "vertical") ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
common-draw-style-name-attlist ::= ((draw:style-name::styleNameRef)? (draw:class-names::styleNameRefs)?) | ((presentation:style-name::styleNameRef)? (presentation:class-names::styleNameRefs)?) ;
common-value-and-type-attlist ::= (office:value-type::"float" office:value::double) | (office:value-type::"percentage" office:value::double) | (office:value-type::"currency" office:value::double (office:currency::string)?) | (office:value-type::"date" office:date-value::dateOrDateTime) | (office:value-type::"time" office:time-value::duration) | (office:value-type::"boolean" office:boolean-value::boolean) | (office:value-type::"string" (office:string-value::string)?) ;
table-columns ::= table-table-columns | (table-table-column+) ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
office-text-content-main ::= (text-content*) | (text-page-sequence (draw-a | shape)*) ;
text-content ::= text-h | text-p | text-list | text-numbered-paragraph | table-table | draw-a | text-section | text-soft-page-break | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | shape | change-marks ;
styleNameRef ::= string() | ε ;
text-list-level-style-image-attr ::= common-draw-data-attlist | office-binary-data ;
table-movement-cut-off-attlist ::= (table:position::integer) | (table:start-position::integer table:end-position::integer) ;
table-visibility-value ::= "visible" | "collapse" | "filter" ;
gradient-style ::= "linear" | "axial" | "radial" | "ellipsoid" | "square" | "rectangular" ;
form-property-type-and-value-list ::= (office:value-type::"float" (form:list-value::(office:value::double))*) | (office:value-type::"percentage" (form:list-value::(office:value::double))*) | (office:value-type::"currency" (form:list-value::(office:value::double (office:currency::string)?))*) | (office:value-type::"date" (form:list-value::(office:date-value::dateOrDateTime))*) | (office:value-type::"time" (form:list-value::(office:time-value::duration))*) | (office:value-type::"boolean" (form:list-value::(office:boolean-value::boolean))*) | (office:value-type::"string" (form:list-value::(office:string-value::string))*) | (office:value-type::"void") ;
navigation ::= "none" | "current" | "parent" ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
any-time ::= number-hours | number-am-pm | number-minutes | number-seconds ;
common-table-range-attlist ::= common-table-cell-address-attlist | common-table-cell-range-address-attlist ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
any-number ::= number-number | number-scientific-number | number-fraction ;
horizontal-mirror ::= "horizontal" | "horizontal-on-odd" | "horizontal-on-even" ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
header-footer-content ::= (text-tracked-changes text-decls (text-h | text-p | text-list | table-table | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | text-index-title | change-marks)*) | (style-region-left? style-region-center? style-region-right?) ;
common-form-relative-image-position-attlist ::= ((form:image-position::"center")?) | (form:image-position::("start" | "end" | "top" | "bottom") (form:image-align::("start" | "center" | "end"))?) ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
tab-cycles ::= "records" | "current" | "page" ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
table-highlighted-range ::= table:highlighted-range::(table-highlighted-range-attlist | table-highlighted-range-attlist-invalid) ;
shapes3d ::= dr3d-scene | dr3d-extrude | dr3d-sphere | dr3d-rotate | dr3d-cube ;
states ::= "unchecked" | "checked" | "unknown" ;
custom-shape-type ::= "non-primitive" | string ;
table-columns-no-group ::= (table-columns (table-table-header-columns table-columns?)?) | (table-table-header-columns table-columns?) ;
--------------------odf::opendoc-1.1.bgf--------------------
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
text-note-class ::= text:note-class::("footnote" | "endnote") ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
types ::= "submit" | "reset" | "push" | "url" ;
table-rows ::= table-table-rows | ((text-soft-page-break? table-table-row)+) ;
lineMode ::= "continuous" | "skip-white-space" ;
fontVariant ::= "normal" | "small-caps" ;
anim-animate-transform-attlist ::= svg:type::("translate" | "scale" | "rotate" | "skewX" | "skewY") ;
presentation-animation-elements ::= presentation-show-shape | presentation-show-text | presentation-hide-shape | presentation-hide-text | presentation-dim | presentation-play ;
presentation-classes ::= "title" | "outline" | "subtitle" | "text" | "graphic" | "object" | "chart" | "table" | "orgchart" | "page" | "notes" | "handout" | "header" | "footer" | "date-time" | "page-number" ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
common-num-format-attlist ::= (style:num-format::("1" | "i" | "I" | string | ε)) | (style:num-format::("a" | "A") style-num-letter-sync-attlist) | ε ;
fontPitch ::= "fixed" | "variable" ;
any-date ::= number-day | number-month | number-year | number-era | number-day-of-week | number-week-of-year | number-quarter | number-hours | number-am-pm | number-minutes | number-seconds ;
table-data-pilot-subtotal-attlist ::= table:function::("auto" | "average" | "count" | "countnums" | "max" | "min" | "product" | "stdev" | "stdevp" | "sum" | "var" | "varp" | string) ;
table-cut-offs ::= table:cut-offs::((table-movement-cut-off+) | (table-insertion-cut-off table-movement-cut-off*)) ;
text-bibliography-types ::= "article" | "book" | "booklet" | "conference" | "custom1" | "custom2" | "custom3" | "custom4" | "custom5" | "email" | "inbook" | "incollection" | "inproceedings" | "journal" | "manual" | "mastersthesis" | "misc" | "phdthesis" | "proceedings" | "techreport" | "unpublished" | "www" ;
form-property-value-and-type-attlist ::= common-value-and-type-attlist | (office:value-type::"void") ;
text-table-of-content-children ::= text-index-entry-chapter | text-index-entry-page-number | text-index-entry-text | text-index-entry-span | text-index-entry-tab-stop | text-index-entry-link-start | text-index-entry-link-end ;
change-marks ::= (text:change::change-mark-attr) | (text:change-start::change-mark-attr) | (text:change-end::change-mark-attr) ;
boolean ::= "true" | "false" ;
table-rows-no-group ::= (table-rows (table-table-header-rows table-rows?)?) | (table-table-header-rows table-rows?) ;
index-content-main ::= text-content | text-index-title ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
draw-glue-points-attlist ::= draw:escape-direction::("auto" | "left" | "right" | "up" | "down" | "horizontal" | "vertical") ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
shape ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
common-draw-style-name-attlist ::= ((draw:style-name::styleNameRef)? (draw:class-names::styleNameRefs)?) | ((presentation:style-name::styleNameRef)? (presentation:class-names::styleNameRefs)?) ;
common-value-and-type-attlist ::= (office:value-type::"float" office:value::double) | (office:value-type::"percentage" office:value::double) | (office:value-type::"currency" office:value::double (office:currency::string)?) | (office:value-type::"date" office:date-value::dateOrDateTime) | (office:value-type::"time" office:time-value::duration) | (office:value-type::"boolean" office:boolean-value::boolean) | (office:value-type::"string" (office:string-value::string)?) ;
table-columns ::= table-table-columns | (table-table-column+) ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
office-text-content-main ::= (text-content*) | (text-page-sequence (draw-a | shape)*) ;
text-content ::= text-h | text-p | text-list | text-numbered-paragraph | table-table | draw-a | text-section | text-soft-page-break | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | shape | change-marks ;
styleNameRef ::= string() | ε ;
text-list-level-style-image-attr ::= common-draw-data-attlist | office-binary-data ;
table-movement-cut-off-attlist ::= (table:position::integer) | (table:start-position::integer table:end-position::integer) ;
table-visibility-value ::= "visible" | "collapse" | "filter" ;
gradient-style ::= "linear" | "axial" | "radial" | "ellipsoid" | "square" | "rectangular" ;
form-property-type-and-value-list ::= (office:value-type::"float" (form:list-value::(office:value::double))*) | (office:value-type::"percentage" (form:list-value::(office:value::double))*) | (office:value-type::"currency" (form:list-value::(office:value::double (office:currency::string)?))*) | (office:value-type::"date" (form:list-value::(office:date-value::dateOrDateTime))*) | (office:value-type::"time" (form:list-value::(office:time-value::duration))*) | (office:value-type::"boolean" (form:list-value::(office:boolean-value::boolean))*) | (office:value-type::"string" (form:list-value::(office:string-value::string))*) | (office:value-type::"void") ;
navigation ::= "none" | "current" | "parent" ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
any-time ::= number-hours | number-am-pm | number-minutes | number-seconds ;
common-table-range-attlist ::= common-table-cell-address-attlist | common-table-cell-range-address-attlist ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
any-number ::= number-number | number-scientific-number | number-fraction ;
horizontal-mirror ::= "horizontal" | "horizontal-on-odd" | "horizontal-on-even" ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
header-footer-content ::= (text-tracked-changes text-decls (text-h | text-p | text-list | table-table | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | text-index-title | change-marks)*) | (style-region-left? style-region-center? style-region-right?) ;
common-form-relative-image-position-attlist ::= ((form:image-position::"center")?) | (form:image-position::("start" | "end" | "top" | "bottom") (form:image-align::("start" | "center" | "end"))?) ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
tab-cycles ::= "records" | "current" | "page" ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
table-highlighted-range ::= table:highlighted-range::(table-highlighted-range-attlist | table-highlighted-range-attlist-invalid) ;
shapes3d ::= dr3d-scene | dr3d-extrude | dr3d-sphere | dr3d-rotate | dr3d-cube ;
states ::= "unchecked" | "checked" | "unknown" ;
custom-shape-type ::= "non-primitive" | string ;
table-columns-no-group ::= (table-columns (table-table-header-columns table-columns?)?) | (table-table-header-columns table-columns?) ;
--------------------odf::opendoc-1.2.bgf--------------------
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
presentation-decl ::= (presentation:header-decl::(presentation-header-decl-attlist string())) | (presentation:footer-decl::(presentation-footer-decl-attlist string())) | (presentation:date-time-decl::(presentation-date-time-decl-attlist string())) ;
text-note-class ::= text:note-class::("footnote" | "endnote") ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
types ::= "submit" | "reset" | "push" | "url" ;
text-changed-region-content ::= (text:insertion::office-change-info) | (text:deletion::(office-change-info text-content*)) | (text:format-change::office-change-info) ;
table-rows ::= table-table-rows | ((text-soft-page-break? table-table-row)+) ;
presentation-classes ::= "title" | "outline" | "subtitle" | "text" | "graphic" | "object" | "chart" | "table" | "orgchart" | "page" | "notes" | "handout" | "header" | "footer" | "date-time" | "page-number" ;
any-date ::= number-day | number-month | number-year | number-era | number-day-of-week | number-week-of-year | number-quarter | number-hours | number-am-pm | number-minutes | number-seconds ;
table-data-pilot-subtotal-attlist ::= table:function::("auto" | "average" | "count" | "countnums" | "max" | "min" | "product" | "stdev" | "stdevp" | "sum" | "var" | "varp" | string) ;
text-bibliography-types ::= "article" | "book" | "booklet" | "conference" | "custom1" | "custom2" | "custom3" | "custom4" | "custom5" | "email" | "inbook" | "incollection" | "inproceedings" | "journal" | "manual" | "mastersthesis" | "misc" | "phdthesis" | "proceedings" | "techreport" | "unpublished" | "www" ;
text-table-of-content-children ::= text-index-entry-chapter | text-index-entry-page-number | text-index-entry-text | text-index-entry-span | text-index-entry-tab-stop | text-index-entry-link-start | text-index-entry-link-end ;
change-marks ::= (text:change::change-mark-attr) | (text:change-start::change-mark-attr) | (text:change-end::change-mark-attr) ;
rowOrCol ::= "row" | "column" ;
URIorSafeCURIE ::= anyURI | SafeCURIE ;
common-draw-style-name-attlist ::= ((draw:style-name::styleNameRef)? (draw:class-names::styleNameRefs)?) | ((presentation:style-name::styleNameRef)? (presentation:class-names::styleNameRefs)?) ;
common-value-and-type-attlist ::= (office:value-type::"float" office:value::double) | (office:value-type::"percentage" office:value::double) | (office:value-type::"currency" office:value::double (office:currency::string)?) | (office:value-type::"date" office:date-value::dateOrDateTime) | (office:value-type::"time" office:time-value::duration) | (office:value-type::"boolean" office:boolean-value::boolean) | (office:value-type::"string" (office:string-value::string)?) ;
table-columns ::= table-table-columns | (table-table-column+) ;
office-text-content-main ::= (text-content*) | (text-page-sequence shape*) ;
text-content ::= text-h | text-p | text-list | text-numbered-paragraph | table-table | text-section | text-soft-page-break | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | shape | change-marks ;
text-list-level-style-image-attr ::= common-draw-data-attlist | office-binary-data ;
table-movement-cut-off-attlist ::= (table:position::integer) | (table:start-position::integer table:end-position::integer) ;
labelPositions ::= "avoid-overlap" | "center" | "top" | "top-right" | "right" | "bottom-right" | "bottom" | "bottom-left" | "left" | "top-left" | "inside" | "outside" | "near-origin" ;
gradient-style ::= "linear" | "axial" | "radial" | "ellipsoid" | "square" | "rectangular" ;
paragraph-content-or-hyperlink ::= paragraph-content | text-a ;
lineType ::= "none" | "single" | "double" ;
column-controls ::= (form:text::(form-text-attlist common-form-control-content)) | (form:textarea::(form-textarea-attlist common-form-control-content text-p*)) | (form:formatted-text::(form-formatted-text-attlist common-form-control-content)) | (form:number::(form-number-attlist common-numeric-control-attlist common-form-control-content common-linked-cell common-spin-button common-repeat common-delay-for-repeat)) | (form:date::(form-date-attlist common-numeric-control-attlist common-form-control-content common-linked-cell common-spin-button common-repeat common-delay-for-repeat)) | (form:time::(form-time-attlist common-numeric-control-attlist common-form-control-content common-linked-cell common-spin-button common-repeat common-delay-for-repeat)) | (form:combobox::(form-combobox-attlist common-form-control-content form-item*)) | (form:listbox::(form-listbox-attlist common-form-control-content form-option*)) | (form:checkbox::(form-checkbox-attlist common-form-control-content)) ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
any-number ::= number-number | number-scientific-number | number-fraction ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
db-data-types ::= "bit" | "boolean" | "tinyint" | "smallint" | "integer" | "bigint" | "float" | "real" | "double" | "numeric" | "decimal" | "char" | "varchar" | "longvarchar" | "date" | "time" | "timestmp" | "binary" | "varbinary" | "longvarbinary" | "sqlnull" | "other" | "object" | "distinct" | "struct" | "array" | "blob" | "clob" | "ref" ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
custom-shape-type ::= "non-primitive" | string ;
style-style-content ::= (style:family::"text" style-text-properties?) | (style:family::"paragraph" style-paragraph-properties? style-text-properties?) | (style:family::"section" style-section-properties?) | (style:family::"ruby" style-ruby-properties?) | (style:family::"table" style-table-properties?) | (style:family::"table-column" style-table-column-properties?) | (style:family::"table-row" style-table-row-properties?) | (style:family::"table-cell" style-table-cell-properties? style-paragraph-properties? style-text-properties?) | (style:family::("graphic" | "presentation") style-graphic-properties? style-paragraph-properties? style-text-properties?) | (style:family::"drawing-page" style-drawing-page-properties?) | (style:family::"chart" style-chart-properties? style-graphic-properties? style-paragraph-properties? style-text-properties?) ;
shape-instance ::= draw-rect | draw-line | draw-polyline | draw-polygon | draw-regular-polygon | draw-path | draw-circle | draw-ellipse | draw-g | draw-page-thumbnail | draw-frame | draw-measure | draw-caption | draw-connector | draw-control | dr3d-scene | draw-custom-shape ;
draw-rect-attlist ::= ((draw:corner-radius::nonNegativeLength)?) | ((svg:rx::nonNegativeLength)? (svg:ry::nonNegativeLength)?) ;
office-body-content ::= (office:text::(office-text-attlist office-text-content-prelude office-text-content-main office-text-content-epilogue)) | (office:drawing::(office-drawing-attlist office-drawing-content-prelude office-drawing-content-main office-drawing-content-epilogue)) | (office:presentation::(office-presentation-attlist office-presentation-content-prelude office-presentation-content-main office-presentation-content-epilogue)) | (office:spreadsheet::(office-spreadsheet-attlist office-spreadsheet-content-prelude office-spreadsheet-content-main office-spreadsheet-content-epilogue)) | (office:chart::(office-chart-attlist office-chart-content-prelude office-chart-content-main office-chart-content-epilogue)) | (office:image::(office-image-attlist office-image-content-prelude office-image-content-main office-image-content-epilogue)) | office-database ;
form-property ::= (form:property::(form-property-name form-property-value-and-type-attlist)) | (form:list-property::(form-property-name form-property-type-and-value-list)) ;
db-data-source-setting-types ::= "boolean" | "short" | "int" | "long" | "double" | "string" ;
lineMode ::= "continuous" | "skip-white-space" ;
chart-dimension ::= "x" | "y" | "z" ;
fontVariant ::= "normal" | "small-caps" ;
anim-animate-transform-attlist ::= svg:type::("translate" | "scale" | "rotate" | "skewX" | "skewY") ;
controls ::= column-controls | (form:password::(form-password-attlist common-form-control-content)) | (form:file::(form-file-attlist common-form-control-content)) | (form:fixed-text::(form-fixed-text-attlist common-form-control-content)) | (form:button::(form-button-attlist common-form-control-content)) | (form:image::(form-image-attlist common-form-control-content)) | (form:radio::(form-radio-attlist common-form-control-content)) | (form:frame::(form-frame-attlist common-form-control-content)) | (form:image-frame::(form-image-frame-attlist common-form-control-content)) | (form:hidden::(form-hidden-attlist common-form-control-content)) | (form:grid::(form-grid-attlist common-form-control-content form-column*)) | (form:value-range::(form-value-range-attlist common-form-control-content)) | (form:generic-control::(form-generic-control-attlist common-form-control-content)) ;
presentation-animation-elements ::= presentation-show-shape | presentation-show-text | presentation-hide-shape | presentation-hide-text | presentation-dim | presentation-play ;
animation-element ::= (anim:animate::(common-anim-target-attlist common-anim-named-target-attlist common-anim-values-attlist common-anim-spline-mode-attlist common-spline-anim-value-attlist common-timing-attlist common-anim-add-accum-attlist)) | (anim:set::(common-anim-target-attlist common-anim-named-target-attlist common-anim-set-values-attlist common-timing-attlist common-anim-add-accum-attlist)) | (anim:animateMotion::(anim-animate-motion-attlist common-anim-target-attlist common-anim-named-target-attlist common-anim-add-accum-attlist common-anim-values-attlist common-timing-attlist common-spline-anim-value-attlist)) | (anim:animateColor::(common-anim-target-attlist common-anim-named-target-attlist common-anim-add-accum-attlist common-anim-values-attlist common-anim-spline-mode-attlist common-spline-anim-value-attlist anim-animate-color-attlist common-timing-attlist)) | (anim:animateTransform::(common-anim-target-attlist common-anim-named-target-attlist common-anim-add-accum-attlist common-anim-values-attlist anim-animate-transform-attlist common-timing-attlist)) | (anim:transitionFilter::(common-anim-target-attlist common-anim-add-accum-attlist common-anim-values-attlist common-anim-spline-mode-attlist anim-transition-filter-attlist common-timing-attlist)) | (anim:par::(common-anim-attlist common-timing-attlist common-endsync-timing-attlist animation-element*)) | (anim:seq::(common-anim-attlist common-endsync-timing-attlist common-timing-attlist animation-element*)) | (anim:iterate::(common-anim-attlist anim-iterate-attlist common-timing-attlist common-endsync-timing-attlist animation-element*)) | (anim:audio::(common-anim-attlist anim-audio-attlist common-basic-timing-attlist)) | (anim:command::(common-anim-attlist anim-command-attlist common-begin-end-timing-attlist common-anim-target-attlist (anim:param::(anim:name::string anim:value::string))*)) ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
common-num-format-attlist ::= (style:num-format::("1" | "i" | "I" | string | ε)) | (style:num-format::("a" | "A") style-num-letter-sync-attlist) | ε ;
fontPitch ::= "fixed" | "variable" ;
table-cut-offs ::= table:cut-offs::((table-movement-cut-off+) | (table-insertion-cut-off table-movement-cut-off*)) ;
form-property-value-and-type-attlist ::= common-value-and-type-attlist | (office:value-type::"void") ;
boolean ::= "true" | "false" ;
table-rows-no-group ::= (table-rows (table-table-header-rows table-rows?)?) | (table-table-header-rows table-rows?) ;
index-content-main ::= text-content | text-index-title ;
common-field-database-name ::= ((text:database-name::string)?) | form-connection-resource ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
shape ::= shape-instance | draw-a ;
office-meta-data ::= (meta:generator::string) | (dc:title::string) | (dc:description::string) | (dc:subject::string) | (meta:keyword::string) | (meta:initial-creator::string) | dc-creator | (meta:printed-by::string) | (meta:creation-date::dateTime) | dc-date | (meta:print-date::dateTime) | (meta:template::(xlink:type::"simple" xlink:href::anyIRI (xlink:actuate::"onRequest")? (xlink:title::string)? (meta:date::dateTime)?)) | (meta:auto-reload::((xlink:type::"simple" xlink:href::anyIRI (xlink:show::"replace")? (xlink:actuate::"onLoad")?)? (meta:delay::duration)?)) | (meta:hyperlink-behaviour::((office:target-frame-name::targetFrameName)? (xlink:show::("new" | "replace"))?)) | (dc:language::language) | (meta:editing-cycles::nonNegativeInteger) | (meta:editing-duration::duration) | (meta:document-statistic::((meta:page-count::nonNegativeInteger)? (meta:table-count::nonNegativeInteger)? (meta:draw-count::nonNegativeInteger)? (meta:image-count::nonNegativeInteger)? (meta:ole-object-count::nonNegativeInteger)? (meta:object-count::nonNegativeInteger)? (meta:paragraph-count::nonNegativeInteger)? (meta:word-count::nonNegativeInteger)? (meta:character-count::nonNegativeInteger)? (meta:frame-count::nonNegativeInteger)? (meta:sentence-count::nonNegativeInteger)? (meta:syllable-count::nonNegativeInteger)? (meta:non-whitespace-character-count::nonNegativeInteger)? (meta:row-count::nonNegativeInteger)? (meta:cell-count::nonNegativeInteger)?)) | (meta:user-defined::(meta:name::string (meta:value-type::"float" double) | (meta:value-type::"date" dateOrDateTime) | (meta:value-type::"time" duration) | (meta:value-type::"boolean" boolean) | (meta:value-type::"string" string) | string())) ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
common-ref-format-values ::= "page" | "chapter" | "direction" | "text" ;
paragraph-content ::= string() | (text:s::((text:c::nonNegativeInteger)?)) | (text:tab::text-tab-attr) | (text:line-break::ε) | text-soft-page-break | (text:span::((text:style-name::styleNameRef)? (text:class-names::styleNameRefs)? paragraph-content-or-hyperlink*)) | (text:meta::(text-meta-attlist paragraph-content-or-hyperlink*)) | text-bookmark | text-bookmark-start | text-bookmark-end | (text:reference-mark::(text:name::string)) | (text:reference-mark-start::(text:name::string)) | (text:reference-mark-end::(text:name::string)) | (text:note::(text-note-class (text:id::string)? text:note-citation::((text:label::string)? string()) text:note-body::(text-content*))) | (text:ruby::((text:style-name::styleNameRef)? text:ruby-base::(paragraph-content-or-hyperlink*) text:ruby-text::((text:style-name::styleNameRef)? string()))) | office-annotation | office-annotation-end | change-marks | shape | (text:date::(text-date-attlist string())) | (text:time::(text-time-attlist string())) | (text:page-number::(text-page-number-attlist string())) | (text:page-continuation::(text-page-continuation-attlist string())) | (text:sender-firstname::(common-field-fixed-attlist string())) | (text:sender-lastname::(common-field-fixed-attlist string())) | (text:sender-initials::(common-field-fixed-attlist string())) | (text:sender-title::(common-field-fixed-attlist string())) | (text:sender-position::(common-field-fixed-attlist string())) | (text:sender-email::(common-field-fixed-attlist string())) | (text:sender-phone-private::(common-field-fixed-attlist string())) | (text:sender-fax::(common-field-fixed-attlist string())) | (text:sender-company::(common-field-fixed-attlist string())) | (text:sender-phone-work::(common-field-fixed-attlist string())) | (text:sender-street::(common-field-fixed-attlist string())) | (text:sender-city::(common-field-fixed-attlist string())) | (text:sender-postal-code::(common-field-fixed-attlist string())) | (text:sender-country::(common-field-fixed-attlist string())) | (text:sender-state-or-province::(common-field-fixed-attlist string())) | (text:author-name::(common-field-fixed-attlist string())) | (text:author-initials::(common-field-fixed-attlist string())) | (text:chapter::(text-chapter-attlist string())) | (text:file-name::(text-file-name-attlist string())) | (text:template-name::(text-template-name-attlist string())) | (text:sheet-name::string()) | (text:variable-set::(common-field-name-attlist common-field-formula-attlist common-value-and-type-attlist common-field-display-value-none-attlist common-field-data-style-name-attlist string())) | (text:variable-get::(common-field-name-attlist common-field-display-value-formula-attlist common-field-data-style-name-attlist string())) | (text:variable-input::(common-field-name-attlist common-field-description-attlist common-value-type-attlist common-field-display-value-none-attlist common-field-data-style-name-attlist string())) | (text:user-field-get::(common-field-name-attlist common-field-display-value-formula-none-attlist common-field-data-style-name-attlist string())) | (text:user-field-input::(common-field-name-attlist common-field-description-attlist common-field-data-style-name-attlist string())) | (text:sequence::(common-field-name-attlist common-field-formula-attlist common-field-num-format-attlist text-sequence-ref-name string())) | (text:expression::(common-field-formula-attlist common-value-and-type-attlist? common-field-display-value-formula-attlist common-field-data-style-name-attlist string())) | (text:text-input::(common-field-description-attlist string())) | (text:initial-creator::(common-field-fixed-attlist string())) | (text:creation-date::(common-field-fixed-attlist common-field-data-style-name-attlist (text:date-value::dateOrDateTime)? string())) | (text:creation-time::(common-field-fixed-attlist common-field-data-style-name-attlist (text:time-value::timeOrDateTime)? string())) | (text:description::(common-field-fixed-attlist string())) | (text:user-defined::(common-field-fixed-attlist text:name::string common-field-data-style-name-attlist (office:value::double)? (office:date-value::dateOrDateTime)? (office:time-value::duration)? (office:boolean-value::boolean)? (office:string-value::string)? string())) | (text:print-time::(common-field-fixed-attlist common-field-data-style-name-attlist (text:time-value::time)? string())) | (text:print-date::(common-field-fixed-attlist common-field-data-style-name-attlist (text:date-value::date)? string())) | (text:printed-by::(common-field-fixed-attlist string())) | (text:title::(common-field-fixed-attlist string())) | (text:subject::(common-field-fixed-attlist string())) | (text:keywords::(common-field-fixed-attlist string())) | (text:editing-cycles::(common-field-fixed-attlist string())) | (text:editing-duration::(common-field-fixed-attlist common-field-data-style-name-attlist (text:duration::duration)? string())) | (text:modification-time::(common-field-fixed-attlist common-field-data-style-name-attlist (text:time-value::time)? string())) | (text:modification-date::(common-field-fixed-attlist common-field-data-style-name-attlist (text:date-value::date)? string())) | (text:creator::(common-field-fixed-attlist string())) | (text:page-count::(common-field-num-format-attlist string())) | (text:paragraph-count::(common-field-num-format-attlist string())) | (text:word-count::(common-field-num-format-attlist string())) | (text:character-count::(common-field-num-format-attlist string())) | (text:table-count::(common-field-num-format-attlist string())) | (text:image-count::(common-field-num-format-attlist string())) | (text:object-count::(common-field-num-format-attlist string())) | (text:database-display::(text-database-display-attlist string())) | (text:database-next::text-database-next-attlist) | (text:database-row-select::text-database-row-select-attlist) | (text:database-row-number::(common-field-database-table common-field-num-format-attlist (text:value::nonNegativeInteger)? string())) | (text:database-name::(common-field-database-table string())) | (text:page-variable-set::(text-set-page-variable-attlist string())) | (text:page-variable-get::(text-get-page-variable-attlist string())) | (text:placeholder::(text-placeholder-attlist string())) | (text:conditional-text::(text-conditional-text-attlist string())) | (text:hidden-text::(text-hidden-text-attlist string())) | (text:reference-ref::(text-common-ref-content text-bookmark-ref-content)) | (text:bookmark-ref::(text-common-ref-content text-bookmark-ref-content)) | (text:note-ref::(text-common-ref-content text-note-ref-content)) | (text:sequence-ref::(text-common-ref-content text-sequence-ref-content)) | (text:script::((xlink:type::"simple" xlink:href::anyIRI) | string() (script:language::string)?)) | (text:execute-macro::((text:name::string)? office-event-listeners? string())) | (text:hidden-paragraph::(text-hidden-paragraph-attlist string())) | (text:dde-connection::(text:connection-name::string string())) | (text:measure::(text:kind::("value" | "unit" | "gap") string())) | (text:table-formula::(common-field-formula-attlist common-field-display-value-formula-attlist common-field-data-style-name-attlist string())) | (text:meta-field::(text-meta-field-attlist paragraph-content-or-hyperlink*)) | (text:toc-mark-start::text-toc-mark-start-attrs) | (text:toc-mark-end::text-id) | (text:toc-mark::(text:string-value::string text-outline-level)) | (text:user-index-mark-start::(text-id text-outline-level text-index-name)) | (text:user-index-mark-end::text-id) | (text:user-index-mark::(text:string-value::string text-outline-level text-index-name)) | (text:alphabetical-index-mark-start::(text-id text-alphabetical-index-mark-attrs)) | (text:alphabetical-index-mark-end::text-id) | (text:alphabetical-index-mark::(text:string-value::string text-alphabetical-index-mark-attrs)) | (text:bibliography-mark::(text:bibliography-type::text-bibliography-types ((text:identifier::string) | (text:address::string) | (text:annote::string) | (text:author::string) | (text:booktitle::string) | (text:chapter::string) | (text:edition::string) | (text:editor::string) | (text:howpublished::string) | (text:institution::string) | (text:journal::string) | (text:month::string) | (text:note::string) | (text:number::string) | (text:organizations::string) | (text:pages::string) | (text:publisher::string) | (text:school::string) | (text:series::string) | (text:title::string) | (text:report-type::string) | (text:volume::string) | (text:year::string) | (text:url::string) | (text:custom1::string) | (text:custom2::string) | (text:custom3::string) | (text:custom4::string) | (text:custom5::string) | (text:isbn::string) | (text:issn::string))* string())) | (presentation:header::ε) | (presentation:footer::ε) | (presentation:date-time::ε) ;
styleNameRef ::= string() | ε ;
table-visibility-value ::= "visible" | "collapse" | "filter" ;
form-property-type-and-value-list ::= (office:value-type::"float" (form:list-value::(office:value::double))*) | (office:value-type::"percentage" (form:list-value::(office:value::double))*) | (office:value-type::"currency" (form:list-value::(office:value::double (office:currency::string)?))*) | (office:value-type::"date" (form:list-value::(office:date-value::dateOrDateTime))*) | (office:value-type::"time" (form:list-value::(office:time-value::duration))*) | (office:value-type::"boolean" (form:list-value::(office:boolean-value::boolean))*) | (office:value-type::"string" (form:list-value::(office:string-value::string))*) | (office:value-type::"void") ;
navigation ::= "none" | "current" | "parent" ;
horiBackPos ::= "left" | "center" | "right" ;
text-list-style-content ::= (text:list-level-style-number::(text-list-level-style-attr text-list-level-style-number-attr style-list-level-properties? style-text-properties?)) | (text:list-level-style-bullet::(text-list-level-style-attr text-list-level-style-bullet-attr style-list-level-properties? style-text-properties?)) | (text:list-level-style-image::(text-list-level-style-attr text-list-level-style-image-attr style-list-level-properties?)) ;
any-time ::= number-hours | number-am-pm | number-minutes | number-seconds ;
common-table-range-attlist ::= common-table-cell-address-attlist | common-table-cell-range-address-attlist ;
horizontal-mirror ::= "horizontal" | "horizontal-on-odd" | "horizontal-on-even" ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
header-footer-content ::= (text-tracked-changes text-decls (text-h | text-p | text-list | table-table | text-section | text-table-of-content | text-illustration-index | text-table-index | text-object-index | text-user-index | text-alphabetical-index | text-bibliography | text-index-title | change-marks)*) | (style-region-left? style-region-center? style-region-right?) ;
common-form-relative-image-position-attlist ::= ((form:image-position::"center")?) | (form:image-position::("start" | "end" | "top" | "bottom") (form:image-align::("start" | "center" | "end"))?) ;
tab-cycles ::= "records" | "current" | "page" ;
table-highlighted-range ::= table:highlighted-range::(table-highlighted-range-attlist | table-highlighted-range-attlist-invalid) ;
shapes3d ::= dr3d-scene | dr3d-extrude | dr3d-sphere | dr3d-rotate | dr3d-cube ;
states ::= "unchecked" | "checked" | "unknown" ;
table-columns-no-group ::= (table-columns (table-table-header-columns table-columns?)?) | (table-table-header-columns table-columns?) ;
--------------------pascal::delphi.bgf--------------------
external_name ::= ("name" expr) | ("index" expr) ;
builtinid ::= "string" | "file" | "set" ;
sign ::= "+" | "-" ;
procedure_keyword ::= "function" | "procedure" | "constructor" | "destructor" ;
real_type ::= "real" | "real48" | "single" | "double" | "extended" | "comp" | "currency" ;
selection_stm ::= ("if" expr "then" nested_stm else_stm?) | ("case" expr "of" case_selector* case_else? end_struct) ;
default_spec ::= ("default" SP expr) | "nodefault" ;
constant_spec ::= (equal expr) | (colon_type const_init) ;
anynumber ::= hexnumber | number ;
to_or_downto ::= "to" | "downto" ;
variant_type ::= "variant" | "olevariant" ;
accessor_spec ::= "readonly" | "writeonly" | (accessor_verb qualified_id) ;
boolean_type ::= "boolean" | "bytebool" | "wordbool" | "longbool" ;
impldecl_section ::= const_section | type_section | var_section | label_decl | procedure_impl_decl | procedure_external_decl | resource_section | exports_section ;
filenamelit ::= charlit | stringlit | qualified_id ;
array_index ::= ordinal_type | qualified_id ;
initialization_kw ::= "initialization" | "begin" ;
string_type ::= "string" | "shortstring" | "ansistring" | "widestring" | ("string" "[" expression "]") ;
var_init ::= absolute_init | const_init ;
postfix_opr ::= arguments | array_subscript | ("." id) | "^" ;
simple_type ::= ordinal_type | real_type ;
intfdecl_section ::= const_section | type_section | var_section | label_decl | procedure_intf_decl | procedure_external_decl | resource_section | exports_section ;
nested_stm ::= sequence_stm | (NL IN statement? EX) ;
struct_type ::= set_type | array_type | file_type ;
atom_expr ::= charlit | anynumber | ctrlchar | "nil" | ("(" expression ")") | set_constructor | qualified_id ;
interface_keyword ::= "interface" | "dispinterface" ;
prop_specifier ::= index_spec | accessor_spec | stored_spec | default_spec | implements_spec | dispid_spec ;
class_keyword ::= "class" | "record" | "object" ;
array_type ::= ("array" of_const) | ("packed"? "array" array_index_list* of_basetype) ;
type_spec ::= simple_type | string_type | struct_type | pointer_type | procedural_type | variant_type | class_reference_type | class_type | interface_type | qualified_id ;
heritage_list ::= ("(" {qualified_id ","}* ")") | ("helper" "for" id) ;
exception_block ::= (exception_handler_list case_else?) | statement_list ;
jump_stm ::= goto_stm | raise_stm ;
integer_type ::= "shortint" | "smallint" | "longint" | "int64" | "word" | "byte" | "longword" | "integer" | "cardinal" ;
nested_decl_section ::= const_section | type_section | var_section | label_decl | procedure_impl_decl ;
accessor_verb ::= "read" | "write" ;
hint_directive ::= "platform" | "deprecated" | "library" ;
calling_spec ::= "pascal" | "safecall" | "stdcall" | "cdecl" | "register" | "local" ;
delphi_file ::= program_file | package_file | unit_file ;
visibility ::= "public" | "protected" | ("strict"? "private") | "published" | "automated" ;
loop_stm ::= ("repeat" statement_list "until" expr) | ("while" expr "do" nested_stm) | ("for" id ":=" expr to_or_downto expr "do" nested_stm) | ("for" id "in" id "do" nested_stm) ;
var_keyword ::= "var" | "threadvar" ;
directive ::= "dynamic" | "virtual" | "abstract" | ("message" qualified_id?) | ("dispid" sign? anynumber) | "override" | "overload" | "reintroduce" | "static" | "assembler" | "far" | "export" | hint_directive | calling_spec ;
procedure_body ::= sequence_stm | "forward" ;
typed_const ::= array_constant | record_constant | expr ;
call_stm ::= expr | "inherited" ;
name ::= builtinid | id ;
method_decl ::= (procedure_signature method_deleg) | (procedure_signature ";" dispid_spec ";") | procedure_intf_decl ;
ordinal_type ::= integer_type | char_type | enumerated_type | boolean_type | subrange_type ;
unlabeled_stm ::= sequence_stm | loop_stm | with_stm | try_finally_stm | try_except_stm | selection_stm | jump_stm | assign_stm | call_stm ;
label_id ::= anynumber | id ;
program_decl ::= ("program" qualified_id program_file_list? ";" NL) | ("library" qualified_id ";" NL) ;
prefix_opr ::= ("not" SP) | ("inherited" SP) | "@" | sign ;
char_type ::= "char" | "ansichar" | "widechar" ;
infix_opr ::= ">" | "<" | "<=" | ">=" | "<>" | "=" | "in" | "is" | "as" | "+" | "-" | "or" | "xor" | "*" | "/" | "div" | "mod" | "and" | "shl" | "shr" | "^" ;
parm_qual ::= "var" | "const" | "out" ;
class_member ::= var_decl | method_decl | property_decl | variant_section ;
ctrlchar ::= "^'A" | "^'B" | "^'C" | "^'D" | "^'E" | "^'F" | "^'G" | "^'H" | "^'I" | "^'J" | "^'K" | "^'L" | "^'M" | "^'N" | "^'O" | "^'P" | "^'Q" | "^'R" | "^'S" | "^'T" | "^'U" | "^'V" | "^'W" | "^'X" | "^'Y" | "^'Z" ;
prop_index_modifier ::= "const" | "var" ;
--------------------pascal::delphipp.bgf--------------------
pp_boolexpr ::= booleanlit | (boolfunc space? "(" id ")") | ("NOT" space? pp_boolexpr) | id | (pp_boolexpr "pp_boolopr" pp_boolexpr) | (pp_litexpr "pp_compareopr" pp_litexpr) | ("(" pp_boolexpr ")") ;
pp_endif ::= ("{$" space? endif_alt bracketbody* "}") | ("(*$" space? endif_alt starbody* "*)") ;
pp_directivestmt ::= ("{$" space? {pp_directive ","}* bracketbody* "}") | ("(*$" space? {pp_directive ","}* starbody* "*)") ;
anynumber ::= number | hexnumber ;
pp_minenumsize ::= "Z1" | "Z2" | "Z4" ;
pp_stmt_or_water ::= (pp_stmt) | (pp_comment) | (pp_any) ;
pp_ifexpr ::= ("{$" space? if_alt bracketbody* "}") | ("(*$" space? if_alt starbody* "*)") ;
pp_directive ::= ("DEFINE" space id) | ("UNDEF" space id) | ("INCLUDE" space? filenamelit) | ("I" space? filenamelit) | ("LINK" space? filenamelit) | ("L" space? filenamelit) | ("RESOURCE" space? filenamelit space? filenamelit?) | ("R" space? filenamelit space? filenamelit?) | ("HPPEMIT" space? charlit) | ("EXTERNALSYM" space id) | "NODEFINE" | "MINENUMSIZE" | "DENYPACKAGEUNIT" | "WEAKPACKAGEUNIT" | ("IMAGEBASE" space? anynumber) | ("C" space id) | ("MINENUMSIZE" space anynumber) | pp_minenumsize | ("ALIGN" space? anynumber) | pp_align | ("M" space? {anynumber ","}*) | ("MAXSTACKSIZE" space anynumber) | ("MINSTACKSIZE" space anynumber) | ("RESOURCERESERVE" space anynumber) | "NOINCLUDE" | "WARN" | "MESSAGE" | "APPTYPE" | ("LIBPREFIX" space? charlit) | ("LIBSUFIX" space? charlit) | ("LIBVERSION" space? charlit) | ("DESCRIPTION" space? charlit) | ("D" space? charlit) | ("EXTENSION" space id) | ("E" space id) | (pp_switch space?) ;
filenamelit ::= charlit | stringlit | nested_id ;
ident ::= id | (key) ;
booleanlit ::= "FALSE" | "TRUE" ;
boolfunc ::= "DEFINED" | "DECLARED" | "OPTION" ;
pp_litexpr ::= id | charlit | anynumber ;
pp_any ::= (id codetoken*) | key | token ;
codetoken ::= "(" | ")" | "." | ";" | ":" | "," | "[" | "]" | "+" | "-" | "*" | "/" | "^" | "=" | "@" | ">" | "<" | "<>" | ">=" | "<=" | ":=" | "//" | id | anynumber | charlit | space ;
pp_compareopr ::= ">" | "<" | "=" | ">=" | "<=" | "<>" ;
pp_elseifexpr ::= ("{$" space? else_alt space? bracketbody* "}") | ("(*$" space? else_alt space? starbody* "*)") ;
pp_boolopr ::= "AND" | "OR" | "XOR" ;
if_alt ::= ("IF" space? pp_boolexpr) | ("IFDEF" space? id) | ("IFNDEF" space? id) | ("IFOPT" space? pp_switch) ;
pp_stmt ::= pp_ifstmt | (pp_directivestmt) ;
pp_align ::= "A1" | "A2" | "A4" | "A8" ;
else_alt ::= ("ELSEIF" space? pp_boolexpr) | ("ELSE" space?) ;
endif_alt ::= "ENDIF" | "IFEND" ;
pp_comment ::= cmbracketblock | cmstarblock | cmline ;
pp_switchopt ::= "+" | "-" | "ON" | "OFF" ;
--------------------pascal::object.bgf--------------------
object ::= (id object_modifier*) | ("(" ref_name ")" object_modifier*) ;
add_op ::= "+" | "-" | "or" | "xor" ;
mul_op ::= "*" | "/" | "div" | "mod" | "and" | "shl" | "shr" | "DIV" | "AND" ;
proc_or_func_heading ::= procedure_heading | function_heading ;
type ::= typeId | simpleType | structType | pointerType | stringType | procedureType | variantType | class_referenceType ;
class_visibility ::= "public" | "protected" | "Protected" | "private" | "published" ;
procedure_section ::= procedure_declaration | function_declaration | constructor_declaration | destructor_declaration ;
realType ::= "real48" | "real" | "single" | "double" | "extended" | "currency" | "comp" ;
ordinal_identifier ::= "shortint" | "smallint" | "integer" | "byte" | "longint" | "int64" | "word" | "boolean" | "char" | "widechar" | "longchar" | "pchar" ;
not_word ::= "not" | "Not" | "NOT" ;
conditional_statement ::= if_statement | case_statement ;
init_section ::= ("intitialization" IN NL statement_list fin_statement_list? EX NL "end") | compound_statement | "end" ;
to_or_downto ::= "to" | "downto" ;
class_element ::= virtual_method_heading | ident_list_colonType | property_list | ε ;
typeId ::= ref_name | predefinedType ;
restrictedType ::= objectType | classType | interfaceType ;
property_word ::= "property" | "Property" ;
interface_declaration ::= constant_section | type_section | var_section | (exported_heading directive?) ;
as ::= "As" | "as" ;
array_word ::= "array" | "Array" ;
statement ::= (labelId_colon? unlabeled_statement) | ε ;
structType ::= (arrayType "packed"?) | (setType "packed"?) | (fileType "packed"?) | (recordType "packed"?) ;
stringType ::= "string" | "ansistring" | "widestring" | ("string" "[" expression "]") ;
begin ::= "begin" | "Begin" ;
type_or_string ::= type | charlit ;
var ::= "var" | "Var" ;
var_assignment ::= absolute_assignment | constant_assignment ;
method_heading ::= procedure_heading | function_heading | destructor_heading | constructor_heading ;
simple_statement ::= (ref_name assign_expression?) | ("inherited" ref_name?) | ("goto" labelId) ;
op ::= ">" | "<" | "<=" | ">=" | "<>" | "=" | "in" | "is" | "+" | "-" | "or" | "xor" | "*" | "/" | "div" | "mod" | "and" | "shl" | "shr" | "DIV" | "AND" ;
predefinedType ::= "integer" | "real" | "boolean" | "char" | "byte" ;
declaration_section ::= label_declaration_section | constant_section | type_section | var_section | procedure_section ;
property_specifiers ::= index_expession | read_id | write_id | stored_id_OR_stored_expression | default_expression_OR_nodefault | implementsTypeId ;
variantType ::= "variant" | "olevariant" ;
constant_declaration ::= (decl_name "=" expression ";" NL) | (decl_name ":" typeId "=" typed_constant ";" NL) ;
exception_block ::= ε | statement_list | exception_else ;
if ::= "if" | "If" ;
bool_value ::= "true" | "false" | "True" | "False" ;
except ::= "except" | "Except" ;
typed_constant ::= expression | array_constant | record_constant ;
expression ::= (factor op_factor*) | (op_factor+) ;
object_modifier ::= ("." id) | array_subscript | arguments | "^" | as_type ;
exported_heading ::= (procedure_heading ";" NL) | (function_heading ";" NL) | (constructor_heading ";" NL) | (destructor_heading ";" NL) ;
loop_statement ::= repeating_statement | while_statement | for_statement ;
procedure ::= "procedure" | "Procedure" ;
function_word ::= "function" | "Function" ;
id_or_expression ::= ref_name | expression ;
directive ::= "cdecl" | "register" | "dynamic" | "virtual" | "export" | "external" | "far" | "forward" | ("message" ref_name?) | "override" | "overload" | "pascal" | "reintroduce" | "safecall" | "stdcall" | "Override" ;
factor ::= ref_name | charlit | (pond_number+) | ("@" "@"? ref_name) | "nil" | ("(" expression ")") | (not_word factor) | set_constructor | (predefinedType "(" expression ")") | bool_value | ("-"? number) ;
default_expression_OR_nodefault ::= ("default" expression) | "nodefault" ;
simpleType ::= ordinalType | realType ;
type_or_restrictedType ::= (type ";" NL) | (restrictedType ";" NL) ;
do ::= "do" | "Do" | "DO" ;
ordinalType ::= subrangeType | enumeratedType | ordinal_identifier ;
unlabeled_statement ::= simple_statement | struct_statement ;
for ::= "for" | "For" ;
rel_op ::= ">" | "<" | "<=" | ">=" | "<>" | "=" | "in" | "is" ;
struct_statement ::= compound_statement | conditional_statement | loop_statement | with_statement | try_finally_statement | try_except_statement | raise_statement ;
program ::= program_definition | package_definition | library_definition | unit_definition ;
parm_qual ::= var | "const" | "out" ;
--------------------uml::collab.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::extended.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::fragment.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::oocm.bgf--------------------
Boolean ::= "true" | "false" ;
ScopeKind ::= (sk_instance_level::ε) | (sk_classifier_level::ε) ;
VisibilityKind ::= (vk_public_vis::ε) | (vk_private_vis::ε) | (vk_protected_vis::ε) ;
--------------------uml::reuse.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::statecharts.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::stereo.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::uml-uc.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------uml::uml2.bgf--------------------
ParameterEffectKind ::= (update::ε) | (read::ε) | (delete::ε) | (create::ε) ;
MessageKind ::= (found::ε) | (lost::ε) | (unknown::ε) | (complete::ε) ;
ParameterDirectionKind ::= (in::ε) | (inout::ε) | (out::ε) | (return::ε) ;
ObjectNodeOrderingKind ::= (FIFO::ε) | (unordered::ε) | (ordered::ε) | (LIFO::ε) ;
TransitionKind ::= (internal::ε) | (local::ε) | (external::ε) ;
CallConcurrencyKind ::= (guarded::ε) | (concurrent::ε) | (sequential::ε) ;
Boolean ::= "true" | "false" ;
PseudostateKind ::= (deepHistory::ε) | (shallowHistory::ε) | (choice::ε) | (join::ε) | (exitPoint::ε) | (terminate::ε) | (fork::ε) | (junction::ε) | (initial::ε) | (entryPoint::ε) ;
InteractionOperator ::= (consider::ε) | (par::ε) | (opt::ε) | (loop::ε) | (alt::ε) | (break::ε) | (assert::ε) | (strict::ε) | (seq::ε) | (ignore::ε) | (neg::ε) | (critical::ε) ;
AggregationKind ::= (composite::ε) | (none::ε) | (shared::ε) ;
VisibilityKind ::= (package::ε) | (private::ε) | (protected::ε) | (public::ε) ;
MessageSort ::= (synchSignal::ε) | (synchCall::ε) | (asynchCall::ε) | (asynchSignal::ε) ;
ExpansionKind ::= (parallel::ε) | (iterative::ε) | (stream::ε) ;
ConnectorKind ::= (delegation::ε) | (assembly::ε) ;
--------------------uml::umldi-2.0.bgf--------------------
ChangeableKind ::= (ck_changeable::ε) | (ck_frozen::ε) | (ck_addOnly::ε) ;
ParameterDirectionKind ::= (pdk_in::ε) | (pdk_inout::ε) | (pdk_out::ε) | (pdk_return::ε) ;
CallConcurrencyKind ::= (cck_sequential::ε) | (cck_guarded::ε) | (cck_concurrent::ε) ;
ScopeKind ::= (sk_instance::ε) | (sk_classifier::ε) ;
OrderingKind ::= (ok_unordered::ε) | (ok_ordered::ε) ;
Boolean ::= "true" | "false" ;
PseudostateKind ::= (pk_choice::ε) | (pk_deepHistory::ε) | (pk_fork::ε) | (pk_initial::ε) | (pk_join::ε) | (pk_junction::ε) | (pk_shallowHistory::ε) ;
VisibilityKind ::= (vk_public::ε) | (vk_protected::ε) | (vk_private::ε) | (vk_package::ε) ;
AggregationKind ::= (ak_none::ε) | (ak_aggregate::ε) | (ak_composite::ε) ;
--------------------uml::umldi-ag.bgf--------------------
ChangeableKind ::= (ck_changeable::ε) | (ck_frozen::ε) | (ck_addOnly::ε) ;
ParameterDirectionKind ::= (pdk_in::ε) | (pdk_inout::ε) | (pdk_out::ε) | (pdk_return::ε) ;
CallConcurrencyKind ::= (cck_sequential::ε) | (cck_guarded::ε) | (cck_concurrent::ε) ;
Boolean ::= "true" | "false" ;
ScopeKind ::= (sk_instance::ε) | (sk_classifier::ε) ;
OrderingKind ::= (ok_unordered::ε) | (ok_ordered::ε) ;
PseudostateKind ::= (pk_choice::ε) | (pk_deepHistory::ε) | (pk_fork::ε) | (pk_initial::ε) | (pk_join::ε) | (pk_junction::ε) | (pk_shallowHistory::ε) ;
VisibilityKind ::= (vk_public::ε) | (vk_protected::ε) | (vk_private::ε) | (vk_package::ε) ;
AggregationKind ::= (ak_none::ε) | (ak_aggregate::ε) | (ak_composite::ε) ;
--------------------uml::umldi-c.bgf--------------------
ChangeableKind ::= (ck_changeable::ε) | (ck_frozen::ε) | (ck_addOnly::ε) ;
ParameterDirectionKind ::= (pdk_in::ε) | (pdk_inout::ε) | (pdk_out::ε) | (pdk_return::ε) ;
CallConcurrencyKind ::= (cck_sequential::ε) | (cck_guarded::ε) | (cck_concurrent::ε) ;
ScopeKind ::= (sk_instance::ε) | (sk_classifier::ε) ;
OrderingKind ::= (ok_unordered::ε) | (ok_ordered::ε) ;
Boolean ::= "true" | "false" ;
VisibilityKind ::= (vk_public::ε) | (vk_protected::ε) | (vk_private::ε) | (vk_package::ε) ;
AggregationKind ::= (ak_none::ε) | (ak_aggregate::ε) | (ak_composite::ε) ;
--------------------uml::umldi-mm.bgf--------------------
ScopeKind ::= (sk_instance::ε) | (sk_classifier::ε) ;
Boolean ::= "true" | "false" ;
VisibilityKind ::= (vk_public::ε) | (vk_protected::ε) | (vk_private::ε) | (vk_package::ε) ;
--------------------uml::umldi-sm.bgf--------------------
ParameterDirectionKind ::= (pdk_in::ε) | (pdk_inout::ε) | (pdk_out::ε) | (pdk_return::ε) ;
CallConcurrencyKind ::= (cck_sequential::ε) | (cck_guarded::ε) | (cck_concurrent::ε) ;
Boolean ::= "true" | "false" ;
ScopeKind ::= (sk_instance::ε) | (sk_classifier::ε) ;
PseudostateKind ::= (pk_choice::ε) | (pk_deepHistory::ε) | (pk_fork::ε) | (pk_initial::ε) | (pk_join::ε) | (pk_junction::ε) | (pk_shallowHistory::ε) ;
VisibilityKind ::= (vk_public::ε) | (vk_protected::ε) | (vk_private::ε) | (vk_package::ε) ;
--------------------uml::umldi-uc.bgf--------------------
ChangeableKind ::= (ck_changeable::ε) | (ck_frozen::ε) | (ck_addOnly::ε) ;
Boolean ::= "true" | "false" ;
ScopeKind ::= (sk_instance::ε) | (sk_classifier::ε) ;
OrderingKind ::= (ok_unordered::ε) | (ok_ordered::ε) ;
VisibilityKind ::= (vk_public::ε) | (vk_protected::ε) | (vk_private::ε) | (vk_package::ε) ;
AggregationKind ::= (ak_none::ε) | (ak_aggregate::ε) | (ak_composite::ε) ;
--------------------uml::yuml.bgf--------------------
AssociationType ::= (simpleAssociation::ε) | (aggregation::ε) | (composition::ε) ;
Boolean ::= "true" | "false" ;
Visibility ::= (unspecified::ε) | (public::ε) | (private::ε) | (protected::ε) | (package::ε) ;
--------------------xml::rosendal.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------xml::rascal.bgf--------------------
Namespace ::= (namespace::(prefix::string() uri::string())) | (none::ε) ;
Node ::= (document::(root::Node)) | (attribute::(namespace::Namespace name::string() text::string())) | (element::(namespace::Namespace name::string() children::(Node*))) | (charData::(text::string())) | (cdata::(text::string())) | (comment::(text::string())) | (pi::(target::string() text::string())) | (entityRef::(name::string())) | (charRef::(code::integer())) ;
--------------------xml::zhang-cordy.bgf--------------------
element ::= (empty_elem_tag spaces) | (tag_content spaces) ;
atttype ::= stringtype | tokenizedtype | enumeratedtype ;
mixed ::= pcdata_or_name | pcdata ;
enumeratedtype ::= notationtype | enumeration ;
nmtoken ::= name | dname ;
cp_body ::= name | choice | seq ;
contentspec ::= "EMPTY" | "ANY" | mixed | children ;
markupdecl ::= elementdecl | attlistdecl | entitydecl | notationdecl | pi | comment ;
space_or_newline ::= space | newline ;
repetition ::= "?" | "*" | "+" ;
pedef ::= entityvalue | external_id ;
attvalue ::= stringlit | charlit | longstringlit | longcharlit ;
external_id ::= exid_sys | exid_pub ;
literal ::= charlit | stringlit ;
entityvalue ::= charlit | stringlit | longstringlit | longcharlit ;
cdata ::= token | comment ;
exid_or_pubid ::= external_id | ("PUBLIC" spaces literal) ;
entitydecl ::= gedecl | pedecl ;
sub2_content ::= element | reference | cdsect | pi | comment | regexp ;
misc ::= comment | pi | space | newline ;
reference ::= ("&" name ";") | charref ;
defaultdecl ::= "#REQUIRED" | "#IMPLIED" | (fixed? attvalue) ;
decl ::= markupdecl | ("%" name ";") | spaces ;
tokenizedtype ::= "ID" | "IDREF" | "IDREFS" | "ENTITY" | "ENTITIES" | "NMTOKEN" | "NMTOKENS" ;
entitydef ::= entityvalue | (external_id ndatadecl?) ;
children_body ::= choice | seq ;
--------------------xquery::rosendal.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------xslt::clark.bgf--------------------
instruction.category ::= apply-templates.element | apply-imports.element | call-template.element | element.element | attribute.element | text.element | processing-instruction.element | comment.element | copy.element | value-of.element | number.element | for-each.element | if.element | choose.element | variable.element | copy-of.element | message.element | fallback.element ;
top-level-element.category ::= include.element | strip-space.element | preserve-space.element | template.element | namespace-alias.element | attribute-set.element | variable.element | param.element | key.element | decimal-format.element | output.element ;
prefix.datatype ::= string() | "#default" ;
--------------------xslt::rosendal.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------logo::sdf.bgf--------------------
Exp ::= Integer | Formal | "xcor" | "ycor" | "heading" | ("towards" Exp Exp) | "pendown?" | ("sum" Exp Exp) | ("difference" Exp Exp) | ("product" Exp Exp) | ("quotient" Exp Exp) | ("remainder" Exp Exp) | ("minus" Exp) | ("less?" Exp Exp) | ("greater?" Exp Exp) | ("equal?" Exp Exp) | ("notequal?" Exp Exp) ;
BasicCommand ::= ("if" Exp Block) | ("ifelse" Exp Block Block) | ("repeat" Exp Block) | ("forward" Exp) | ("back" Exp) | ("left" Exp) | ("right" Exp) | ("setxy" Exp Exp) | ("setx" Exp) | ("sety" Exp) | "home" | "showturtle" | "hideturtle" | "clean" | "clearscreen" | "pendown" | "penup" | ("pencolor" Color) | ("local" QuotedId) | ("make" QuotedId Exp) ;
Id ::= "xcor" | "ycor" | "heading" | "towards" | "pendown?" | "sum" | "difference" | "product" | "quotient" | "remainder" | "minus" | "less?" | "greater?" | "equal?" | "notequal?" | "to" | "if" | "ifelse" | "repeat" | "forward" | "back" | "left" | "right" | "setxy" | "setx" | "sety" | "home" | "showturtle" | "hideturtle" | "clean" | "clearscreen" | "pendown" | "penup" | "local" | "make" ;
Command ::= BasicCommand | FunctionDef | Call ;
--------------------php::cordy.bgf--------------------
VarModifier ::= "public" | "protected" | "private" | "static" | "final" ;
ForEachVar ::= CVar | ("&" CVar) ;
SwitchStatement ::= ("switch" "(" Expr ")" NL "{" ";"? NL IN Case* EX "}" NL) | ("switch" "(" Expr ")" ":" ";"? NL IN Case* EX "endswitch" ";" NL) ;
Document ::= (PHPOpenTag? PHPSection PHPCloseTagDocumentSection?) | (HTMLSection PHPOpenTagPHPSection? PHPCloseTagDocumentSection?) ;
TopStatement ::= FunctionDecl | ClassDecl | Statement | InterfaceDecl ;
PHPCloseTag ::= ("?>" NL) | ("%>" NL) ;
CastType ::= "int" | "integer" | "bool" | "boolean" | "real" | "double" | "float" | "string" | "array" | "object" | "unset" ;
ArrayValue ::= Expr | ("&" ObjectCVar) ;
PHPOpenTag ::= ("<?php" NL) | ("<?" NL) | ("<%" NL) | ("<?=" NL) ;
StringConstant ::= stringlit | charlit | CommandString | ("<<<" id IN NL EncapsedInlineHTML* id EX) ;
CaseSeparator ::= ";" | ":" ;
IfStatement ::= ("if" "(" Expr ")" NL Statement ElseIfStatement* ElseStatement?) | ("if" "(" Expr ")" ":" NL IN TopStatement* EX AltElseifStatement* AltElseStatement? "endif" ";" NL) ;
ControlStatement ::= ("break" Expr? ";" NL) | ("continue" Expr? ";" NL) | ("return" Expr? ";" NL) ;
ClassType ::= "class" | ("abstract" "class") | ("final" "class") ;
NumericConstant ::= number | Hexa | Octa ;
ListElem ::= List | ObjectCVar | ε ;
Param ::= (TypeHint? "&"? TVariable EqualsStaticScalar?) | ("const" TVariable) ;
id_or_key ::= (id "-"? id?) | key ;
IncDec ::= "++" | "--" ;
ShiftOp ::= "<<" | ">>" ;
Primary ::= VariableOrFunctionCall | ScalarConstant | Array | List | InternalFunction | ("(" Expr ")") ;
bigtag_id ::= "html" | "body" | "head" | "form" | "table" | "tr" | "td" | "script" | "select" | "label" | "div" ;
GlobalStaticStatement ::= ("global" {CVar ","}+ ";" NL) | ("static" {StaticVariable ","}+ ";" NL) ;
WhileStatement ::= ("while" "(" Expr ")" NL Statement) | ("while" "(" Expr ")" ":" NL IN TopStatement* EX "endwhile" ";" NL) ;
EqualityOp ::= "==" | "!=" | "===" | "!==" ;
tag ::= ("<" SPOFF bigtag_id tag_attribute* ">" SPON IN NL) | (EX FL "<" SPOFF "/" bigtag_id ">" SPON FL) | ("<" SPOFF "!"? id_or_key tag_attribute* ">" SPON NL) | ("<" SPOFF "/" id_or_key ">" SPON NL) | ("<" SPOFF id_or_key tag_attribute* "/>" SPON NL) ;
SimpleVariableName ::= id | ("$" SPOFF IdOrKey SPON) ;
PlusMinus ::= "+" | "-" ;
InternalFunction ::= ("new" Primary) | ("clone" Primary) | ("isset" "(" {ObjectCVar ","}+ ")") | ("empty" "(" ObjectCVar ")") | ("intval" "(" ObjectCVar ")") | ("eval" "(" Expr ")") | ("exit" exit_value?) | ("include" Expr) | ("include_once" Expr) | ("require" Expr) | ("require_once" Expr) ;
ObjectProperty ::= VariableName | IdOrKey | (ObjectProperty VariableExtension) | ObjectCVar ;
ClassMember ::= (VarModifiers? FunctionDecl) | (VarModifiers? "abstract" VarModifiers? "function" "&"? id "(" {Param ","}* ")" ";" NL) | ("var" {InstanceVariable ","}+ ";" NL) | ("const" id "=" StaticScalar ";" NL) | (VarModifiers {InstanceVariable ","}+ ";" NL) ;
MultOp ::= "*" | "/" | "%" ;
ScalarConstant ::= (PlusMinus? NumericConstant) | StringConstant | MagicConstant | BooleanConstant | "null" ;
UnaryOp ::= "~" | "-" | "@" | ("(" CastType ")") | ("@" "!") ;
AssignOp ::= ".=" | "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "=&" ;
Case ::= ("case" Expr CaseSeparator NL IN TopStatement* EX) | ("default" CaseSeparator NL IN TopStatement* EX) ;
Statement ::= ExprStatement | BlockStatement | IfStatement | WhileStatement | DoStatement | ForStatement | SwitchStatement | ControlStatement | GlobalStaticStatement | UnsetStatement | EchoStatement | PrintStatement | InlineHTMLStatement | ForEachStatement | NullStatement | DeclareStatement | TryStatement | ThrowStatement ;
tag_token_or_key ::= tag | (";" NL) | token | key ;
BooleanConstant ::= "true" | "false" ;
token_or_key ::= token | key ;
VariableName ::= SimpleVariableName | ("$" VariableName) | ("{" SimpleVariableName "}") | ("{" Expr "}") ;
ForStatement ::= ("for" "(" {Expr ","}* ";" {Expr ","}* ";" {Expr ","}* ")" NL Statement) | ("for" "(" {Expr ","}* ";" {Expr ","}* ";" {Expr ","}* ")" ":" NL IN Statement* EX "endfor" ";" NL) ;
ForEachStatement ::= ("foreach" "(" Expr "as" ForEachPattern ")" NL Statement) | ("foreach" "(" Expr "as" ForEachPattern ")" ":" NL IN Statement* EX "endforeach" ";" NL) ;
VariableExtension ::= ("[" Expr? "]") | ("{" Expr "}") ;
AddOp ::= "+" | "-" ;
IdOrKey ::= id | key ;
InequalityOp ::= "<>" | "<" | "<=" | ">" | ">=" ;
--------------------python::indent-cordy.bgf--------------------
compoundtoken ::= linetoken | newline | comment ;
tab_space ::= tab | space ;
compoundtokensquare ::= linetoken | newline | comment ;
compound ::= ("{" compoundtoken* "}") | ("[" compoundtokensquare* "]") | ("(" compoundtokenround* ")") ;
linetoken ::= tab_space | nonblank_token ;
nonblank_token ::= compound | token ;
compoundtokenround ::= linetoken | newline | comment ;
--------------------python::sorochan-cordy.bgf--------------------
integer ::= integernumber | hexinteger | octinteger ;
stringliteral ::= (stringprefix SPOFF string SPON) | string ;
shift_op ::= "<<" | ">>" ;
long ::= (SPOFF "l" SPON) | (SPOFF "L" SPON) ;
fpdef ::= (id endofline?) | (SPOFF "(" SPON fplist endofline* ")" endofline?) ;
testplist_gexp ::= (test+ endofline? ","?) | (test endofline? gen_for) ;
flow_stmt ::= break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt ;
suite ::= (indent endofline stmt_or_newline+ dedent) | (simple_stmt endofline) ;
decorated ::= (decorators classdef) | (decorators funcdef) ;
simple_stmt ::= (small_stmt semicolon_small_stmt* ";"?) | comment ;
arith_op ::= "+" | "-" ;
trailer ::= (SPOFF "(" SPON IN arglist endofline* ")" EX) | ("[" IN subscriptlist "]" EX) | (endofline* "." endofline* id) ;
unary_op ::= "+" | "-" | "~" ;
literal ::= (stringliteral more_stringliteral*) | integerliteral | floatliteral ;
argument_value ::= (endofline* gen_for?) | ("=" endofline* test) ;
old_test ::= or_test | old_lambdef ;
plist_iter ::= (endofline* plist_for) | (endofline* plist_if) ;
gen_iter ::= (endofline* gen_for) | (endofline* gen_if) ;
listmaker ::= (endofline* test endofline* plist_for endofline*) | (endofline* {test ","}* ","? endofline*) ;
import_items ::= "*" | (endofline* SPOFF "(" SPON import_as_names endofline* ")") | (endofline* import_as_names) ;
stringprefix ::= "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR" | "b" ;
augassign ::= "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "**=" | "//=" ;
import_stmt ::= import_name | import_from ;
varargslist ::= (fpdef_test_comma* endofline* "*" id) | (fpdef_test_comma* endofline* "*" id endofline? "," endofline* "**" id) | (fpdef_test_comma* endofline* "**" id) | (fpdef_test+ ","?) ;
assign_value ::= yield_expr | testlist ;
star_test ::= (endofline* "*" test) | (endofline* "**" test) ;
compound_stmt ::= if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated ;
term_op ::= "*" | "/" | "%" | "//" ;
floatliteral ::= (number imag?) | (pointfloat imag?) ;
test ::= (endofline* or_test if_test? endofline?) | (endofline* lambdef endofline?) ;
expr_stmt ::= (testlist is_expr*) | (testlist augassign assign_value) ;
string ::= stringlit | charlit | longstringlit | longcharlit ;
atom ::= id | literal | ("(" IN endofline* yield_expr? endofline* ")" EX) | ("(" IN endofline* testplist_gexp endofline* ")" EX) | ("[" IN endofline* listmaker? "]" EX) | ("{" IN endofline* dictmaker? endofline* "}" EX) | ("`" testlist1 "`") ;
comp_op ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!=" | "in" | ("not" "in") | "is" | ("is" "not") ;
stmt_or_newline ::= stmt | endofline ;
classdef ::= ("class" id? ":" suite) | ("class" id? SPOFF "(" SPON testlist? endofline* ")" ":" suite) ;
subscript ::= (endofline* "." "." "." endofline?) | (endofline* test endofline?) | (endofline* test? ":" test? sliceop? endofline?) ;
as_or_comma_test ::= ("as" test) | ("," test) ;
imag ::= (SPOFF "j" SPON) | (SPOFF "J" SPON) ;
stmt ::= (simple_stmt endofline) | compound_stmt ;
small_stmt ::= expr_stmt | print_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | exec_stmt | assert_stmt ;
--------------------markup::cml.bgf--------------------
AngleUnits ::= (degrees::ε) | (radians::ε) ;
Coordinate3Builtin ::= (xyz3::ε) | (xyzFract::ε) ;
Boolean ::= "true" | "false" ;
FloatBuiltin ::= (x2::ε) | (y2::ε) | (x3::ε) | (y3::ε) | (z3::ε) | (xFract::ε) | (yFract::ε) | (zFract::ε) | (occupancy::ε) | (isotope::ε) | (formalCharge::ε) | (hydrogenCount::ε) | (nonHydrogenCount::ε) | (atomParity::ε) | (length::ε) | (acell::ε) | (bcell::ε) | (ccell::ε) | (alpha::ε) | (beta::ε) | (gamma::ε) | (z::ε) ;
IntegerBuiltin ::= (isotope::ε) | (formalCharge::ε) | (hydrogenCount::ε) | (nonHydrogenCount::ε) | (atomParity::ε) | (z::ε) ;
StringBuiltin ::= (id::ε) | (elementType::ε) | (atomId::ε) | (residueType::ε) | (residueId::ε) | (atomRef::ε) | (order::ε) | (stereo::ε) | (spaceground::ε) ;
--------------------markup::csv-rascal-abstract.bgf--------------------
Field ::= (unquoted::(text::string())) | (quoted::(text::string())) ;
--------------------markup::ebxml.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------markup::docbook-walsh.bgf--------------------
legalnotice.mix ::= list.class | admon.class | linespecific.class | para.class | blockquote | ndxterm.class | beginpage | local.legalnotice.mix ;
bookcomponent.content ::= (divcomponent.mix+ (sect1*) | (refentry.class*) | (simplesect*) | (section.class*)) | (sect1+) | (refentry.class+) | (simplesect+) | (section.class+) ;
other.char.class ::= remark | subscript | superscript | local.other.char.class ;
gen.char.class ::= abbrev | acronym | citation | citerefentry | citetitle | emphasis | firstterm | foreignphrase | glossterm | footnote | phrase | quote | trademark | wordasword | personname | local.gen.char.class ;
divcomponent.mix ::= list.class | admon.class | linespecific.class | synop.class | para.class | informal.class | formal.class | compound.class | genobj.class | descobj.class | ndxterm.class | beginpage | forms.hook | local.divcomponent.mix ;
formal.class ::= equation | example | figure | table | local.formal.class ;
info.class ::= graphic | mediaobject | legalnotice | modespec | subjectset | keywordset | itermset | bibliocomponent.mix | local.info.class ;
listpreamble.mix ::= admon.class | linespecific.class | synop.class | para.class | informal.class | genobj.class | descobj.class | ndxterm.class | beginpage | local.listpreamble.mix ;
tech.char.class ::= action | application | classname | methodname | interfacename | exceptionname | ooclass | oointerface | ooexception | command | computeroutput | database | email | envar | errorcode | errorname | errortype | errortext | filename | function | guibutton | guiicon | guilabel | guimenu | guimenuitem | guisubmenu | hardware | interface | keycap | keycode | keycombo | keysym | literal | constant | markup | medialabel | menuchoice | mousebutton | option | optional | parameter | prompt | property | replaceable | returnvalue | sgmltag | structfield | structname | symbol | systemitem | token | type | userinput | varname | ebnf.inline.hook | local.tech.char.class ;
ndxterm.class ::= indexterm | local.ndxterm.class ;
refcomponent.mix ::= list.class | admon.class | linespecific.class | synop.class | para.class | informal.class | formal.class | compound.class | genobj.class | descobj.class | ndxterm.class | beginpage | local.refcomponent.mix ;
admon.mix ::= list.class | linespecific.class | synop.class | para.class | informal.class | formal.class | procedure | sidebar | anchor | bridgehead | remark | ndxterm.class | beginpage | local.admon.mix ;
compound.class ::= msgset | procedure | sidebar | qandaset | ebnf.block.hook | local.compound.class ;
book.class ::= book | local.book.class ;
synop.class ::= synopsis | cmdsynopsis | funcsynopsis | classsynopsis | fieldsynopsis | method.synop.class | local.synop.class ;
genobj.class ::= anchor | bridgehead | remark | highlights | local.genobj.class ;
linespecific.class ::= literallayout | programlisting | programlistingco | screen | screenco | screenshot | local.linespecific.class ;
section.class ::= section | local.section.class ;
highlights.mix ::= list.class | admon.class | para.class | ndxterm.class | local.highlights.mix ;
nav.class ::= toc | lot | index | glossary | bibliography | local.nav.class ;
tabentry.mix ::= list.class | admon.class | linespecific.class | para.class | graphic | mediaobject | local.tabentry.mix ;
component.mix ::= list.class | admon.class | linespecific.class | synop.class | para.class | informal.class | formal.class | compound.class | genobj.class | descobj.class | ndxterm.class | beginpage | local.component.mix ;
para.class ::= formalpara | para | simpara | local.para.class ;
glossdef.mix ::= list.class | linespecific.class | synop.class | para.class | informal.class | formal.class | remark | ndxterm.class | beginpage | local.glossdef.mix ;
word.char.mix ::= string() | acronym | emphasis | trademark | link.char.class | base.char.class | other.char.class | inlinegraphic | inlinemediaobject | ndxterm.class | beginpage | local.word.char.mix ;
docinfo.char.class ::= author | authorinitials | corpauthor | modespec | othercredit | productname | productnumber | revhistory | local.docinfo.char.class ;
list.class ::= calloutlist | glosslist | itemizedlist | orderedlist | segmentedlist | simplelist | variablelist | local.list.class ;
cptr.char.mix ::= string() | link.char.class | tech.char.class | base.char.class | other.char.class | inlinegraphic | inlinemediaobject | ndxterm.class | beginpage | local.cptr.char.mix ;
revdescription.mix ::= list.class | admon.class | linespecific.class | synop.class | para.class | informal.class | formal.class | procedure | genobj.class | ndxterm.class | local.revdescription.mix ;
method.synop.class ::= constructorsynopsis | destructorsynopsis | methodsynopsis | local.method.synop.class ;
informal.class ::= address | blockquote | graphic | graphicco | mediaobject | mediaobjectco | informalequation | informalexample | informalfigure | informaltable | local.informal.class ;
base.char.class ::= anchor | local.base.char.class ;
index.class ::= index | setindex | local.index.class ;
title.char.mix ::= string() | xref.char.class | gen.char.class | link.char.class | tech.char.class | base.char.class | docinfo.char.class | other.char.class | inlineobj.char.class | ndxterm.class | local.title.char.mix ;
textobject.mix ::= list.class | admon.class | linespecific.class | para.class | blockquote | local.textobject.mix ;
example.mix ::= list.class | linespecific.class | synop.class | para.class | informal.class | ndxterm.class | beginpage | local.example.mix ;
chapter.class ::= chapter | local.chapter.class ;
qandaset.mix ::= list.class | admon.class | linespecific.class | synop.class | para.class | informal.class | formal.class | procedure | genobj.class | ndxterm.class | local.qandaset.mix ;
bibliocomponent.mix ::= abbrev | abstract | address | artpagenums | author | authorgroup | authorinitials | bibliomisc | biblioset | collab | confgroup | contractnum | contractsponsor | copyright | corpauthor | corpname | date | edition | editor | invpartnumber | isbn | issn | issuenum | orgname | biblioid | citebiblioid | bibliosource | bibliorelation | bibliocoverage | othercredit | pagenums | printhistory | productname | productnumber | pubdate | publisher | publishername | pubsnumber | releaseinfo | revhistory | seriesvolnums | subtitle | title | titleabbrev | volumenum | citetitle | personname | person.ident.mix | ndxterm.class | local.bibliocomponent.mix ;
link.char.class ::= link | olink | ulink | local.link.char.class ;
partcontent.mix ::= appendix.class | chapter.class | nav.class | article.class | preface | refentry.class | reference | local.partcontent.mix ;
refname.char.mix ::= string() | tech.char.class | local.refname.char.mix ;
admon.class ::= caution | important | note | tip | warning | local.admon.class ;
xref.char.class ::= footnoteref | xref | local.xref.char.class ;
appendix.class ::= appendix | local.appendix.class ;
para.char.mix ::= string() | xref.char.class | gen.char.class | link.char.class | tech.char.class | base.char.class | docinfo.char.class | other.char.class | inlineobj.char.class | synop.class | ndxterm.class | beginpage | forminlines.hook | local.para.char.mix ;
figure.mix ::= linespecific.class | synop.class | informal.class | ndxterm.class | beginpage | local.figure.mix ;
mediaobject.mix ::= videoobject | audioobject | imageobject | textobject | local.mediaobject.mix ;
inlineobj.char.class ::= inlinegraphic | inlinemediaobject | inlineequation | local.inlineobj.char.class ;
descobj.class ::= abstract | authorblurb | epigraph | local.descobj.class ;
tbl.table-main.mdl ::= (tgroup+) | (graphic+) ;
para.mix ::= list.class | admon.class | linespecific.class | informal.class | formal.class | local.para.mix ;
footnote.mix ::= list.class | linespecific.class | synop.class | para.class | informal.class | local.footnote.mix ;
refclass.char.mix ::= string() | application | local.refclass.char.mix ;
docinfo.char.mix ::= string() | link.char.class | emphasis | trademark | replaceable | other.char.class | inlinegraphic | inlinemediaobject | ndxterm.class | local.docinfo.char.mix ;
notation.class ::= "BMP" | "CGM-CHAR" | "CGM-BINARY" | "CGM-CLEAR" | "DITROFF" | "DVI" | "EPS" | "EQN" | "FAX" | "GIF" | "GIF87a" | "GIF89a" | "JPG" | "JPEG" | "IGES" | "PCX" | "PIC" | "PNG" | "PS" | "SGML" | "TBL" | "TEX" | "TIFF" | "WMF" | "WPG" | "SVG" | "linespecific" | local.notation.class ;
indexdivcomponent.mix ::= itemizedlist | orderedlist | variablelist | simplelist | linespecific.class | synop.class | para.class | informal.class | anchor | remark | link.char.class | beginpage | local.indexdivcomponent.mix ;
sidebar.mix ::= list.class | admon.class | linespecific.class | synop.class | para.class | informal.class | formal.class | procedure | genobj.class | ndxterm.class | beginpage | local.sidebar.mix ;
tbl.entry.mdl ::= para.char.mix | tabentry.mix ;
refentry.class ::= refentry | local.refentry.class ;
refinline.char.mix ::= string() | xref.char.class | gen.char.class | link.char.class | tech.char.class | base.char.class | docinfo.char.class | other.char.class | ndxterm.class | beginpage | local.refinline.char.mix ;
person.ident.mix ::= honorific | firstname | surname | lineage | othername | affiliation | authorblurb | contrib | local.person.ident.mix ;
ndxterm.char.mix ::= string() | xref.char.class | gen.char.class | link.char.class | tech.char.class | base.char.class | docinfo.char.class | other.char.class | inlinegraphic | inlinemediaobject | local.ndxterm.char.mix ;
smallcptr.char.mix ::= string() | replaceable | inlinegraphic | inlinemediaobject | ndxterm.class | beginpage | local.smallcptr.char.mix ;
article.class ::= article | local.article.class ;
--------------------markup::kml.bgf--------------------
AltitudeModeValue ::= (clampedToGround::ε) | (relativeToGround::ε) | (absolute::ε) ;
ColorModeValue ::= (normal::ε) | (random::ε) ;
Boolean ::= "true" | "false" ;
--------------------markup::graphml-doux.bgf--------------------
AttrType ::= (double::ε) | (string::ε) | (integer::ε) | (boolean::ε) ;
ElemType ::= (edge::ε) | (node::ε) | (graph::ε) ;
Boolean ::= "true" | "false" ;
EdgeType ::= (directed::ε) | (undirected::ε) ;
--------------------markup::json-rascal-abstract.bgf--------------------
Value ::= (null::ε) | (object::(members::((memberName::string() memberValue::Value)*))) | (array::(values::(Value*))) | (integer::(n::integer())) | (float::(r::integer())) | (string::(s::string())) | (boolean::(b::("true" | "false"))) ;
--------------------markup::json-zaytsev-abstract.bgf--------------------
JSO ::= (jsnumber::(n::integer())) | (jsstring::(s::string())) | (jsboolean::(b::("true" | "false"))) | (jsarray::(xs::(JSO*))) | (jsobject::(kvs::((JSO JSO)*))) | (jsnull::ε) ;
--------------------markup::mathml-furubayashi.bgf--------------------
mml.plschema ::= mml.pgenschema | mml.pscrschema | mml.ptabschema ;
mml.ctrigop ::= mml.sin.qname | mml.cos.qname | mml.tan.qname | mml.sec.qname | mml.csc.qname | mml.cot.qname | mml.sinh.qname | mml.cosh.qname | mml.tanh.qname | mml.sech.qname | mml.csch.qname | mml.coth.qname | mml.arcsin.qname | mml.arccos.qname | mml.arctan.qname | mml.arccosh.qname | mml.arccot.qname | mml.arccoth.qname | mml.arccsc.qname | mml.arccsch.qname | mml.arcsec.qname | mml.arcsech.qname | mml.arcsinh.qname | mml.arctanh.qname ;
mml.cfuncop1ary ::= mml.inverse.qname | mml.ident.qname | mml.domain.qname | mml.codomain.qname | mml.image.qname ;
mml.cop1ary ::= mml.cfuncop1ary | mml.carithop1ary | mml.clogicop1ary | mml.ccalcop1ary | mml.ctrigop | mml.clalgop1ary | mml.csetop1ary ;
mml.c0ary ::= mml.integers.qname | mml.reals.qname | mml.rationals.qname | mml.naturalnumbers.qname | mml.complexes.qname | mml.primes.qname | mml.exponentiale.qname | mml.imaginaryi.qname | mml.notanumber.qname | mml.true.qname | mml.false.qname | mml.emptyset.qname | mml.eulergamma.qname | mml.infinity.qname ;
mml.peschema ::= mml.maligngroup.qname | mml.malignmark.qname ;
mml.cquantifier ::= mml.lowlimit.qname | mml.uplimit.qname | mml.bvar.qname | mml.degree.qname | mml.logbase.qname | mml.momentabout.qname | mml.domainofapplication.qname ;
mml.ccalcop ::= mml.log.qname | mml.int.qname | mml.diff.qname | mml.partialdiff.qname | mml.divergence.qname | mml.grad.qname | mml.curl.qname | mml.laplacian.qname ;
mml.Content ::= mml.ctoken | mml.cspecial | mml.cother | mml.csemantics | mml.c0ary | mml.cconstructor | mml.cquantifier | mml.cop1ary | mml.cop2ary | mml.copnary | mml.copmisc | mml.crel2ary | mml.crelnary ;
mml.pscrschema ::= mml.msub.qname | mml.msup.qname | mml.msubsup.qname | mml.munder.qname | mml.mover.qname | mml.munderover.qname | mml.mmultiscripts.qname ;
mml.MathMLCharacters ::= mml.mglyph.qname | string() ;
mml.pscreschema ::= mml.mprescripts.qname | mml.none.qname ;
mml.crelnary ::= mml.cgenrelnary | mml.csetrelnary ;
mml.csetrelnary ::= mml.subset.qname | mml.prsubset.qname ;
mml.color.datatype ::= string() | string() | "transparent" ;
mml.cstatopnary ::= mml.mean.qname | mml.sdev.qname | mml.variance.qname | mml.median.qname | mml.mode.qname ;
mml.cother ::= mml.condition.qname | mml.declare.qname | mml.sep.qname ;
mml.csetrel2ary ::= mml.in.qname | mml.notin.qname | mml.notsubset.qname | mml.notprsubset.qname ;
mml.crel2ary ::= mml.cgenrel2ary | mml.csetrel2ary | mml.cseqrel2ary ;
mml.ptoken ::= mml.mi.qname | mml.mn.qname | mml.mo.qname | mml.mtext.qname | mml.ms.qname ;
mml.clalgop1ary ::= mml.determinant.qname | mml.transpose.qname ;
mml.ptabschema ::= mml.mtable.qname | mml.mtr.qname | mml.mlabeledtr.qname | mml.mtd.qname ;
mml.clogicopquant ::= mml.exists.qname | mml.forall.qname ;
mml.pgenschema ::= mml.mrow.qname | mml.mfrac.qname | mml.msqrt.qname | mml.mroot.qname | mml.menclose.qname | mml.mstyle.qname | mml.merror.qname | mml.mpadded.qname | mml.mphantom.qname | mml.mfenced.qname ;
mml.namedspace.datatype ::= string() | "veryverythinmathspace" | "verythinmathspace" | "thinmathspace" | "mediummathspace" | "thickmathspace" | "verythickmathspace" | "veryverythickmathspace" ;
mml.carithop1ary ::= mml.abs.qname | mml.conjugate.qname | mml.exp.qname | mml.factorial.qname | mml.arg.qname | mml.real.qname | mml.imaginary.qname | mml.floor.qname | mml.ceiling.qname ;
mml.cfuncopnary ::= mml.fn.qname | mml.compose.qname ;
mml.cseqop ::= mml.sum.qname | mml.product.qname | mml.limit.qname ;
mml.Presentation ::= mml.ptoken | mml.petoken | mml.pscreschema | mml.plschema | mml.peschema | mml.pactions ;
mml.copnary ::= mml.cfuncopnary | mml.carithopnary | mml.clogicopnary | mml.csetopnary | mml.cstatopnary | mml.clalgopnary ;
mml.csetopnary ::= mml.union.qname | mml.intersect.qname | mml.cartesianproduct.qname ;
mml.cconstructor ::= mml.interval.qname | mml.list.qname | mml.matrix.qname | mml.matrixrow.qname | mml.set.qname | mml.vector.qname | mml.piecewise.qname ;
mml.cspecial ::= mml.apply.qname | mml.reln.qname | mml.lambda.qname ;
mml.cop2ary ::= mml.carithop2ary | mml.clogicop2ary | mml.clalgop2ary | mml.csetop2ary ;
mml.clogicopnary ::= mml.and.qname | mml.or.qname | mml.xor.qname ;
mml.ctoken ::= mml.csymbol.qname | mml.ci.qname | mml.cn.qname ;
mml.copmisc ::= mml.carithoproot | mml.carithop1or2ary | mml.ccalcop | mml.cseqop | mml.cstatopmoment | mml.clogicopquant ;
mml.csemantics ::= mml.semantics.qname | mml.annotation.qname | mml.annotation-xml.qname ;
mml.PresInCont ::= mml.ptoken | mml.petoken | mml.plschema | mml.peschema | mml.pactions ;
mml.ContInPres ::= mml.ci.qname | mml.csymbol.qname | mml.cn.qname | mml.c0ary | mml.apply.qname | mml.fn.qname | mml.lambda.qname | mml.reln.qname | mml.cconstructor | mml.semantics.qname | mml.declare.qname ;
mml.clalgop2ary ::= mml.vectorproduct.qname | mml.scalarproduct.qname | mml.outerproduct.qname ;
mml.carithopnary ::= mml.plus.qname | mml.times.qname | mml.max.qname | mml.min.qname | mml.gcd.qname | mml.lcm.qname ;
mml.cgenrelnary ::= mml.eq.qname | mml.leq.qname | mml.lt.qname | mml.geq.qname | mml.gt.qname | mml.equivalent.qname | mml.approx.qname ;
mml.carithop2ary ::= mml.quotient.qname | mml.divide.qname | mml.power.qname | mml.rem.qname ;
mml.cgenrel2ary ::= mml.neq.qname | mml.factorof.qname ;
--------------------markup::pnml-booleans.bgf--------------------
BooleanOperator ::= And | Or | Imply | Not ;
Operator ::= Equality | Inequality ;
--------------------markup::pnml-cyclicenumerations.bgf--------------------
CyclicEnumOperator ::= Successor | Predecessor ;
--------------------markup::r2ml.bgf--------------------
CollectionTypes ::= (individual::ε) | (set::ε) | (orderedSet::ε) | (bag::ε) | (sequence::ε) ;
ExternalVocabularyLanguage ::= (RDFS::ε) | (UML::ε) | (OWL::ε) ;
Boolean ::= "true" | "false" ;
PredicateCategory ::= (closed::ε) | (open::ε) | (partial::ε) ;
PredicateType ::= (ObjectClassificationPredicate::ε) | (AttributionPredicate::ε) | (AssociationPredicate::ε) | (ReferencePropertyPredicate::ε) | (EqualityPredicate::ε) | (InequalityPredicate::ε) | (DatatypePredicate::ε) | (DataClassificationPredicate::ε) ;
--------------------markup::pnml-ext-inhibitor.bgf--------------------
specialarc.value ::= "normal" | "inhibitor" | "read" | "reset" ;
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
--------------------markup::pnml-ext-reset.bgf--------------------
specialarc.value ::= "normal" | "inhibitor" | "read" | "reset" ;
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
--------------------markup::pnml-ext-resetinhibitor.bgf--------------------
specialarc.value ::= "normal" | "inhibitor" | "read" | "reset" ;
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
--------------------markup::pnml-ext-specialarcs.bgf--------------------
specialarc.value ::= "normal" | "inhibitor" | "read" | "reset" ;
--------------------markup::pnml-finiteintranges.bgf--------------------
FiniteIntRangeOperator ::= FIRLessThan | FIRLessThanOrEqual | FIRGreaterThan | FIRGreaterThanOrEqual ;
--------------------markup::pnml-guyard-basic.bgf--------------------
AlignType ::= (atleft::ε) | (atcenter::ε) | (atright::ε) ;
StyleType ::= (sttsolid::ε) | (sttdash::ε) | (sttdot::ε) ;
ShapeType ::= (shtline::ε) | (shtcurve::ε) ;
DecorationType ::= (dtunderligne::ε) | (dtoverligne::ε) | (dtlinethrough::ε) ;
RotationType ::= (rtvertical::ε) | (rthorizontal::ε) | (rtdiagonal::ε) ;
--------------------markup::pnml-guyard-modular.bgf--------------------
AlignType ::= (atleft::ε) | (atcenter::ε) | (atright::ε) ;
StyleType ::= (sttsolid::ε) | (sttdash::ε) | (sttdot::ε) ;
ShapeType ::= (shtline::ε) | (shtcurve::ε) ;
DecorationType ::= (dtunderligne::ε) | (dtoverligne::ε) | (dtlinethrough::ε) ;
RotationType ::= (rtvertical::ε) | (rthorizontal::ε) | (rtdiagonal::ε) ;
--------------------markup::pnml-guyard-structured.bgf--------------------
AlignType ::= (atleft::ε) | (atcenter::ε) | (atright::ε) ;
StyleType ::= (sttsolid::ε) | (sttdash::ε) | (sttdot::ε) ;
ShapeType ::= (shtline::ε) | (shtcurve::ε) ;
DecorationType ::= (dtunderligne::ε) | (dtoverligne::ε) | (dtlinethrough::ε) ;
RotationType ::= (rtvertical::ε) | (rthorizontal::ε) | (rtdiagonal::ε) ;
--------------------markup::pnml-highlevelnet.bgf--------------------
Sort ::= BuiltInSort | MultisetSort | ProductSort | UserSort ;
CyclicEnumOperator ::= Successor | Predecessor ;
PartitionOperator ::= PartitionLessThan | PartitionGreaterThan | PartitionElementOf ;
Term ::= Variable | Operator ;
BooleanOperator ::= And | Or | Imply | Not ;
Number ::= Natural | Positive | Integer ;
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
StringOperator ::= StringLessThan | StringLessThanOrEqual | StringGreaterThan | StringGreaterThanOrEqual | StringConcatenation | StringAppend | StringLength | Substring ;
IntegerOperator ::= Addition | Subtraction | Multiplication | Division | Modulo | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual ;
ListOperator ::= ListAppend | ListConcatenation | MakeList | ListLength | MemberAtIndex | Sublist ;
FiniteIntRangeOperator ::= FIRLessThan | FIRLessThanOrEqual | FIRGreaterThan | FIRGreaterThanOrEqual ;
--------------------markup::pnml-hlpng.bgf--------------------
Sort ::= BuiltInSort | MultisetSort | ProductSort | UserSort ;
Term ::= Variable | Operator ;
BooleanOperator ::= And | Or | Imply | Not ;
Declaration ::= SortDeclaration | VariableDeclaration | OperatorDeclaration ;
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
--------------------markup::pnml-integers.bgf--------------------
Number ::= Natural | Positive | Integer ;
IntegerOperator ::= Addition | Subtraction | Multiplication | Division | Modulo | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual ;
--------------------markup::pnml-lists.bgf--------------------
ListOperator ::= ListAppend | ListConcatenation | MakeList | ListLength | MemberAtIndex | Sublist ;
--------------------markup::pnml-multisets.bgf--------------------
MultisetOperator ::= Add | All | NumberOf | Subtract | ScalarProduct | Empty ;
BuiltInOperator ::= Cardinality | CardinalityOf | Contains ;
--------------------markup::rss.bgf--------------------
DayKind ::= (Monday::ε) | (Tuesday::ε) | (Wednesday::ε) | (Thursday::ε) | (Friday::ε) | (Saturday::ε) | (Sunday::ε) ;
--------------------markup::pnml-partitions.bgf--------------------
PartitionOperator ::= PartitionLessThan | PartitionGreaterThan | PartitionElementOf ;
--------------------markup::pnml-pnmlcoremodel.bgf--------------------
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
--------------------markup::pnml-ptnet.bgf--------------------
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
--------------------markup::pnml-strings.bgf--------------------
StringOperator ::= StringLessThan | StringLessThanOrEqual | StringGreaterThan | StringGreaterThanOrEqual | StringConcatenation | StringAppend | StringLength | Substring ;
--------------------markup::pnml-symmetricnet.bgf--------------------
Sort ::= BuiltInSort | MultisetSort | ProductSort | UserSort ;
CyclicEnumOperator ::= Successor | Predecessor ;
PartitionOperator ::= PartitionLessThan | PartitionGreaterThan | PartitionElementOf ;
Term ::= Variable | Operator ;
BooleanOperator ::= And | Or | Imply | Not ;
Declaration ::= SortDeclaration | VariableDeclaration | OperatorDeclaration ;
Number ::= Natural | Positive | Integer ;
netobject.content ::= page.content | place.content | transition.content | refplace.content | reftrans.content | arc.content ;
IntegerOperator ::= Addition | Subtraction | Multiplication | Division | Modulo | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual ;
FiniteIntRangeOperator ::= FIRLessThan | FIRLessThanOrEqual | FIRGreaterThan | FIRGreaterThanOrEqual ;
--------------------markup::pnml-terms.bgf--------------------
Sort ::= BuiltInSort | MultisetSort | ProductSort | UserSort ;
Term ::= Variable | Operator ;
Declaration ::= SortDeclaration | VariableDeclaration | OperatorDeclaration ;
Operator ::= BuiltInOperator | BuiltInConstant | MultisetOperator | Tuple | UserOperator ;
--------------------markup::svg-furubayashi-basic.bgf--------------------
SVG.Script.class ::= SVG.script | SVG.Script.extra.class ;
SVG.Description.class ::= SVG.desc | SVG.title | SVG.metadata | SVG.Description.extra.class ;
SVG.Image.class ::= SVG.image | SVG.Image.extra.class ;
SVG.View.class ::= SVG.view | SVG.View.extra.class ;
SVG.Structure.class ::= SVG.svg | SVG.g | SVG.defs | SVG.symbol | SVG.Use.class | SVG.Structure.extra.class ;
SVG.Style.class ::= SVG.style | SVG.Style.extra.class ;
SVG.Pattern.class ::= SVG.pattern | SVG.Pattern.extra.class ;
SVG.FilterPrimitive.class ::= SVG.feBlend | SVG.feColorMatrix | SVG.feComponentTransfer | SVG.feComposite | SVG.feFlood | SVG.feGaussianBlur | SVG.feImage | SVG.feMerge | SVG.feOffset | SVG.feTile | SVG.FilterPrimitive.extra.class ;
SVG.TextContent.class ::= SVG.tspan | SVG.tref | SVG.textPath | SVG.altGlyph | SVG.TextContent.extra.class ;
SVG.Filter.class ::= SVG.filter | SVG.Filter.extra.class ;
SVG.Profile.class ::= SVG.color-profile | SVG.Profile.extra.class ;
SVG.Extensibility.class ::= SVG.foreignObject | SVG.Extensibility.extra.class ;
SVG.Use.class ::= SVG.use | SVG.Use.extra.class ;
SVG.Hyperlink.class ::= SVG.a | SVG.Hyperlink.extra.class ;
SVG.Conditional.class ::= SVG.switch | SVG.Conditional.extra.class ;
SVG.Gradient.class ::= SVG.linearGradient | SVG.radialGradient | SVG.Gradient.extra.class ;
SVG.Clip.class ::= SVG.clipPath | SVG.Clip.extra.class ;
SVG.Animation.class ::= SVG.animate | SVG.set | SVG.animateMotion | SVG.animateColor | SVG.animateTransform | SVG.Animation.extra.class ;
SVG.Font.class ::= SVG.font | SVG.font-face | SVG.Font.extra.class ;
SVG.Text.class ::= SVG.text | SVG.altGlyphDef | SVG.Text.extra.class ;
SVG.Shape.class ::= SVG.path | SVG.rect | SVG.circle | SVG.line | SVG.ellipse | SVG.polyline | SVG.polygon | SVG.Shape.extra.class ;
SVG.Mask.class ::= SVG.mask | SVG.Mask.extra.class ;
--------------------markup::svg-furubayashi-tiny.bgf--------------------
SVG.Script.class ::= SVG.script | SVG.Script.extra.class ;
SVG.Description.class ::= SVG.desc | SVG.title | SVG.metadata | SVG.Description.extra.class ;
SVG.Image.class ::= SVG.image | SVG.Image.extra.class ;
SVG.View.class ::= SVG.view | SVG.View.extra.class ;
SVG.Extensibility.class ::= SVG.foreignObject | SVG.Extensibility.extra.class ;
SVG.Use.class ::= SVG.use | SVG.Use.extra.class ;
SVG.Hyperlink.class ::= SVG.a | SVG.Hyperlink.extra.class ;
SVG.Conditional.class ::= SVG.switch | SVG.Conditional.extra.class ;
SVG.Animation.class ::= SVG.animate | SVG.set | SVG.animateMotion | SVG.animateColor | SVG.animateTransform | SVG.Animation.extra.class ;
SVG.Structure.class ::= SVG.g | SVG.defs | SVG.Use.class | SVG.Structure.extra.class ;
SVG.Font.class ::= SVG.font | SVG.font-face | SVG.Font.extra.class ;
SVG.Style.class ::= SVG.style | SVG.Style.extra.class ;
SVG.Shape.class ::= SVG.path | SVG.rect | SVG.circle | SVG.line | SVG.ellipse | SVG.polyline | SVG.polygon | SVG.Shape.extra.class ;
SVG.Text.class ::= SVG.text | SVG.Text.extra.class ;
--------------------markup::svg-furubayashi.bgf--------------------
SVG.Script.class ::= SVG.script | SVG.Script.extra.class ;
SVG.Description.class ::= SVG.desc | SVG.title | SVG.metadata | SVG.Description.extra.class ;
SVG.Image.class ::= SVG.image | SVG.Image.extra.class ;
SVG.View.class ::= SVG.view | SVG.View.extra.class ;
SVG.Structure.class ::= SVG.svg | SVG.g | SVG.defs | SVG.symbol | SVG.Use.class | SVG.Structure.extra.class ;
SVG.Style.class ::= SVG.style | SVG.Style.extra.class ;
SVG.Pattern.class ::= SVG.pattern | SVG.Pattern.extra.class ;
SVG.FilterPrimitive.class ::= SVG.feBlend | SVG.feColorMatrix | SVG.feComponentTransfer | SVG.feComposite | SVG.feConvolveMatrix | SVG.feDiffuseLighting | SVG.feDisplacementMap | SVG.feFlood | SVG.feGaussianBlur | SVG.feImage | SVG.feMerge | SVG.feMorphology | SVG.feOffset | SVG.feSpecularLighting | SVG.feTile | SVG.feTurbulence | SVG.FilterPrimitive.extra.class ;
SVG.Marker.class ::= SVG.marker | SVG.Marker.extra.class ;
SVG.TextContent.class ::= SVG.tspan | SVG.tref | SVG.textPath | SVG.altGlyph | SVG.TextContent.extra.class ;
SVG.Filter.class ::= SVG.filter | SVG.Filter.extra.class ;
SVG.Cursor.class ::= SVG.cursor | SVG.Cursor.extra.class ;
SVG.Profile.class ::= SVG.color-profile | SVG.Profile.extra.class ;
SVG.Extensibility.class ::= SVG.foreignObject | SVG.Extensibility.extra.class ;
SVG.Use.class ::= SVG.use | SVG.Use.extra.class ;
SVG.Hyperlink.class ::= SVG.a | SVG.Hyperlink.extra.class ;
SVG.Conditional.class ::= SVG.switch | SVG.Conditional.extra.class ;
SVG.Gradient.class ::= SVG.linearGradient | SVG.radialGradient | SVG.Gradient.extra.class ;
SVG.Clip.class ::= SVG.clipPath | SVG.Clip.extra.class ;
SVG.Animation.class ::= SVG.animate | SVG.set | SVG.animateMotion | SVG.animateColor | SVG.animateTransform | SVG.Animation.extra.class ;
SVG.Font.class ::= SVG.font | SVG.font-face | SVG.Font.extra.class ;
SVG.Text.class ::= SVG.text | SVG.altGlyphDef | SVG.Text.extra.class ;
SVG.Shape.class ::= SVG.path | SVG.rect | SVG.circle | SVG.line | SVG.ellipse | SVG.polyline | SVG.polygon | SVG.Shape.extra.class ;
SVG.Mask.class ::= SVG.mask | SVG.Mask.extra.class ;
--------------------markup::svg-palies.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------markup::uiml.bgf--------------------
UsedInTagKind ::= (event::ε) | (listener::ε) | (part::ε) ;
WhereKind ::= (first::ε) | (last::ε) | (before::ε) | (after::ε) ;
ExportKind ::= (hidden::ε) | (optional::ε) | (required::ε) ;
MapsTypeKind ::= (attribute::ε) | (getMethod::ε) | (setMethod::ε) | (method::ε) ;
HowKind ::= (append::ε) | (cascade::ε) | (replace::ε) | (union::ε) | (delete::ε) ;
--------------------markup::wiki-mediawiki-bnf.bgf--------------------
title-legal-char ::= space | "%" | "!" | """ | "$" | "&" | "'" | "(" | ")" | "*" | "," | "-" | "." | "/" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | ":" | ";" | "=" | "?" | "@" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "\" | "^" | "_" | "`" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "~" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | "" | " " | "¡" | "¢" | "£" | "¤" | "¥" | "¦" | "§" | "¨" | "©" | "ª" | "«" | "¬" | "­" | "®" | "¯" | "°" | "±" | "²" | "³" | "´" | "µ" | "¶" | "·" | "¸" | "¹" | "º" | "»" | "¼" | "½" | "¾" | "¿" | "À" | "Á" | "Â" | "Ã" | "Ä" | "Å" | "Æ" | "Ç" | "È" | "É" | "Ê" | "Ë" | "Ì" | "Í" | "Î" | "Ï" | "Ð" | "Ñ" | "Ò" | "Ó" | "Ô" | "Õ" | "Ö" | "×" | "Ø" | "Ù" | "Ú" | "Û" | "Ü" | "Ý" | "Þ" | "ß" | "à" | "á" | "â" | "ã" | "ä" | "å" | "æ" | "ç" | "è" | "é" | "ê" | "ë" | "ì" | "í" | "î" | "ï" | "ð" | "ñ" | "ò" | "ó" | "ô" | "õ" | "ö" | "÷" | "ø" | "ù" | "ú" | "û" | "ü" | "ý" | "þ" | "ÿ" | "+" ;
table-first-row ::= (table-column-line newline) | table-column-multiline | table-row ;
whitespace ::= (whitespace-char whitespace?) | EOF ;
html-unsafe-symbol ::= unescaped-ampersand | unescaped-less-than | unescaped-greater-than ;
external-link ::= (external-link-start url whitespace? link-description? external-link-end) | url ;
canonical-page-char ::= letter | decimal-digit | underscore ;
hex-digit ::= decimal-digit | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
image-other-parameter ::= image-param-page | image-param-upright | image-param-border ;
link ::= internal-link | external-link ;
special-block ::= horizontal-rule | heading | list-item | table | space-block ;
canonical-page-first-char ::= ucase-letter | decimal-digit | underscore ;
lcase-letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
table-cell-parameters ::= CSS | html-cell-attributes ;
Whitespaces ::= newline | TAB | space ;
article ::= special-block-and-more | paragraph-and-more ;
table-column ::= table-column-line | table-column-multiline ;
image-mode-frame ::= "framed" | "enframed" | "frame" ;
image-mode-parameter ::= image-mode-manual-thumb | image-mode-auto-thumb | image-mode-frame | image-mode-frameless ;
decimal-digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
image-mode-auto-thumb ::= "thumbnail" | "thumb" ;
image-valign-super ::= "super" | "sup" ;
image-align-parameter ::= image-align-left | image-align-center | image-align-right | image-align-none ;
paragraph ::= (newline lines-of-text?) | lines-of-text ;
text-with-formatting ::= formatting | inline-html | noparse-block | behaviour-switch | html-entity | html-unsafe-symbol | text | random-character ;
harmless-character ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
character ::= whitespace-char | non-whitespace-char | html-entity ;
image-option ::= image-mode-parameter | image-size-parameter | image-align-parameter | image-valign-parameter | caption | image-other-parameter ;
letter ::= ucase-letter | lcase-letter ;
non-whitespace-char ::= letter | decimal-digit | symbol ;
whitespace-char ::= space-tab | newline ;
formatting ::= bold-italic-toggle | bold-toggle | italic-toggle ;
list-item ::= indent-item | enumerated-item | bullet-item ;
EOL ::= newline | EOF ;
image-valign-parameter ::= image-valign-baseline | image-valign-sub | image-valign-super | image-valign-top | image-valign-text-top | image-valign-middle | image-valign-bottom | image-valign-text-bottom ;
item-body ::= defined-term | (whitespace? inline-text) ;
magic-link ::= isbn | rfc-number | pmid-number ;
protocol ::= "http://" | "https://" | "ftp://" | "ftps://" | "mailto:" ;
symbol ::= html-unsafe-symbol | underscore | "." | "," ;
media-extension ::= "ogg" | "wav" ;
page-char ::= canonical-page-char | space ;
newline ::= (CR LF) | (LF CR) | CR | LF ;
wiki-markup-characters ::= "|" | "[" | "]" | "*" | "#" | ":" | ";" | "<" | ">" | "=" | "'" | "{" | "}" ;
noparse-block ::= nowiki-block | html-block | math-block | pre-block | html-comment ;
page-first-char ::= canonical-page-first-char | lcase-letter ;
plain-text ::= unicode-wiki | ("<nowiki>" ("|" | "[" | "]" | "<" | ">" | "{" | "}")* "</nowiki>") | (unicode-wiki space* "*" | "#" | ":" | ";") | (unicode-wiki space? "=" space? unicode-wiki) | (unicode-wiki "'") | ("'" unicode-wiki) ;
image-align-center ::= "center" | "centre" ;
ucase-letter ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
space-tab ::= space | TAB ;
image-extension ::= "jpg" | "jpeg" | "png" | "svg" | "gif" | "bmp" ;
wiki-page ::= (redirect article?) | (article?) ;
table-parameters ::= CSS | html-table-attributes ;
inline-element ::= category-link | link | magic-link | image-inline | gallery-block | media-inline | text-with-formatting ;
image-mode-manual-thumb ::= ("thumbnail=" image-name) | ("thumb=" image-name) ;
bad-title-characters ::= "[" | "]" | "{" | "}" | "<" | ">" | "_" | "|" | "#" ;
html-entity ::= ("&" html-entity-name ";") | ("&#" decimal-number ";") | ("&#x" hex-number ";") ;
behaviour-switch ::= behaviourswitch-toc | behaviourswitch-forcetoc | behaviourswitch-notoc | behaviourswitch-noeditsection | behaviourswitch-nogallery ;
heading ::= level-6-heading | level-5-heading | level-4-heading | level-3-heading | level-2-heading | level-1-heading ;
image-param-page ::= "page=$1" | "page $1" ;
--------------------markup::wiki-mediawiki-ebnf.bgf--------------------
external_link ::= URL | (start_link URL (whitespace label)? end_link label_extension) ;
header ::= header1 | header2 | header3 | header4 | header5 | header6 ;
digit ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "0" ;
include ::= template | tplarg ;
URL_char ::= ASCII_letter | digit | "-" | "_" | "." | "~" | "!" | "*" | "'" | "(" | ")" | ";" | ":" | "@" | "&" | "=" | "+" | "$" | "," | "/" | "?" | "%" | "#" | "[" | "]" ;
ASCII_letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
table_cell ::= (line_break "|" (style | whitespace)* text) | (table_cell "||" (style | whitespace)* text) ;
table_header_cell ::= (line_break "!" (style | whitespace)* text) | (table_cell "!!" | "||" (style | whitespace)* text) ;
--------------------markup::wiki-table.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------fl::antlr.bgf--------------------
expr ::= (b::binary) | (a::apply) | (i::ifThenElse) ;
ops ::= "==" | "+" | "-" ;
atom ::= ID | INT | ("(" e::expr ")") ;
--------------------fl::ecore.bgf--------------------
Exp ::= LiteralExp | ArgumentExp | IfThenElseExp | ApplyExp | BinaryExp ;
BinaryExp ::= PlusExp | MinusExp | EqualExp ;
--------------------fl::emf.bgf--------------------
Expr ::= Apply | Argument | Binary | IfThenElse | Literal ;
Ops ::= (Equal::ε) | (Plus::ε) | (Minus::ε) ;
--------------------fl::jaxb.bgf--------------------
Expr ::= Apply | Argument | Binary | IfThenElse | Literal ;
Ops ::= (EQUAL::ε) | (PLUS::ε) | (MINUS::ε) ;
--------------------fl::om.bgf--------------------
Expr ::= Apply | Argument | Binary | IfThenElse | Literal ;
Ops ::= (Equal::ε) | (Plus::ε) | (Minus::ε) ;
--------------------fl::python.bgf--------------------
operators ::= "==" | "+" | "-" ;
expr ::= binary | apply | ifThenElse ;
atom ::= name | literal | ("(" expr ")") ;
--------------------fl::rascal-a.bgf--------------------
FLExpr ::= (binary::(e1::FLExpr op::FLOp e2::FLExpr)) | (apply::(f::string() vargs::(FLExpr*))) | (ifThenElse::(c::FLExpr t::FLExpr e::FLExpr)) | (argument::(a::string())) | (literal::(i::integer())) ;
FLOp ::= (minus::ε) | (plus::ε) | (equal::ε) ;
--------------------fl::txl.bgf--------------------
expression ::= (expression op expression) | (id expression+) | ("if" expression "then" expression "else" expression) | ("(" expression ")") | id | number ;
op ::= "+" | "-" | "==" ;
--------------------fl::xsd.bgf--------------------
Expr ::= Literal | Argument | Binary | IfThenElse | Apply ;
Ops ::= (Equal::ε) | (Plus::ε) | (Minus::ε) ;
--------------------metasyntax::bnf-sdf.bgf--------------------
Element ::= NonTerminal | Terminal | ("[" Element ("|" Element)* "]") | ("{" Element ("|" Element)* "}") | "|" | "[" | "]" | "{" | "}" | "<" | ">" | "..." | "::=" | (Element Element) ;
--------------------metasyntax::txl.bgf--------------------
condition ::= (EX "where" "not"? "all"? NL IN commentNL* expression NL) | (EX "assert" "not"? "all"? NL IN commentNL* expression NL) ;
type ::= formatCues | ("[" typeSpec "]") ;
ruleid ::= id | special | "#" | key ;
functionStatement ::= ("function" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "replace" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX "by" NL IN replacement EX EX "end" "function" NL NL) | ("function" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "match" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX EX "end" "function" NL NL) ;
tokenPattern ::= (typeid TAB_24 stringlit NL) | (TAB_16 "|" TAB_24 stringlit NL) | (typeid TAB_16 "..."? "|" TAB_24 stringlit NL) | (typeid TAB_16 "+" TAB_24 stringlit NL) | (comment NL) ;
typeid ::= id | (SP literal) ;
typeSpec ::= (typeModifier? typeid typeRepeater?) | "!" ;
ruleApplication ::= (SP "[" ruleid varidOrLiteral* eachArgs? "]" commentNL*) | (SP lengthrule varidOrLiteral* eachArgs? "]" commentNL*) ;
ruleStatement ::= ("rule" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "replace" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX "by" NL IN replacement EX EX "end" "rule" NL NL) | ("rule" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "match" dollarStar? SP type NL IN pattern EX EX constructDeconstructImportExportOrCondition* "end" "rule" NL NL) ;
formatId ::= "NL" | ("IN" IN) | ("EX" EX) ;
typeModifier ::= "opt" | "repeat" | "list" | "attr" | "see" | "not" | "push" | "pop" | ":" | "~" | ">" | "<" ;
commentConvention ::= (literal SP literal NL) | (literal NL) ;
literal ::= quotedLiteral | unquotedLiteral | (SP comment NEWoptNL?) ;
typeidOrQuotedLiteral ::= typeid | quotedLiteral ;
statement ::= includeStatement | keysStatement | compoundsStatement | commentsStatement | tokensStatement | defineStatement | redefineStatement | ruleStatement | functionStatement | externalStatement | (comment NL) ;
unquotedLiteral ::= (SP "'") | token ;
literalOrVariable ::= (literal SP) | (varid SP type SP) | (varid SP) ;
dollarStar ::= (SP "$") | (SP "*") ;
literalOrType ::= (type SP) | (literal SP) ;
redefineOrDefine ::= "redefine" | "define" ;
varidOrLiteral ::= (SP varid) | (SP literal) ;
literalOrExpression ::= (literal SP) | (expression SP) ;
keyword ::= (literal SP) | (key SP) ;
quotedLiteral ::= ("'" unquotedLiteral) | ("'" key) ;
externalStatement ::= ("external" "rule" ruleid formalArgument* NL NL) | ("external" "function" ruleid formalArgument* NL NL) ;
typeRepeater ::= "+" | "*" | "?" | "," | ",+" ;
constructDeconstructImportExportOrCondition ::= constructor | deconstructor | condition | importer | exporter | (EX comment NL IN) ;
--------------------metasyntax::ebnf-bgf.bgf--------------------
repetition-metasymbol ::= "+" | "*" ;
expression ::= empty | epsilon | any | value | selectable-expression | marked-expression | repetition-expression | optional-expression | terminal | nonterminal | group-expression ;
value ::= "INT" | "STR" ;
--------------------metasyntax::ebnf-iso-1.bgf--------------------
commentless_symbol ::= terminal_character | meta_identifier | integer | terminal_string | special_sequence ;
start_repeat_symbol ::= "{" | "(:" ;
decimal_digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
end_option_symbol ::= "]" | "/)" ;
definition_separator_symbol ::= "|" | "/" | "!" ;
meta_identifier_character ::= letter | decimal_digit ;
gap_separator ::= space_character | horizontal_tabulation_character | new_line | vertical_tabulation_character | form_feed ;
other_character ::= " " | ":" | "+" | "_" | "%" | "@" | "&" | "#" | "$" | "<" | ">" | "\" | "^" | "‘" | "~" ;
comment_symbol ::= bracketed_textual_comment | other_character | commentless_symbol ;
end_repeat_symbol ::= "}" | ":)" ;
terminal_character ::= letter | decimal_digit | concatenate_symbol | defining_symbol | definition_separator_symbol | end_comment_symbol | end_group_symbol | end_option_symbol | end_repeat_symbol | except_symbol | first_quote_symbol | repetition_symbol | second_quote_symbol | special_sequence_symbol | start_comment_symbol | start_group_symbol | start_option_symbol | start_repeat_symbol | terminator_symbol | other_character ;
letter ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
start_option_symbol ::= "[" | "(/" ;
terminal_string ::= (first_quote_symbol first_terminal_character+ first_quote_symbol) | (second_quote_symbol second_terminal_character+ second_quote_symbol) ;
syntactic_primary ::= optional_sequence | repeated_sequence | grouped_sequence | meta_identifier | terminal_string | special_sequence | empty_sequence ;
gap_free_symbol ::= terminal_character | terminal_string ;
terminator_symbol ::= ";" | "." ;
--------------------metasyntax::ebnf-iso-2.bgf--------------------
comment_symbol ::= comment | terminal_string | special_sequence | character ;
terminal_string ::= ("’" character+ "’") | (""" character+ """) ;
primary ::= optional_sequence | repeated_sequence | special_sequence | grouped_sequence | meta_identifier | terminal_string | empty ;
--------------------metasyntax::ebnf-iso-3.bgf--------------------
TERMINAL ::= ("’" CHARACTER+ "’") | (""" CHARACTER+ """) ;
COMMENT_SYMBOL ::= COMMENT | TERMINAL | SPECIAL_SEQUENCE | CHARACTER ;
PRIMARY ::= OPTIONAL_SEQUENCE | REPEATED_SEQUENCE | SPECIAL_SEQUENCE | GROUPED_SEQUENCE | META_IDENTIFIER | TERMINAL | EMPTY ;
--------------------metasyntax::relaxng.bgf--------------------
name-class ::= (name::(common-atts string())) | (anyName::(common-atts except-name-class)) | (nsName::(common-atts except-name-class)) | (choice::(common-atts open-name-classes)) ;
pattern ::= (element::((name::string()) | open-name-class common-atts open-patterns)) | (attribute::(common-atts (name::string()) | open-name-class other pattern?)) | (group::(common-atts open-patterns)) | (interleave::(common-atts open-patterns)) | (choice::(common-atts open-patterns)) | (optional::(common-atts open-patterns)) | (zeroOrMore::(common-atts open-patterns)) | (oneOrMore::(common-atts open-patterns)) | (list::(common-atts open-patterns)) | (mixed::(common-atts open-patterns)) | (ref::(name::string() common-atts other)) | (parentRef::(name::string() common-atts other)) | (empty::(common-atts other)) | (text::(common-atts other)) | (value::((type::string())? common-atts string())) | (data::(type::string() common-atts other (param::(name::string() common-atts string()))* (except::(common-atts open-patterns))?)) | (notAllowed::(common-atts other)) | (externalRef::(href::string() common-atts other)) | (grammar::(common-atts grammar-content)) ;
--------------------metasyntax::ebnf-sdf.bgf--------------------
Expression ::= IdCon | String | ("(" Expression ")") | (Expression "?") | (Expression "*") | (Expression "+") | (Expression "|" Expression) | (Expression Expression) ;
--------------------metasyntax::lll-kort.bgf--------------------
basis ::= ident | literal | "%epsilon" | alternation | group ;
repetition ::= "+" | "*" | "?" ;
--------------------metasyntax::lll-ldta.bgf--------------------
basis ::= literal | sort ;
repetition ::= "*" | "+" | "?" ;
--------------------metasyntax::xsd-guyard.bgf--------------------
Boolean ::= "true" | "false" ;
AttributeUseType ::= (null::ε) | (optional::ε) | (prohibited::ε) | (required::ε) ;
--------------------metasyntax::yacc-sdf.bgf--------------------
Expression ::= Terminal | NonTerminal | Literal | ("%prec" Terminal) | C-code | (Expression Expression) ;
Yacc-declaration ::= ("%token" | "%left" | "%right" | "%nonassoc" (Terminal | Literal)+ String?) | ("%start" Terminal) ;
--------------------metasyntax::yacc-txl.bgf--------------------
literal ::= quotedLiteral | unquotedLiteral ;
plusOrStar ::= "+" | "*" ;
unquotedLiteral ::= yac_id | charlit | stringlit | number | key ;
tokenDefinition ::= yac_tokenDefinition | ("define" yac_id NL IN yac_tokenDefinition EX "end" "define" NL NL) ;
Ccode_or_token ::= Ccode | token ;
literalOrType ::= literal | type | prec | Ccode ;
productionDefinition ::= (yac_id ":" NL IN SP SP literalsAndTypes barLiteralsAndTypes* ";"? NL EX) | ("define" yac_id NL IN SP SP literalsAndTypes NL barLiteralsAndTypes* EX "end" "define" NL NL) ;
yac_literal ::= yac_id | charlit ;
type ::= (SP "[" yac_id "]") | (SP "[" "opt" yac_idOrQuotedLiteral "]") | (SP "[" "repeat" yac_idOrQuotedLiteral plusOrStar? "]") | (SP "[" "list" yac_idOrQuotedLiteral plusOrStar? "]") ;
barLiteralsAndTypes ::= ("|" SP literalsAndTypes NL) | (SP bar_yac_literals NL) ;
yac_tokdef ::= id | charlit ;
yac_idOrQuotedLiteral ::= yac_id | quotedLiteral ;
--------------------metasyntax::xsd-tennison.bgf--------------------
simpleRestrictionModel ::= (base::"xs:anySimpleType" rangeFacets digitFacets lengthFacets whiteSpace? enumeration* pattern*) | (base::"xs:string" lengthFacets whiteSpace? enumeration* pattern*) | (base::"xs:normalizedString" lengthFacets whiteSpaceReplaceOrCollapse? enumeration* pattern*) | (base::("xs:token" | "xs:language" | "xs:Name" | "xs:NCName" | "xs:ID" | "xs:IDREF" | "xs:IDREFS" | "xs:NMTOKEN" | "xs:NMTOKENS" | "xs:ENTITY" | "xs:ENTITIES" | "xs:hexBinary" | "xs:base64Binary" | "xs:anyURI" | "xs:QName" | "xs:NOTATION") lengthFacets commonFacets) | (base::"xs:boolean" whiteSpaceCollapse? pattern*) | (base::("xs:decimal" | "xs:integer" | "xs:nonPositiveInteger" | "xs:nonNegativeInteger" | "xs:positiveInteger" | "xs:negativeInteger" | "xs:unsignedLong" | "xs:unsignedInt" | "xs:unsignedShort" | "xs:unsignedByte" | "xs:long" | "xs:int" | "xs:short" | "xs:byte") digitFacets rangeFacets commonFacets) | (base::("xs:float" | "xs:double" | "xs:duration" | "xs:dateTime" | "xs:time" | "xs:date" | "xs:gYearMonth" | "xs:gYear" | "xs:gMonthDay" | "xs:gMonth" | "xs:gDay") rangeFacets commonFacets) | ((base::string()) | localSimpleType rangeFacets digitFacets lengthFacets whiteSpace? enumeration* pattern*) ;
complexTypeModel ::= simpleContent | ((mixed::("true" | "false"))? complexContent | (typeDefParticle? attrDecls)) ;
nestedParticle ::= localElement | groupRef | choice | sequence | any ;
identityConstraint ::= unique | key | keyref ;
derivationSet ::= "#all" | reducedDerivationControl ;
fixedOrDefault ::= ε | (fixed::string()) | (default::string()) ;
simpleDerivationSet ::= "#all" | (("list" | "union" | "restriction")*) ;
simpleDerivation ::= simpleRestriction | list | union ;
allNNI ::= integer() | "unbounded" ;
attributeType ::= ε | (type::string()) | localSimpleType ;
blockSet ::= "#all" | (("extension" | "restriction" | "substitution")*) ;
formChoice ::= "qualified" | "unqualified" ;
schemaTop ::= redefinable | topLevelElement | topLevelAttribute | notation ;
lengthFacets ::= length | (minLength? maxLength?) ;
typeDefParticle ::= groupRef | all | choice | sequence ;
redefinable ::= topLevelSimpleType | topLevelComplexType | namedGroup | namedAttributeGroup ;
--------------------tescol::00000.bgf--------------------
literal ::= INT | DOUBLE ;
substatement ::= (SKIP SEMI) | assignment | cond | loop ;
statement ::= (LBRACE substatement* RBRACE SEMI) | substatement ;
operatorsymbol ::= ADD | SUB | DIV | MULTI | EXPO ;
parexp ::= literal | (id2::CONSTID) | (id1::ID) | (LPAR arithexp RPAR) ;
syntaxsymbol ::= SEMI | COLON | COMMA | LPAR | RPAR | ASSIGN | QMARK | LBRACE | RBRACE ;
negateexp ::= (SUB negateexp) | parexp ;
type ::= INTWORD | DOUWORD ;
declaration ::= constdec | vardec | procdec ;
token ::= keyword | WS | identifier | symbol | COMMENT | literal | constantid ;
keyword ::= DONE | TROLLEY | CONTAINS | CHECKOUT | SKIP | CONST | PROC | VAR | IF | THEN | ELSE | WHILE | DO | INTWORD | DOUWORD ;
symbol ::= syntaxsymbol | operatorsymbol | comparisonsymbol ;
compoperator ::= CONJUNCT | DISJUNCT ;
comparisonsymbol ::= EQUALS | NOTEQ | LT | LTE | GT | GTE ;
--------------------tescol::00001.bgf--------------------
statement ::= assignment | conditional | loops | grstatement | SKIP ;
id ::= ID | CID ;
types ::= TYPEI | TYPED ;
declarations ::= constDec | varDec | procDec ;
atom ::= INTG | DOUBLE | (ID arglist?) | (CID arglist?) | (OPAR expr CPAR) ;
--------------------tescol::00010.bgf--------------------
DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
booleanOperator ::= EQUAL | NOT_EQUAL | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL ;
bracketedExpr ::= condExpr | arithmeticExpr ;
type ::= INT_TYPE | DOUBLE_TYPE ;
booleanAtom ::= (arithmeticExpr booleanOperator arithmeticExpr) | (LPAR booleanExpr RPAR) ;
unaryExpr ::= (MINUS atom) | (PLUS atom) | atom ;
stat ::= skip | assign | cond | loop | (LCURLYPAR stat* RCURLYPAR SEMI) ;
atom ::= INT | DOUBLE | CONST_ID | VAR_ID | (LPAR bracketedExpr RPAR) | procApply ;
--------------------tescol::00011.bgf--------------------
literal ::= INT | DOUBLE ;
statement ::= (SKIP SEMI) | (assignmentstatement SEMI) | whilestatement | ifstatement | (OBRACE statement+ CBRACE) ;
arithmeticoperator ::= ADDITION | SUBTRACT | DIVISION | MULTIPLY | EXP ;
booleanoperator ::= EQUAL | NONEQUAL | LESS | LESSEQUAL | MORE | MOREEQUAL | CONJUNCTION | DISJUNCTION ;
type ::= INTTYPE | DOUBLETYPE ;
identifier ::= ID | CONSTID ;
operator ::= arithmeticoperator | booleanoperator ;
atom ::= literal | identifier | (OPARAN expression CPARAN) ;
--------------------tescol::00100.bgf--------------------
statement ::= skip | assignment | ifStat | loop ;
type ::= INT | DOUBLE ;
multOperand ::= MULTIPLICATION | DIVISION ;
addOperand ::= ADDITION | SUBTRACTION ;
relational ::= EQUALITY | NON_EQUALITY | LESS | LESS_EQUAL | GREATER_EQUAL | GREATER ;
statements ::= statement | groupStatement ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | ID | CID | procedureApp | (LPAREN expression RPAREN) ;
--------------------tescol::00101.bgf--------------------
statement ::= statement_main | (OPENCURL statement_main (SEMICOLON statement_main)* CLOSECURL) ;
relationals ::= EQUALITY | NON_EQUALITY | L_THAN | LE_THAN | G_THAN | GE_THAN ;
id ::= ID | CONSTID ;
number ::= INT_VAL | DOUBLE_VAL ;
types ::= INTEGER | DOUBLE ;
logical ::= AND | OR ;
statement_main ::= SKIP | if_statement | while_statement | assignment ;
header_declaration ::= const_dec | var_dec | proc_dec ;
arith_atom ::= ((ADDITION | SUBTRACTION)? number) | id | (OPENPAR expr CLOSEPAR) | proc_call ;
--------------------tescol::00110.bgf--------------------
statement ::= assignmentStatement | whileStatement | ifStatement | skipStatement | (LEFT_BRACKET (assignmentStatement | whileStatement | ifStatement | skipStatement)+ RIGHT_BRACKET) ;
WS ::= " " | "\t" | "\f" | "\r\n" | "\r" | "\n" ;
term ::= (LEFT_PAREN expression RIGHT_PAREN) | procedureApplication | (v2::VAR_ID) | CONST_ID | INTEGER | DOUBLE ;
TYPE ::= "int" | "double" ;
declarations ::= constantDeclaration | variableDeclaration | procedureDeclaration ;
--------------------tescol::00111.bgf--------------------
statement ::= SKIP | assignment | conditional | loop ;
arithEx ::= expr | procedureApplication ;
WS ::= " " | "\r" | "\t" | "\u000C" ;
type ::= INT | DOUBLE ;
identifier ::= ID | CID ;
compoundStatement ::= (LBRACE statement (SEMI statement)* RBRACE) | statement ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | identifier | (LPAREN conditionalExpr RPAREN) ;
--------------------tescol::01000.bgf--------------------
statement ::= SKIP | statements | (LCBRACK statement (SEMI statement)* RCBRACK) ;
nums ::= VARID | CONSTID | INTNUM | DOUBNUM ;
id ::= CONSTID | VARID ;
type ::= INT | DOUBLE ;
statements ::= assign | condstatement | loop ;
comparOps ::= EQ | NEQ | LT | GT | LTE | GTE ;
atom ::= INTNUM | DOUBNUM | id | procapp | (LBRACK arith RBRACK) ;
--------------------tescol::01001.bgf--------------------
statement ::= grouped | SKIP | assignment | conditional | loop ;
type ::= INT_T | DOUBLE_T ;
rel_operator ::= EQ | NEQ | LESS | LESSEQ | GRT | GRTEQ ;
p_id ::= idname::(VAR_ID | CONST_ID) ;
declaration ::= const_dec | var_dec | proc_dec ;
typename ::= INT | DOUBLE ;
v_id ::= idname::(VAR_ID | CONST_ID) ;
atom ::= type | constant | variable | procedure | (OPEN arith_exp CLOSE) ;
minus ::= atom | (MINUS minus) ;
--------------------tescol::01010.bgf--------------------
logicop ::= AND | OR ;
addsub ::= ADDITION | POSITIVE | SUBTRACTION | NEGATIVE ;
statement ::= SKIP | (LCURL statement (SEMI statement)* RCURL) | assignment | ifthenelse | whiledo ;
sign ::= POSITIVE | NEGATIVE ;
arithop ::= POSITIVE | NEGATIVE | ADDITION | SUBTRACTION | MUL | DIV | EXP ;
id ::= ID | CONSTID ;
type ::= INT | DOUBLE ;
declaration ::= procdec | constdec | vardec ;
number ::= INUM | NUM ;
positive ::= POSITIVE | ADDITION ;
comparator ::= EQL | NEQL | GRT | GRTE | LST | LSTE ;
unsignedatom ::= bracketexpr | (id argslist?) | (sign number) | number ;
negative ::= NEGATIVE | SUBTRACTION ;
vartype ::= CONST | VAR | PROC ;
atom ::= (negative unsignedatom) | unsignedatom ;
--------------------tescol::01011.bgf--------------------
statement ::= (LBRACE statement+ RBRACE SEMI) | skip | assignment | conditional | loop | procedureapp | ret ;
term ::= procedureapp | ID | ("(" expression ")") | INUMB | DNUMB ;
--------------------tescol::01100.bgf--------------------
type ::= TYPEINT | TYPEDOUBLE ;
number ::= (ADDITION? INT) | (ADDITION? DOUBLE) | (SUBSTRACTION INT) | (SUBSTRACTION DOUBLE) ;
identifier ::= ID | constidentifier ;
comparison ::= (a2::addition booleanSymbols a1::addition) | addition ;
DIFFERENTOREQUAL ::= "<=" | ">=" ;
statements ::= stat | (LEFTCURLY stat+ RIGHTCURLY SEMICOLON) ;
stat ::= skip | assign | cond | loop ;
program ::= (TROLLEY constidentifier CONTAINS declaration CHECKOUT statements DONE SEMICOLON) | (TROLLEY constidentifier CONTAINS CHECKOUT statements DONE SEMICOLON) ;
STRICTLYDIFFERENT ::= "<" | ">" ;
booleanSymbols ::= EQUALITY | NONEQUALITY | DIFFERENTOREQUAL | STRICTLYDIFFERENT ;
dec ::= constdec | vardec | procdec ;
atom ::= number | procedure | identifier | (LEFTPARENTHESIS condExp RIGHTPARENTHESIS) | (SUBSTRACTION condExp) ;
--------------------tescol::01101.bgf--------------------
statement ::= conditional | loop | assignment | skip | procedure_call ;
TYPE ::= "int" | "double" ;
negation ::= (SUB atom) | atom ;
varIDs ::= CID | ID ;
cond_statements ::= (OPENBRACKET statement* CLOSEDBRACKET) | statement ;
atom ::= procedure_call | CID | ID | (OPENPARENTHESIS mix_fix CLOSEDPARENTHESIS) | INT | DOUBLE ;
--------------------tescol::01110.bgf--------------------
statement ::= assignment | ifStat | loopStat | skipStat | (LBRACE statement+ RBRACE SEMI) ;
declaration ::= constDec | varDec | procDec ;
mixFix ::= (a::conjDisjunExpr QUESTION b::conjDisjunExpr COLON c::conjDisjunExpr) | conjDisjunExpr ;
ifStat ::= (IF a::mixFix THEN b::statement ELSE c::statement) | (IF a::mixFix THEN b::statement) ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | ID | CID | procCall | (LPAREN mixFix RPAREN) ;
--------------------tescol::01111.bgf--------------------
operations ::= EQUALITY | NONEQUALITY | LESSTHAN | LESSTHANOREQUAL | GREATERTHAN | GREATERTHANOREQUAL ;
number ::= INTKEYWORD | DOUBLEKEYWORD ;
declarations ::= (CONST constDec SEMI) | (VAR varDec SEMI) | (PROC procDec) ;
stat ::= conditionalStat | loopStat | (assignStat SEMI) | (SKIP SEMI) | (LPAR stat+ RPAR SEMI) ;
atom ::= CONSTID | VARANDPROCID | (("+" | "-")? INTVALUE) | (("+" | "-")? DOUBLEVALUE) | applyProc | (OPAR arithmeticExpression CPAR) ;
--------------------tescol::10000.bgf--------------------
decl ::= (VAR ID COLON INT | DOUBLE SEMI NEWLINE*) | (CONST CID COLON INT | DOUBLE COLON_EQUALS condExpr SEMI NEWLINE*) | (PROC a::ID LPAREN (decl (COMMA decl)*)? RPAREN COLON_EQUALS stat SEMI NEWLINE*) ;
stat ::= condExpr | SKIP | assign | multStat | ifthenelse | whileloop ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | (a::(CID | ID) (LPAREN (expr (COMMA expr)*)? RPAREN)?) | (LPAREN condExpr RPAREN) ;
--------------------tescol::10001.bgf--------------------
type ::= INT | DOUBLE ;
def ::= (CONST n::cid COLON t::type COLON_EQUALS e::expr SEMI) | (VAR vartypedef SEMI) | (procedure SEMI) ;
stat ::= (expr SEMI) | trolley | checkout | assignment | ifstat | whilestat | (SKIP SEMI) | (LBRACE stat+ RBRACE) | SEMI ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | id | cid | (LPAREN condExpr RPAREN) | proccall ;
--------------------tescol::10010.bgf--------------------
statement ::= SKIP | assignment | conditional | loop | statementList ;
arithmeticOperator ::= ADD | SUBTRACT | DIVIDE | MULTIPLY | EXPON ;
relationalOperator ::= EQUAL | NOTEQUAL | MORETHAN | LESSTHAN | MORETHANEQUAL | LESSTHANEQUAL ;
type ::= INTKEYWORD | DOUBLEKEYWORD ;
number ::= INT | DOUBLE | ID | (LPAREN conditionalExpression RPAREN) ;
operator ::= DEF | QUESTION | CONJUNC | DISJUNC | arithmeticOperator | relationalOperator ;
--------------------tescol::10011.bgf--------------------
statement ::= SKIP | assignment | conditional | loop ;
INT ::= "0" | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*) ;
statementlist ::= statement | (LCPAR statement (SEMI statement)* RCPAR) ;
type ::= INTEGER | DOUBLE ;
declaration ::= consdec | vardec | procdec ;
number ::= INT | DUB ;
expr ::= (multExpr (PLUS | MINUS multExpr)*) | procapp ;
rop ::= EQ | NEQ | LESS | MORE | LESSEQ | MOREEQ ;
atom ::= number | VARIABLE | CONSTANT | (LPAR cexpr RPAR) ;
--------------------tescol::10100.bgf--------------------
statement ::= statementList | condStatement | expression | assignment | loop | SKIP ;
type ::= INT | DOUBLE ;
individual_declaration ::= (CONST CID COLON type COLON_EQUALS expression) | (VAR ID COLON type) | (PROC ID paramlist COLON type COLON_EQUALS statement) ;
atom ::= INT_NUMBER | DOUBLE_NUMBER | ID | CID | (LPAREN expression RPAREN) ;
--------------------tescol::10101.bgf--------------------
statement ::= SKIP | (ID ASSIGN condExpr) | (IF boolExpr THEN statement ELSE statement) | (WHILE boolExpr DO statement) ;
type ::= INT | FLOAT ;
declaration ::= variabledec | constantdec | proceduredec ;
mainstatement ::= ε | statement | (STATEMENTOPEN statement (SEMI statement)* STATEMENTCLOSE) ;
atom ::= INTEGER | FLOATINGPOINT | CONSTANTID | ID | (PARENOPEN condExpr PARENCLOSE) | procedureList ;
--------------------tescol::10110.bgf--------------------
statement ::= SKIP | conditional | loop | assignment | cond_expr | (CURLY_L SKIP | conditional | loop | assignment | cond_expr (SEMI statement)* CURLY_R) ;
type ::= "int" | "double" ;
identifier ::= ID | CID ;
comparator ::= EQUALITY | NON_EQUALITY | LESS_THAN | GREATER_THAN | LESS_THAN_EQ | GREATER_THAN_EQ ;
operator ::= ADD | SUBTRACT | MULTIPLY | DIVIDE | EXPONENTIATION | EQUAL ;
dec ::= constant | var | proc ;
atom ::= INT | DOUBLE | ID | CID | (LPAR condExpr RPAR) | procedure_expr ;
DOUBLE ::= (INT "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT?) | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT?) | (INT EXPONENT) | "." ;
--------------------tescol::10111.bgf--------------------
statement ::= (KW_SKIP SYM_SEMI) | (a::varproc_id SYM_ASS c::mixfix SYM_SEMI) | (SYM_OPEN_BRACE statement+ SYM_CLOSE_BRACE SYM_SEMI) | (KW_IF mixfix KW_THEN statement KW_ELSE statement) | (KW_WHILE mixfix KW_DO statement) ;
varproc_id ::= ID_VARPROC | ID_GENERAL ;
type ::= KW_TYPE_INT | KW_TYPE_DOUBLE ;
decl ::= (const_decl | var_decl SYM_SEMI) | proc_decl ;
comparator ::= SYM_EQ | SYM_INEQ | SYM_GT | SYM_NS_GT | SYM_LT | SYM_NS_LT ;
immediate ::= integerNum | doubleNum ;
atom ::= immediate | (v::varproc_id) | proc_call | parenthesised ;
--------------------tescol::11000.bgf--------------------
relationships ::= EQUALITY | NONEQUALITY | GREATERTHAN | LESSTHAN | GREATEROREQUAL | LESSOREQUAL ;
numbervalues ::= INTEGER | DOUBLE ;
declarations ::= constant | variable | procedure ;
runproc ::= conditexpr | (ID | CID LEFTBRACKET (expression (COMMA expression)*)? RIGHTBRACKET) ;
atom ::= INT | DOU | ID | CID | (LEFTBRACKET expression RIGHTBRACKET) ;
--------------------tescol::11001.bgf--------------------
atom_exp ::= (e::unary_exp) | (LPAREN exp::expression RPAREN) | (proc::proccall) ;
statement ::= SKIP | (LBRACE statement (SEMI statement)* SEMI? RBRACE) | assignment | ifstatement | whilestatement ;
id ::= name::(CONSTID | VARID) ;
argumentlist ::= (exp::expression (COMMA args::argumentlist)?) | ε ;
type ::= TINT | TDOUBLE ;
number ::= (f::FLOAT) | (i::INT) | (u::UINT) ;
parameterlist ::= (name::varid COLON t::type (COMMA params::parameterlist)?) | ε ;
conditional ::= (t::EQUALITY) | (t::INEQUALITY) | (t::LANGLE) | (t::RANGLE) | (t::LTEQUALS) | (t::GTEQUALS) ;
varid ::= CONSTID | VARID ;
--------------------tescol::11010.bgf--------------------
type ::= INTEGER | FLOATDOUBLE ;
declarations ::= (CONST constDec SEMI) | (VAR varDec SEMI) | (PROC procDec SEMI) ;
stat ::= conditionalStat | loopStat | assignStat | (LEFTBRACE stat (SEMI stat)* RIGHTBRACE SEMI) | SKIP ;
smallId ::= CONSTID | ID ;
atom ::= CONSTID | ID | INT | DOUBLE | (LEFTPAR condExpr RIGHTPAR) | applyProc ;
--------------------tescol::11011.bgf--------------------
statement ::= assign | SKIP | conditional | loop | statement_group ;
dec_types ::= TYPE_INT | TYPE_DOUBLE ;
ids ::= ID | CONST_ID ;
atom ::= INT | DOUBLE | (ids argument_list?) | (LPAR expr RPAR) ;
--------------------tescol::11100.bgf--------------------
statement ::= (SKIP SEMI) | (ID ASSIGNMENT expression SEMI) | (IF boolexp THEN statement ELSE statement) | (WHILE boolexp DO statement) | (LEFTBRACE statement+ RIGHTBRACE) ;
BOOLOPERATOR ::= "/\\" | "\\/" ;
type ::= INTTYPE | DOUBLETYPE ;
COMPARISON ::= "==" | "!=" | "<=" | ">=" | "<" | ">" ;
definition ::= (CONST CONSTID COLON type ASSIGNMENT expression) | (VAR ID COLON type) | (PROC ID LEFTBRACKET parameters? RIGHTBRACKET COLON type ASSIGNMENT statement) ;
addop ::= PLUS | MINUS ;
MULTIPLIER ::= "**" | "/" | "*" ;
value ::= INT | DOUBLE ;
atom ::= procedurecall | ID | CONSTID | (LEFTBRACKET expression RIGHTBRACKET) | value ;
--------------------tescol::11101.bgf--------------------
statement ::= (SKIP SEMI) | assignment | conditional | loop | groupedstatement ;
type ::= INT | DBLE ;
declaration ::= constdeclaration | vardeclaration | procdeclaration ;
number ::= INTEGER | DOUBLE ;
expression ::= (p1::procedureapplication) | (b1::booleanexpression (QUESTION expression COLON expression)?) ;
ROP ::= "==" | "!=" | "<" | "<=" | ">=" | ">" ;
atom ::= constantidentifier | varprocidentifier | number | (PARENTHESISL expression PARENTHESISR) ;
--------------------tescol::11110.bgf--------------------
arithmeticExpr ::= conditionalExpr | (a::applyProcedure) ;
statement ::= (e::singleStatement) | (b::listofStatement) ;
type ::= INT | DOUBLE ;
singleStatement ::= skipStm | loopStm | condStm | (a::assgStm) ;
unaryExpr ::= ("-" atom) | atom ;
atom ::= INTEGER | FLOAT | CONSTID | ("(" conditionalExpr ")") | applyProcedure | ID ;
--------------------tescol::11111.bgf--------------------
statement ::= single_statement | multiple_statement ;
term ::= INT_NUMBER | DOUBLE_NUMBER | (LPAREN expression RPAREN) | id | proc ;
id ::= CONSTID | VARID ;
type ::= INT | DOUBLE ;
declaration ::= constant_declaration | variable_declaration | procedure_declaration ;
relational_op ::= EQUAL | NONEQUAL | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL ;
single_statement ::= SKIP | assignment | conditional | loop ;
--------------------tescol::reference.bgf--------------------
statement ::= stmtElem | stmtList ;
appList ::= ε | (e::expression (COMMA f::expression)*) ;
DIGIT ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
EQOP ::= ET | NET ;
term ::= (LPAR expression RPAR) | (CONSTID p::procApp) | (ID p::procApp) ;
paramList ::= ε | (p::paramElem (COMMA q::paramElem)*) ;
procApp ::= ε | (LPAR appList RPAR) ;
RELOP ::= LT | LTE | GT | GTE ;
type ::= INT | DOUB ;
declaration ::= constDecl | varDecl | procDecl ;
number ::= INTEGER | DOUBLE ;
stmtElem ::= SKIP | assign | condSt | loop ;
UPPER ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
LOWER ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
MULTOP ::= MULT | DIV ;
--------------------metamodels::ACG.bgf--------------------
Severity ::= (critic::ε) | (error::ε) | (warning::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::ACME.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::ASM.bgf--------------------
Boolean ::= "true" | "false" ;
AccessUpdateType ::= (access::ε) | (update::ε) ;
AsmType ::= (function::ε) | (subasm::ε) ;
--------------------metamodels::ATL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::AWKPrograms.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Agate.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Amble.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::AnyLogic.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Architectural_Description.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::AsmL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::BMM.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::BPEL.bgf--------------------
XSDVariety ::= (union::ε) | (list::ε) | (atomic::ε) ;
XSDSubstitutionGroupExclusions ::= (restriction::ε) | (extension::ε) ;
XSDSimpleFinal ::= (list::ε) | (restriction::ε) | (all::ε) | (union::ε) ;
XSDXPathVariety ::= (field::ε) | (selector::ε) ;
XSDDisallowedSubstitutions ::= (extension::ε) | (substitution::ε) | (all::ε) | (restriction::ε) ;
XSDAttributeUseCategory ::= (prohibited::ε) | (optional::ε) | (required::ε) ;
XSDProhibitedSubstitutions ::= (extension::ε) | (restriction::ε) | (all::ε) ;
XSDComplexFinal ::= (all::ε) | (restriction::ε) | (extension::ε) ;
CorrelationPattern ::= (outin::ε) | (in::ε) | (out::ε) ;
XSDNamespaceConstraintCategory ::= (set::ε) | (not::ε) | (any::ε) ;
XSDForm ::= (unqualified::ε) | (qualified::ε) ;
XSDDiagnosticSeverity ::= (fatal::ε) | (warning::ε) | (error::ε) | (information::ε) ;
EndpointReferenceRole ::= (partnerRole::ε) | (myRole::ε) ;
XSDCompositor ::= (all::ε) | (choice::ε) | (sequence::ε) ;
XSDContentTypeCategory ::= (elementOnly::ε) | (mixed::ε) | (simple::ε) | (empty::ε) ;
XSDWhiteSpace ::= (replace::ε) | (collapse::ε) | (preserve::ε) ;
XSDConstraint ::= (fixed::ε) | (default::ε) ;
XSDCardinality ::= (countablyInfinite::ε) | (finite::ε) ;
XSDOrdered ::= (total::ε) | (partial::ε) ;
XSDIdentityConstraintCategory ::= (keyref::ε) | (unique::ε) | (key::ε) ;
XSDDerivationMethod ::= (extension::ε) | (restriction::ε) ;
XSDProcessContents ::= (skip::ε) | (lax::ε) | (strict::ε) ;
--------------------metamodels::BPMN.bgf--------------------
DirectionType ::= (Both::ε) | (From::ε) | (To::ε) | (None::ε) ;
ActivityType ::= (SubProcess::ε) | (EventEndMultiple::ε) | (EventEndMessage::ε) | (EventIntermediateMessage::ε) | (EventStartMultiple::ε) | (EventIntermediateMultiple::ε) | (GatewayParallel::ε) | (EventStartTimer::ε) | (EventStartEmpty::ε) | (EventIntermediateCancel::ε) | (EventEndError::ε) | (EventStartRule::ε) | (EventEndTerminate::ε) | (EventStartLink::ε) | (EventIntermediateLink::ε) | (EventEndCancel::ε) | (EventEndLink::ε) | (EventIntermediateEmpty::ε) | (EventIntermediateCompensation::ε) | (Task::ε) | (GatewayDataBasedExclusive::ε) | (GatewayComplex::ε) | (EventEndEmpty::ε) | (EventIntermediateError::ε) | (EventIntermediateTimer::ε) | (EventEndCompensation::ε) | (EventStartMessage::ε) | (GatewayDataBasedInclusive::ε) | (GatewayEventBasedExclusive::ε) | (EventIntermediateRule::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::Book.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Bossa.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::BusinessEntityModel.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::BusinessProcessModel.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CDE.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CFG.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::COBOL.bgf--------------------
Boolean ::= "true" | "false" ;
COBOLInitialValueKind ::= (civk_string_value::ε) | (civk_low_value::ε) | (civk_high_value::ε) | (civk_zero_value::ε) | (civk_quotes::ε) | (civk_null::ε) | (civk_all_literal::ε) ;
COBOLUsageValue ::= (cuv_binary::ε) | (cuv_dbcs::ε) | (cuv_double::ε) | (cuv_display::ε) | (cuv_float::ε) | (cuv_index::ε) | (cuv_objectReference::ε) | (cuv_packedDecimal::ε) | (cuv_pointer::ε) | (cuv_procedurePointer::ε) ;
--------------------metamodels::CORBAComponent.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CPL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CPR.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CSM.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CWMCore.bgf--------------------
Boolean ::= "true" | "false" ;
VisibilityKind ::= (vk_public_vis::ε) | (vk_private_vis::ε) | (vk_protected_vis::ε) ;
--------------------metamodels::CWMRelationalData.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Class.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::ChocoModel.bgf--------------------
OpConstraint ::= (eq::ε) | (and2::ε) | (or2::ε) | (gt::ε) | (ge::ε) | (lt::ε) | (le::ε) | (plus::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::Cocus.owl.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::DSL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::CompanyStructure.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::ComponentUML.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Conference.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (male::ε) | (female::ε) ;
--------------------metamodels::Contact.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::ControllerUML.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Cristal.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::DSLModel.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::DSLtools.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::DTD.bgf--------------------
Boolean ::= "true" | "false" ;
OtherAttributeTypeEnum ::= (cdata::ε) | (id::ε) | (idref::ε) | (entityType::ε) | (entities::ε) | (nmtoken::ε) | (nmtakens::ε) ;
Occurence ::= (zeroOrOne::ε) | (zeroOrMore::ε) | (oneOrMore::ε) | (one::ε) ;
--------------------metamodels::DTMP.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::DeploymentReport.bgf--------------------
ProcessorArchitectures ::= (x86::ε) | (ia64::ε) | (amd64::ε) | (wow64::ε) | (msil::ε) | (shx::ε) | (arm::ε) | (data::ε) ;
Boolean ::= "true" | "false" ;
Platform ::= (x86::ε) | (ia64::ε) | (amd64::ε) | (wow64::ε) | (msil::ε) | (shx::ε) | (arm::ε) | (data::ε) | (*::ε) | (neutral::ε) ;
SettingState ::= (Set::ε) | (NotSet::ε) | (Error::ε) ;
--------------------metamodels::DiagramInterchange.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::DoDAF-SV5.bgf--------------------
SupportStatusCode ::= (red::ε) | (yellow::ε) | (green::ε) ;
--------------------metamodels::DotNET_SystemReflection.bgf--------------------
MemberTypes ::= (Constructor::ε) | (Event::ε) | (Field::ε) | (Method::ε) | (Property::ε) | (TypeInfo::ε) | (Custom::ε) | (NestedType::ε) | (All::ε) ;
PropertyAttributes ::= (NotSupported::ε) | (Optional::ε) | (Read::ε) | (Required::ε) | (Write::ε) ;
GenericParameterAttributes ::= (HasElementType::ε) | (Abstract::ε) | (AnsiClass::ε) | (AutoClass::ε) | (AutoLayout::ε) | (ByRef::ε) | (Class::ε) | (COMObject::ε) | (Contextful::ε) | (Enum::ε) | (ExplicitLayout::ε) | (Import::ε) | (Interface::ε) | (LayoutSequential::ε) | (MarshalByRef::ε) | (NestedAssembly::ε) | (NestedFamADNAssem::ε) | (NestedFamily::ε) | (NestedFamORAssem::ε) | (NestedPrivate::ε) | (NestedPublic::ε) | (NotPublic::ε) | (Pointer::ε) | (Primitive::ε) | (Public::ε) | (Sealed::ε) | (Serializable::ε) | (SpecialName::ε) | (UnicodeClass::ε) | (ValueType::ε) ;
MethodAttributes ::= (Abstract::ε) | (Assembly::ε) | (ChekedAccessOnOverride::ε) | (FamADNAssem::ε) | (Family::ε) | (FamORAssem::ε) | (Final::ε) | (HasSecurity::ε) | (HideBySig::ε) | (MemberAccessMask::ε) | (NewSlot::ε) | (PInvokeImpl::ε) | (Private::ε) | (PrivateScope::ε) | (Public::ε) | (RequiredSecObject::ε) | (ReservedMask::ε) | (ReuseSlot::ε) | (RTSpecialName::ε) | (SpecialName::ε) | (Static::ε) | (UnmanagedExport::ε) | (Virtual::ε) | (VtableLayoutMask::ε) ;
Boolean ::= "true" | "false" ;
TypeAttributes ::= (Abstract::ε) | (AnsiClass::ε) | (AutoClass::ε) | (AutoLayout::ε) | (BeforFieldInit::ε) | (Class::ε) | (ClassSemanticsMask::ε) | (ExplicitLayout::ε) | (HasSecutity::ε) | (Import::ε) | (Interface::ε) | (LayoutMask::ε) | (NestedAssembly::ε) | (NestedFamADNAssem::ε) | (NestedFamily::ε) | (NestedFamORAssem::ε) | (NestedPrivate::ε) | (NestedPublic::ε) | (NotPublic::ε) | (Public::ε) | (ReservedMask::ε) | (RTSpecialName::ε) | (Sealed::ε) | (SequentialLayout::ε) | (Serializable::ε) | (SpecialName::ε) | (StringFormatMask::ε) | (UnicodeClass::ε) | (VisibilityMask::ε) ;
FieldAttributes ::= (FieldAccessMask::ε) | (PrivateScope::ε) | (Private::ε) | (Assembly::ε) | (Family::ε) | (FamANDAssem::ε) | (FamORAssem::ε) | (Public::ε) | (Shared::ε) | (InitOnly::ε) | (Literal::ε) | (NotSerialized::ε) | (SpecialName::ε) | (PinvokeImpl::ε) | (ReservedMask::ε) | (RTSpecialName::ε) | (HasFieldMarshal::ε) | (HasDefault::ε) | (HasFieldRVA::ε) | (Static::ε) ;
EventAttributes ::= (None::ε) | (ReservedMask::ε) | (RTSpecialName::ε) | (SpecialName::ε) ;
ParameterAttributes ::= (HasDefault::ε) | (HasDefaultMArshal::ε) | (In::ε) | (Lcid::ε) | (None::ε) | (Optional::ε) | (Out::ε) | (Reserved3::ε) | (Reserved4::ε) | (ReservedMask::ε) | (RetVal::ε) ;
--------------------metamodels::EG.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::EQN.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::EXPRESS.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::EXPRESSb.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::EclipseLaunchConfigurations.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::FeatureDiagrams.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::GUI.bgf--------------------
Layout ::= (default::ε) | (horizontal::ε) | (vertical::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::Gantt.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::GenericEditor.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::GenericOutline.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::GeoTrans.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Grafcet.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::HAL.bgf--------------------
FormatWebEnum ::= (XML::ε) | (HTML::ε) | (HTM::ε) ;
FormatEnum ::= (PDF::ε) | (TEX::ε) | (DOC::ε) | (RTF::ε) | (TXT::ε) | (PS::ε) | (ANNEX::ε) ;
Boolean ::= "true" | "false" ;
DateVisibleEnum ::= (15J::ε) | (1M::ε) | (3M::ε) | (1A::ε) | (2A::ε) | (JAMAIS::ε) ;
--------------------metamodels::HPROF.bgf--------------------
Day ::= (Monday::ε) | (Tuesday::ε) | (Wednesday::ε) | (Thursday::ε) | (Friday::ε) | (Saturday::ε) | (Sunday::ε) ;
Boolean ::= "true" | "false" ;
Month ::= (January::ε) | (February::ε) | (March::ε) | (April::ε) | (May::ε) | (June::ε) | (July::ε) | (August::ε) | (September::ε) | (October::ε) | (November::ε) | (December::ε) ;
--------------------metamodels::HierarchicalStateMachine.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::HybridAutomata.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::IRL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::IMSTransactionMessage.bgf--------------------
OIMAPrefixFormats ::= (opp_one::ε) | (opp_two::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::M.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Jess.bgf--------------------
Boolean ::= "true" | "false" ;
Advice ::= (before::ε) | (after::ε) ;
--------------------metamodels::KDM.bgf--------------------
ParameterKind ::= (byReference::ε) | (unknown::ε) | (exception::ε) | (return::ε) | (byValue::ε) | (catchall::ε) | (byName::ε) | (throws::ε) | (variadic::ε) ;
CallableKind ::= (external::ε) | (regular::ε) | (stored::ε) | (operator::ε) | (unknown::ε) ;
Boolean ::= "true" | "false" ;
ExportKind ::= (private::ε) | (unknown::ε) | (public::ε) | (protected::ε) | (final::ε) ;
MethodKind ::= (operator::ε) | (destructor::ε) | (method::ε) | (abstract::ε) | (virtual::ε) | (unknown::ε) | (constructor::ε) ;
StorableKind ::= (global::ε) | (external::ε) | (static::ε) | (unknown::ε) | (register::ε) | (local::ε) ;
MacroKind ::= (external::ε) | (unknown::ε) | (option::ε) | (undefined::ε) | (regular::ε) ;
--------------------metamodels::KDMSimplified.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::KM3.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Klaper.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::LQN.bgf--------------------
TaskType ::= (a_reference::ε) | (non_reference::ε) ;
SchedulingType ::= (FCFS::ε) | (preemptive_Priority::ε) | (head_of_line::ε) | (random::ε) ;
CallType ::= (synchronous::ε) | (asynchronous::ε) | (forwording::ε) ;
Boolean ::= "true" | "false" ;
PhaseType ::= (stochastic::ε) | (deterministic::ε) ;
LinkType ::= (and_Fork::ε) | (and_join::ε) | (basic::ε) | (or_Fork::ε) | (or_join::ε) ;
--------------------metamodels::Marte.bgf--------------------
LaxityKind ::= (hard::ε) | (soft::ε) | (other::ε) ;
NotificationKind ::= (Memorized::ε) | (Bounded::ε) | (Memoryless::ε) | (Undef::ε) | (Other::ε) ;
TimeStandardKind ::= (TAI::ε) | (UT0::ε) | (UT1::ε) | (UTC::ε) | (Local::ε) | (TT::ε) | (TBD::ε) | (TCG::ε) | (TCB::ε) | (Sidereal::ε) | (GPS::ε) ;
PowerUnitKind ::= (W::ε) | (mW::ε) | (KW::ε) ;
CacheType ::= (Data::ε) | (Instruction::ε) | (Unified::ε) | (Other::ε) | (Undef::ε) ;
BasicNFP_Types_DirectionKind ::= (incr::ε) | (decr::ε) ;
QueuePolicyKind ::= (FIFO::ε) | (LIFO::ε) | (Priority::ε) | (Undef::ε) | (Other::ε) ;
InterruptKind ::= (HardwareInterruption::ε) | (ProcessorDetectedException::ε) | (ProgrammedException::ε) | (Undef::ε) | (Other::ε) ;
VariableDirectionKind ::= (in::ε) | (out::ε) | (inout::ε) ;
AggregationKind ::= (none::ε) | (shared::ε) | (composite::ε) ;
SynchronizationKind ::= (synchronous::ε) | (asynchronous::ε) | (delayedSynchronous::ε) | (rendezVous::ε) | (other::ε) ;
AllocationKind ::= (structural::ε) | (behavioral::ε) | (hybrid::ε) ;
ConstraintKind ::= (required::ε) | (offered::ε) | (constraint::ε) ;
SourceKind ::= (est::ε) | (meas::ε) | (calc::ε) | (req::ε) ;
ParameterEffectKind ::= (create::ε) | (read::ε) | (update::ε) | (delete::ε) ;
EventKind ::= (start::ε) | (finish::ε) | (send::ε) | (receive::ε) | (consume::ε) ;
NotificationResourceKind ::= (Event::ε) | (Barrier::ε) | (Undef::ε) | (Other::ε) ;
ExecutionKind ::= (deferred::ε) | (remoteImmediate::ε) | (localImmediate::ε) ;
ParameterDirectionKind ::= (in::ε) | (inout::ε) | (out::ε) | (return::ε) ;
ObjectNodeOrderingKind ::= (unordered::ε) | (ordered::ε) | (LIFO::ε) | (FIFO::ε) ;
TransitionKind ::= (internal::ε) | (local::ε) | (external::ε) ;
CallConcurrencyKind ::= (sequential::ε) | (guarded::ε) | (concurrent::ε) ;
TimeNatureKind ::= (discrete::ε) | (dense::ε) ;
PseudostateKind ::= (initial::ε) | (deepHistory::ε) | (shallowHistory::ε) | (join::ε) | (fork::ε) | (junction::ε) | (choice::ε) | (entryPoint::ε) | (exitPoint::ε) | (terminate::ε) ;
ConcurrencyKind ::= (reader::ε) | (writer::ε) | (parallel::ε) ;
VisibilityKind ::= (public::ε) | (private::ε) | (protected::ε) | (package::ε) ;
MessageSort ::= (synchCall::ε) | (asynchCall::ε) | (asynchSignal::ε) | (createMessage::ε) | (deleteMessage::ε) | (reply::ε) ;
ConnectorKind ::= (assembly::ε) | (delegation::ε) ;
PLD_Class ::= (SymetricalArray::ε) | (RowBased::ε) | (SeaOfGates::ε) | (HierarchicalPLD::ε) | (Other::ε) | (Undef::ε) ;
LengthUnitKind ::= (m::ε) | (cm::ε) | (mm::ε) ;
SchedPolicyKind ::= (EarliestDeadlineFirst::ε) | (FIFO::ε) | (FixedPriority::ε) | (LeastLaxityFirst::ε) | (RoundRobin::ε) | (TimeTableDriven::ε) | (Undef::ε) | (Other::ε) ;
TransmModeKind ::= (simplex::ε) | (halfDuplex::ε) | (fullDuplex::ε) ;
MutualExclusionResourceKind ::= (BooleanSemaphore::ε) | (CountSemaphore::ε) | (Mutex::ε) | (Undef::ε) | (Other::ε) ;
MessageKind ::= (complete::ε) | (lost::ε) | (found::ε) | (unknown::ε) ;
ProtectProtocolKind ::= (FIFO::ε) | (NoPreemption::ε) | (PriorityCeiling::ε) | (PriorityInheritance::ε) | (StackBased::ε) | (Undef::ε) | (Other::ε) ;
TimeLibrary_TimeUnitKind ::= (s::ε) | (ms::ε) | (us::ε) | (ns::ε) | (min::ε) | (hrs::ε) | (dys::ε) ;
ConditionType ::= (Temperature::ε) | (Humidity::ε) | (Altitude::ε) | (Vibration::ε) | (Shock::ε) | (Other::ε) | (Undef::ε) ;
FrequencyUnitKind ::= (Hz::ε) | (KHz::ε) | (MHz::ε) | (GHz::ε) | (rpm::ε) ;
DirectionKind ::= (in::ε) | (out::ε) | (inout::ε) ;
PeriodicServerKind ::= (Sporadic::ε) | (Deferrable::ε) | (Undef::ε) | (Other::ε) ;
WritePolicy ::= (WriteBack::ε) | (WriteThrough::ε) | (Other::ε) | (Undef::ε) ;
ComponentKind ::= (Card::ε) | (Channel::ε) | (Chip::ε) | (Port::ε) | (Unit::ε) | (Other::ε) | (Undef::ε) ;
OptimallityCriterionKind ::= (meetHardDeadlines::ε) | (minimizeMissedDeadlines::ε) | (minimizedMeanTardiness::ε) | (undef::ε) | (other::ε) ;
AccessPolicyKind ::= (Read::ε) | (Write::ε) | (ReadWrite::ε) | (Undef::ε) | (Other::ε) ;
TimeInterpretationKind ::= (duration::ε) | (instant::ε) ;
ROM_Type ::= (MaskedROM::ε) | (EPROM::ε) | (OTP_EPROM::ε) | (EEPROM::ε) | (Flash::ε) | (Other::ε) | (Undef::ε) ;
MessageResourceKind ::= (MessageQueue::ε) | (Pipe::ε) | (Blackboard::ε) | (Undef::ε) | (Other::ε) ;
Boolean ::= "true" | "false" ;
BFeatureKind ::= (in::ε) | (out::ε) | (inout::ε) | (required::ε) | (provided::ε) | (reqpro::ε) ;
ConcurrentAccessProtocolKind ::= (PIP::ε) | (PCP::ε) | (NoPreemption::ε) | (Undef::ε) | (Other::ε) ;
AllocationNature ::= (spatialDistribution::ε) | (timeScheduling::ε) ;
DataTxRateUnitKind ::= (b_per_s::ε) | (Kb_per_s::ε) | (Mb_per_s::ε) ;
AreaUnitKind ::= (mm2::ε) | (um2::ε) ;
TimeUnitKind ::= (s::ε) | (tick::ε) | (ms::ε) | (us::ε) | (min::ε) | (hrs::ε) | (dys::ε) ;
CompnentState ::= (Operating::ε) | (Storage::ε) | (Other::ε) | (Undef::ε) ;
PoolMgtPolicyKind ::= (infiniteWait::ε) | (timedWait::ε) | (dynamic::ε) | (exception::ε) | (other::ε) ;
StatisticalQualifierKind ::= (max::ε) | (min::ε) | (mean::ε) | (range::ε) | (percent::ε) | (distrib::ε) | (determ::ε) | (other::ε) ;
DataSizeUnitKind ::= (bits::ε) | (Bytes::ε) | (KB::ε) | (MB::ε) | (GB::ε) ;
PLD_Technology ::= (SRAM::ε) | (Antifuse::ε) | (Flash::ε) | (Other::ε) | (Undef::ε) ;
Repl_Policy ::= (LRU::ε) | (NFU::ε) | (FIFO::ε) | (Random::ε) | (Other::ε) | (Undef::ε) ;
ISA_Type ::= (RISC::ε) | (CISC::ε) | (VLIW::ε) | (SIMD::ε) | (Other::ε) | (Undef::ε) ;
EnergyUnitKind ::= (J::ε) | (KJ::ε) | (Wh::ε) | (KWh::ε) | (mWh::ε) ;
--------------------metamodels::METAH.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MICRO.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (Compilers::ε) | (Microarchitecture::ε) | (Systems::ε) | (ForwardLookingIdea::ε) | (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) ;
--------------------metamodels::MSOfficeExcel_SpreadsheetMLBasicDef.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MSOfficeExcel_SpreadsheetMLPrintingSetup.bgf--------------------
CalculationWorkbookType ::= (cwt_automaticCalculation::ε) | (cwt_manualCalculation::ε) | (cwt_semiAutomaticCalculation::ε) ;
VisibleType ::= (vt_SheetVisible::ε) | (vt_SheetHidden::ε) | (vt_SheetVeryHidden::ε) ;
ExcelWorksheetTypeType ::= (ewt_Worksheet::ε) | (ewt_Chart::ε) | (ewt_Macro::ε) | (ewt_Dialog::ε) ;
OrientationType ::= (ot_Landscape::ε) | (ot_Portrait::ε) ;
Boolean ::= "true" | "false" ;
CommentsLayoutType ::= (clt_InPlace::ε) | (clt_PrintNone::ε) | (clt_SheetEnd::ε) ;
EnableSelectionType ::= (est_UnlockedCells::ε) | (est_NoSelection::ε) ;
DisplayDrawingObjectsType ::= (ddot_displayShapes::ε) | (ddot_placeHolders::ε) | (ddot_hideAll::ε) ;
--------------------metamodels::MSOfficeExcel_SpreadsheetMLSimplified.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MSOfficeExcel_SpreadsheetMLStyles.bgf--------------------
VerticalAlignementType ::= (vat_Top::ε) | (vat_Bottom::ε) | (vat_Justify::ε) | (vat_Distributed::ε) | (vat_Center::ε) | (vat_Automatic::ε) | (vat_JustifyDistributed::ε) ;
CalculationWorkbookType ::= (cwt_automaticCalculation::ε) | (cwt_manualCalculation::ε) | (cwt_semiAutomaticCalculation::ε) ;
ReadingOrderType ::= (rot_RightToLeft::ε) | (rot_LeftToRight::ε) | (rot_Context::ε) ;
HorizontalAlignementType ::= (hat_CenterAcrossSelection::ε) | (hat_Fill::ε) | (hat_Left::ε) | (hat_Right::ε) | (hat_Justify::ε) | (hat_Distributed::ε) | (hat_Center::ε) | (hat_Automatic::ε) | (hat_JustifyDistributed::ε) ;
VisibleType ::= (vt_SheetVisible::ε) | (vt_SheetHidden::ε) | (vt_SheetVeryHidden::ε) ;
ExcelWorksheetTypeType ::= (ewt_Worksheet::ε) | (ewt_Chart::ε) | (ewt_Macro::ε) | (ewt_Dialog::ε) ;
PatternType ::= (pt_None::ε) | (pt_Solid::ε) | (pt_Gray75::ε) | (pt_Gray50::ε) | (pt_Gray25::ε) | (pt_Gray125::ε) | (pt_Gray0625::ε) | (pt_HorzStripe::ε) | (pt_VertStripe::ε) | (pt_ReverseDiagStripe::ε) | (pt_DiagStripe::ε) | (pt_DiagCross::ε) | (pt_ThickDiagCross::ε) | (pt_ThinHorzStripe::ε) | (pt_ThinVertStripe::ε) | (pt_ThinReverseDiagStripe::ε) | (pt_ThinDiagStripe::ε) | (pt_ThinHorzCross::ε) | (pt_ThinDiagCross::ε) ;
OrientationType ::= (ot_Landscape::ε) | (ot_Portrait::ε) ;
VerticalAlignType ::= (vat_None::ε) | (vat_Subscript::ε) | (vat_Superscript::ε) ;
Boolean ::= "true" | "false" ;
CommentsLayoutType ::= (clt_InPlace::ε) | (clt_PrintNone::ε) | (clt_SheetEnd::ε) ;
LineStyleType ::= (lst_None::ε) | (lst_Continuous::ε) | (lst_Dash::ε) | (lst_Dot::ε) | (lst_DashDot::ε) | (lst_DashDotDot::ε) | (lst_SlantDashDot::ε) | (lst_Double::ε) ;
UnderlineType ::= (ut_None::ε) | (ut_Single::ε) | (ut_Double::ε) | (ut_SingleAccounting::ε) | (ut_DoubleAccounting::ε) ;
PositionType ::= (pt_Left::ε) | (pt_Top::ε) | (pt_Right::ε) | (pt_Bottom::ε) | (pt_DiagonalLeft::ε) | (pt_DiagonalRight::ε) ;
EnableSelectionType ::= (est_UnlockedCells::ε) | (est_NoSelection::ε) ;
DisplayDrawingObjectsType ::= (ddot_displayShapes::ε) | (ddot_placeHolders::ε) | (ddot_hideAll::ε) ;
ExcelNumberFormatType ::= (enft_General::ε) | (enft_General_Number::ε) | (enft_General_Date::ε) | (enft_Long_Date::ε) | (enft_Medium_Date::ε) | (enft_Short_Date::ε) | (enft_Long_Time::ε) | (enft_Medium_Time::ε) | (enft_Short_Time::ε) | (enft_Currency::ε) | (enft_Euro_Currency::ε) | (enft_Fixed::ε) | (enft_Standard::ε) | (enft_Percent::ε) | (enft_Scientific::ε) | (enft_Yes_No::ε) | (enft_True_False::ε) | (enft_On_Off::ε) ;
--------------------metamodels::MSOfficeExcel_SpreadsheetMLWorkbookProp.bgf--------------------
CalculationWorkbookType ::= (cwt_automaticCalculation::ε) | (cwt_manualCalculation::ε) | (cwt_semiAutomaticCalculation::ε) ;
Boolean ::= "true" | "false" ;
DisplayDrawingObjectsType ::= (ddot_displayShapes::ε) | (ddot_placeHolders::ε) | (ddot_hideAll::ε) ;
--------------------metamodels::MSOfficeExcel_SpreadsheetMLWorksheetOpt.bgf--------------------
CalculationWorkbookType ::= (cwt_automaticCalculation::ε) | (cwt_manualCalculation::ε) | (cwt_semiAutomaticCalculation::ε) ;
VisibleType ::= (vt_SheetVisible::ε) | (vt_SheetHidden::ε) | (vt_SheetVeryHidden::ε) ;
ExcelWorksheetTypeType ::= (ewt_Worksheet::ε) | (ewt_Chart::ε) | (ewt_Macro::ε) | (ewt_Dialog::ε) ;
Boolean ::= "true" | "false" ;
EnableSelectionType ::= (est_UnlockedCells::ε) | (est_NoSelection::ε) ;
DisplayDrawingObjectsType ::= (ddot_displayShapes::ε) | (ddot_placeHolders::ε) | (ddot_hideAll::ε) ;
--------------------metamodels::MSOfficeWord_WordprocessingMLBasicDef.bgf--------------------
NoteValue ::= (ftn_normal::ε) | (ftn_separator::ε) | (ftn_continuation_separator::ε) | (ftn_continuation_notice::ε) ;
OnOffType ::= (oot_on::ε) | (oot_off::ε) ;
BreakType ::= (bt_page::ε) | (bt_column::ε) | (bt_text_wrapping::ε) ;
Boolean ::= "true" | "false" ;
FldCharTypeProperty ::= (fctp_begin::ε) | (fctp_separate::ε) | (fctp_end::ε) ;
--------------------metamodels::MSOfficeWord_WordprocessingMLSimplified.bgf--------------------
NoteValue ::= (ftn_normal::ε) | (ftn_separator::ε) | (ftn_continuation_separator::ε) | (ftn_continuation_notice::ε) ;
OnOffType ::= (oot_on::ε) | (oot_off::ε) ;
BreakType ::= (bt_page::ε) | (bt_column::ε) | (bt_text_wrapping::ε) ;
Boolean ::= "true" | "false" ;
FldCharTypeProperty ::= (fctp_begin::ε) | (fctp_separate::ε) | (fctp_end::ε) ;
--------------------metamodels::MSOfficeWord_WordprocessingMLStyles.bgf--------------------
JustificationValue ::= (jv_left::ε) | (jv_center::ε) | (jv_right::ε) | (jv_both::ε) ;
NoteValue ::= (ftn_normal::ε) | (ftn_separator::ε) | (ftn_continuation_separator::ε) | (ftn_continuation_notice::ε) ;
UnderlineValues ::= (uv_single::ε) | (uv_words::ε) | (uv_double::ε) | (uv_thick::ε) | (uv_dotted::ε) | (uv_dotted_heavy::ε) | (uv_dash::ε) | (uv_dashed_heavy::ε) | (uv_dash_long::ε) | (uv_dash_long_heavy::ε) | (uv_dot_dash::ε) | (uv_dash_dot_heavy::ε) | (uv_dot_dot_dash::ε) | (uv_dash_dot_dot_heavy::ε) | (uv_wave::ε) | (uv_wavy_heavy::ε) | (uv_wavy_double::ε) | (uv_none::ε) ;
StyleKindValue ::= (skv_paragraph::ε) | (skv_character::ε) | (skv_table::ε) | (skv_list::ε) ;
OnOffType ::= (oot_on::ε) | (oot_off::ε) ;
BreakType ::= (bt_page::ε) | (bt_column::ε) | (bt_text_wrapping::ε) ;
Boolean ::= "true" | "false" ;
VerticalAlignRunType ::= (vart_baseline::ε) | (vart_superscript::ε) | (vart_subscript::ε) ;
FldCharTypeProperty ::= (fctp_begin::ε) | (fctp_separate::ε) | (fctp_end::ε) ;
HighlightColorValues ::= (hcv_black::ε) | (hcv_blue::ε) | (hcv_cyan::ε) | (hcv_green::ε) | (hcv_magenta::ε) | (hcv_red::ε) | (hcv_yellow::ε) | (hcv_white::ε) | (hcv_dark_blue::ε) | (hcv_dark_cyan::ε) | (hcv_dark_green::ε) | (hcv_dark_magenta::ε) | (hcv_dark_red::ε) | (hcv_dark_yellow::ε) | (hcv_dark_gray::ε) | (hcv_light_gray::ε) | (hcv_none::ε) ;
HintType ::= (ht_default::ε) | (ht_fareast::ε) | (ht_cs::ε) ;
--------------------metamodels::MSOfficeWord_WordprocessingMLTableElts.bgf--------------------
NoteValue ::= (ftn_normal::ε) | (ftn_separator::ε) | (ftn_continuation_separator::ε) | (ftn_continuation_notice::ε) ;
OnOffType ::= (oot_on::ε) | (oot_off::ε) ;
BreakType ::= (bt_page::ε) | (bt_column::ε) | (bt_text_wrapping::ε) ;
Boolean ::= "true" | "false" ;
FldCharTypeProperty ::= (fctp_begin::ε) | (fctp_separate::ε) | (fctp_end::ε) ;
--------------------metamodels::MTRANS.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MSVisio_DatadiagramMLBasicDef.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MSVisio_DatadiagramMLSimplified.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MSVisio_DatadiagramMLTextFormat.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MSVisio_DatadiagramMLXForm.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Mantis.bgf--------------------
Boolean ::= "true" | "false" ;
RelationshipType ::= (rt_related to::ε) | (rt_parent of::ε) | (rt_child of::ε) | (rt_duplicate of::ε) | (rt_has duplicate::ε) ;
--------------------metamodels::Matlab.bgf--------------------
TrueFalse ::= (True::ε) | (False::ε) ;
--------------------metamodels::Maude.bgf--------------------
ImportationMode ::= (protecting::ε) | (including::ε) | (extending::ε) ;
--------------------metamodels::Measure.bgf--------------------
ModelKind ::= (KM3::ε) | (UML2::ε) ;
Boolean ::= "true" | "false" ;
ElementKind ::= (metamodel::ε) | (model::ε) | (package::ε) | (interface::ε) | (class::ε) ;
--------------------metamodels::Metrics.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MoMM.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MiningMart_ViewCaseRepresentation.bgf--------------------
Boolean ::= "true" | "false" ;
ParameterType ::= (Value::ε) | (Concept::ε) | (RelationShip::ε) | (FeatureAttribute::ε) ;
--------------------metamodels::MiningMart_ViewDataRepresentation.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::MonitorProgram.bgf--------------------
Direction ::= (in::ε) | (out::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::MySQL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::News.bgf--------------------
Boolean ::= "true" | "false" ;
DayKind ::= (Monday::ε) | (Tuesday::ε) | (Wednesday::ε) | (Thursday::ε) | (Friday::ε) | (Saturday::ε) | (Sunday::ε) ;
--------------------metamodels::OWL.bgf--------------------
ReificationKind ::= (none::ε) | (reifiedOnly::ε) | (reified::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::OpenConf.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (Yes::ε) | (No::ε) | (Accept::ε) | (Reject::ε) | (Unsure::ε) | (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (Compilers::ε) | (Microarchitecture::ε) | (Systems::ε) | (ForwardLookingIdea::ε) ;
--------------------metamodels::PCS.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (Yes::ε) | (No::ε) | (Accept::ε) | (Reject::ε) | (Unsure::ε) | (submitted::ε) | (missing::ε) | (notStarted::ε) | (active::ε) | (finished::ε) | (accepted::ε) | (rejected::ε) | (regular::ε) | (invited::ε) | (lowBid::ε) | (-::ε) | (CONFLICT::ε) | (wantNot::ε) | (highBid::ε) | (Compilers::ε) | (Microarchitecture::ε) | (Systems::ε) | (ForwardLookingIdea::ε) | (1::ε) | (2::ε) | (3::ε) | (4::ε) | (5::ε) | (6::ε) | (7::ε) | (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) ;
--------------------metamodels::PDG.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::PRR.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Perceptory.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Person.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::PluginEclipse.bgf--------------------
Resolution ::= (Mandatory::ε) | (Optional::ε) ;
Boolean ::= "true" | "false" ;
Visibility ::= (Private::ε) | (Reexport::ε) ;
--------------------metamodels::ProMarte.bgf--------------------
RateUnitKinds ::= (kbs::ε) | (MIPS::ε) ;
SizeUnitKinds ::= (bits::ε) | (bytes::ε) | (Mb::ε) | (MB::ε) ;
InstantUnitKinds ::= (TAI::ε) | (UT0::ε) | (UT1::ε) | (UTC::ε) | (TT::ε) | (TDB::ε) | (TCG::ε) | (TCB::ε) | (Sideral::ε) | (Local::ε) ;
Boolean ::= "true" | "false" ;
DurationUnitKinds ::= (ns::ε) | (us::ε) | (ms::ε) | (s::ε) | (min::ε) | (hrs::ε) | (dys::ε) | (wks::ε) | (mos::ε) | (yrs::ε) ;
ProbabilityUnitKinds ::= (us::ε) | (s::ε) ;
SourceKinds ::= (est::ε) | (meas::ε) | (req::ε) | (implicit::ε) | (calc::ε) ;
StatisticalQualifierKinds ::= (max::ε) | (min::ε) | (range::ε) | (mean::ε) | (variance::ε) | (standardDeviation::ε) | (percentil::ε) | (frequency::ε) | (moment::ε) | (distribution::ε) | (instantaneous::ε) ;
DirectionKinds ::= (increasing::ε) | (decreasing::ε) | (undefined::ε) ;
--------------------metamodels::Problem.bgf--------------------
Severity ::= (error::ε) | (warning::ε) | (critic::ε) ;
--------------------metamodels::Program.bgf--------------------
Direction ::= (in::ε) | (out::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::Promenade.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::PtolemyII.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Publication.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::QVT.bgf--------------------
ImportKind ::= (extension::ε) | (access::ε) ;
Boolean ::= "true" | "false" ;
EnforcementMode ::= (Deletion::ε) | (Creation::ε) ;
DirectionKind ::= (in::ε) | (inout::ε) | (out::ε) ;
CollectionKind ::= (OrderedSet::ε) | (Set::ε) | (Bag::ε) | (Sequence::ε) ;
SeverityKind ::= (error::ε) | (fatal::ε) | (warning::ε) ;
--------------------metamodels::QoS.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::QoS_Characteristic.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::RDFS.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::QoS_Profile.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::QoS_Statement.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Relational.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::RelationalDBContent.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::RelationalDBSchema.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Repository.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SBVRvoc.bgf--------------------
EndOperator ::= (given::ε) | (thanone::ε) | (one::ε) | (isobligatorythat::ε) | (ispermittedthat::ε) | (isprohibitedthat::ε) | (isnecessarythat::ε) | (ispossiblethat::ε) | (isimpossiblethat::ε) | (isnotthecasethat::ε) | (least::ε) | (leastone::ε) | (most::ε) | (mostone::ε) | (leastnandatmostm::ε) | (andonlyif::ε) | (ornot::ε) | (not::ε) | (of::ε) ;
Verb ::= (is::ε) | (relevant::ε) | (comprises::ε) | (to::ε) | (work::ε) | (in::ε) | (trades::ε) | (as::ε) | (are::ε) | (accepted::ε) | (generally::ε) | (important::ε) | (across::ε) | (share::ε) | (sets::ε) | (assigned::ε) | (by::ε) | (contains::ε) | (for::ε) | (has::ε) | (specifies::ε) | (specified::ε) ;
Qualif ::= (the::ε) | (The::ε) | (a::ε) | (A::ε) | (an::ε) | (An::ε) | (Each::ε) | (each::ε) | (Some::ε) | (some::ε) | (At::ε) | (at::ε) | (Exactly::ε) | (exactly::ε) ;
ModalVerb ::= (must::ε) | (may::ε) | (never::ε) | (always::ε) ;
Link ::= (of::ε) | (quoteS::ε) ;
Join ::= (that::ε) | (who::ε) ;
Boolean ::= "true" | "false" ;
ConjonctionnalKeyWord ::= (and::ε) | (or::ε) | (if::ε) | (whether::ε) ;
--------------------metamodels::SCADE.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SDM.bgf--------------------
ProcessorArchitectures ::= (x86::ε) | (ia64::ε) | (amd64::ε) | (wow64::ε) | (msil::ε) | (shx::ε) | (arm::ε) | (data::ε) ;
SettingMemberAccess ::= (ReadWrite::ε) | (ReadOnly::ε) | (WriteOnly::ε) ;
RolesList ::= (Host::ε) | (Guest::ε) | (Parent::ε) | (Member::ε) | (Source::ε) | (Dependent::ε) | (Proxy::ε) | (Delegate::ε) | (Client::ε) | (Server::ε) ;
ConstraintEvaluation ::= (Design::ε) | (Never::ε) ;
Boolean ::= "true" | "false" ;
Platform ::= (x86::ε) | (ia64::ε) | (amd64::ε) | (wow64::ε) | (msil::ε) | (shx::ε) | (arm::ε) | (data::ε) | (*::ε) | (neutral::ε) ;
SettingMemberSecure ::= (Always::ε) | (PerInstance::ε) | (Never::ε) ;
--------------------metamodels::SEE_Design.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SPEM.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SPL.bgf--------------------
Direction ::= (inout::ε) | (in::ε) | (out::ε) ;
ControlMethod ::= (deploy::ε) | (undeploy::ε) | (uninvite::ε) | (unregister::ε) | (unsubscribe::ε) ;
FunctionLocation ::= (remote::ε) | (local::ε) ;
SIPMethod ::= (ACK::ε) | (BYE::ε) | (CANCEL::ε) | (INVITE::ε) | (NOTIFY::ε) | (OPTIONS::ε) | (REACK::ε) | (REGISTER::ε) | (REINVITE::ε) | (REREGISTER::ε) | (RESUBSCRIBE::ε) | (SUBSCRIBE::ε) ;
ServerErrorKind ::= (BAD_GATEWAY::ε) | (MESSAGE_TOO_LARGE::ε) | (NOT_IMPLEMENTED::ε) | (SERVER_INTERNAL_ERROR::ε) | (SERVER_TIMEOUT::ε) | (SERVICE_UNAVAILABLE::ε) | (VERSION_NOT_SUPPORTED::ε) ;
GlobalErrorKind ::= (BUSY_EVERYWHERE::ε) | (DECLINE::ε) | (DOES_NOT_EXIST_ANYWHERE::ε) | (NOT_ACCEPTABLE::ε) ;
Boolean ::= "true" | "false" ;
SuccessKind ::= (OK::ε) | (ACCEPTED::ε) ;
SIPHeader ::= (CALL_ID::ε) | (CONTACT::ε) | (CSEQ::ε) | (EVENT::ε) | (FROM::ε) | (MAX_FORWARDS::ε) | (SUBSCRIPTION_STATE::ε) | (TO::ε) | (VIA::ε) ;
Modifier ::= (LIFO::ε) | (FIFO::ε) ;
ClientErrorKind ::= (ADDRESS_INCOMPLETE::ε) | (AMBIGUOUS::ε) | (BAD_EXTENSION::ε) | (BAD_REQUEST::ε) | (BUSY_HERE::ε) | (CALL_OR_TRANSACTION_DOES_NOT_EXIST::ε) | (EXTENSION_REQUIRED::ε) | (FORBIDDEN::ε) | (GONE::ε) | (INTERVAL_TOO_BRIEF::ε) | (LOOP_DETECTED::ε) | (METHOD_NOT_ALLOWED::ε) | (NOT_ACCEPTABLE_HERE::ε) | (NOT_ACCEPTABLE::ε) | (NOT_FOUND::ε) | (PAYMENT_REQUIRED::ε) | (PROXY_AUTHENTICATION_REQUIRED::ε) | (REQUESTURI_TOO_LONG::ε) | (REQUEST_ENTITY_TOO_LARGE::ε) | (REQUEST_PENDING::ε) | (REQUEST_TERMINATED::ε) | (REQUEST_TIMEOUT::ε) | (TEMPORARILY_UNAVAILABLE::ε) | (TOO_MANY_HOPS::ε) | (UNAUTHORIZED::ε) | (UNDECIPHERABLE::ε) | (UNSUPPORTED_MEDIA_TYPE::ε) | (UNSUPPORTED_URI_SCHEME::ε) ;
PrimitiveType ::= (void::ε) | (bool::ε) | (int::ε) | (request::ε) | (response::ε) | (string::ε) | (time::ε) | (uri::ε) ;
RedirectionErrorKind ::= (ALTERNATIVE_SERVICE::ε) | (MOVED_PERMANENTLY::ε) | (MOVED_TEMPORARILY::ε) | (MULTIPLE_CHOICES::ε) | (USE_PROXY::ε) ;
--------------------metamodels::SQLDDL.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SQLDML.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Scilab.bgf--------------------
InOut ::= (in::ε) | (out::ε) ;
PreDef ::= (Preserve::ε) | (Default::ε) ;
--------------------metamodels::SecureUML.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SeminarSchedulingSystem.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::SimpleAirlineDomain.bgf--------------------
Boolean ::= "true" | "false" ;
Genre ::= (male::ε) | (female::ε) ;
--------------------metamodels::SysML.bgf--------------------
Boolean ::= "true" | "false" ;
FlowDirection ::= (in::ε) | (out::ε) | (inout::ε) ;
--------------------metamodels::SimulinkStateFlow.bgf--------------------
Units ::= (alpha::ε) | (beta::ε) ;
TriggerEnum ::= (alpha::ε) | (beta::ε) ;
EnableEnum ::= (alpha::ε) | (beta::ε) ;
--------------------metamodels::SoftwareQualityControl.bgf--------------------
Boolean ::= "true" | "false" ;
BugStatusType ::= (bst_open::ε) | (bst_closed::ε) | (bst_skipped::ε) ;
--------------------metamodels::SyncCharts.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::TextualPathExp.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::Trace.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::USECASE1.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::USECASE2.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::UnifiedOntologyLanguage.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::UsiXML-task.bgf--------------------
BinaryType ::= (Enabling::ε) | (Disabling::ε) | (SuspendResume::ε) | (OrderIndependence::ε) | (IndependentConcurrency::ε) | (ConcurencyWithInformationPassing::ε) | (UnderterministicChoice::ε) | (EnablingWithInformationPassing::ε) ;
UnaryType ::= (Optional::ε) | (Iteration::ε) | (finitIteration::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::WSLink.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::WTIP_SimpleClass.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::WebApplications_AbstractModel.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::WebApplications_ConceptualModel.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::WorkDefinitions.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::XAML-Perspective.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::XAML-ResourceDictionary.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::XMorphLanguage_abstractSyntax.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::XPDL-1.14.bgf--------------------
ProcessTypeKind ::= (None::ε) | (Private::ε) | (Abstract::ε) | (Collaboration::ε) ;
TriggerKind ::= (None::ε) | (Message::ε) | (Timer::ε) | (Rule::ε) | (Link::ε) | (Error::ε) | (Cancel::ε) | (Compensation::ε) | (Terminate::ε) | (Multiple::ε) ;
ExecutionKind ::= (Asynchr::ε) | (Synchr::ε) ;
Boolean ::= "true" | "false" ;
ModeKind ::= (Automatic::ε) | (Manual::ε) ;
ImplementationKind ::= (WebService::ε) | (Other::ε) | (Unspecified::ε) ;
StatusKind ::= (None::ε) | (Ready::ε) | (Active::ε) | (Cancelled::ε) | (Aborting::ε) | (Aborted::ε) | (Completing::ε) | (Completed::ε) ;
AccessLevelKind ::= (Public::ε) | (Private::ε) ;
OrientationKind ::= (Horizontal::ε) | (Vertical::ε) ;
GatewayTypeKind ::= (Xor::ε) | (Or::ε) | (Complex::ε) | (And::ε) ;
AssociationDirectionKind ::= (None::ε) | (To::ε) | (From::ε) | (Both::ε) ;
AdHocOrderingKind ::= (Sequential::ε) | (Parallel::ε) ;
--------------------metamodels::XUL-Interactorl.bgf--------------------
Orients ::= (horizontal::ε) | (vertical::ε) ;
Boolean ::= "true" | "false" ;
--------------------metamodels::cmt.owl.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::confOf.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (male::ε) | (female::ε) ;
--------------------metamodels::confious.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (male::ε) | (female::ε) ;
--------------------metamodels::crs_dr.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (male::ε) | (female::ε) ;
--------------------metamodels::edas.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) ;
--------------------metamodels::ekaw.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) ;
--------------------metamodels::iasted.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) ;
--------------------metamodels::ifc2x3.bgf--------------------
IfcSurfaceSide ::= (BOTH::ε) | (NEGATIVE::ε) | (POSITIVE::ε) ;
IfcEnvironmentalImpactCategoryEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TRANSPORTATION::ε) | (MANUFACTURE::ε) | (INSTALLATION::ε) | (EXTRACTION::ε) | (DISPOSAL::ε) | (COMBINEDVALUE::ε) ;
IfcElectricHeaterTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ELECTRICMATHEATER::ε) | (ELECTRICCABLEHEATER::ε) | (ELECTRICPOINTHEATER::ε) ;
IfcSwitchingDeviceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TOGGLESWITCH::ε) | (SWITCHDISCONNECTOR::ε) | (STARTER::ε) | (EMERGENCYSTOP::ε) | (CONTACTOR::ε) ;
IfcDataOriginEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SIMULATED::ε) | (PREDICTED::ε) | (MEASURED::ε) ;
IfcArithmeticOperatorEnum ::= (SUBTRACT::ε) | (MULTIPLY::ε) | (DIVIDE::ε) | (ADD::ε) ;
IfcTransportElementTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (MOVINGWALKWAY::ε) | (ESCALATOR::ε) | (ELEVATOR::ε) ;
IfcHeatExchangerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SHELLANDTUBE::ε) | (PLATE::ε) ;
IfcDocumentStatusEnum ::= (NOTDEFINED::ε) | (REVISION::ε) | (FINAL::ε) | (FINALDRAFT::ε) | (DRAFT::ε) ;
IfcThermalLoadTypeEnum ::= (NOTDEFINED::ε) | (RADIANT::ε) | (LATENT::ε) | (SENSIBLE::ε) ;
IfcCoolingTowerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (MECHANICALFORCEDDRAFT::ε) | (MECHANICALINDUCEDDRAFT::ε) | (NATURALDRAFT::ε) ;
IfcCoilTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (GASHEATINGCOIL::ε) | (ELECTRICHEATINGCOIL::ε) | (WATERHEATINGCOIL::ε) | (STEAMHEATINGCOIL::ε) | (WATERCOOLINGCOIL::ε) | (DXCOOLINGCOIL::ε) ;
IfcRibPlateDirectionEnum ::= (DIRECTION_Y::ε) | (DIRECTION_X::ε) ;
IfcTransformerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (VOLTAGE::ε) | (FREQUENCY::ε) | (CURRENT::ε) ;
IfcStairFlightTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (FREEFORM::ε) | (CURVED::ε) | (SPIRAL::ε) | (WINDER::ε) | (STRAIGHT::ε) ;
IfcOutletTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (POWEROUTLET::ε) | (COMMUNICATIONSOUTLET::ε) | (AUDIOVISUALOUTLET::ε) ;
IfcUnitaryEquipmentTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ROOFTOPUNIT::ε) | (SPLITSYSTEM::ε) | (AIRCONDITIONINGUNIT::ε) | (AIRHANDLER::ε) ;
IfcSIUnitName ::= (WEBER::ε) | (WATT::ε) | (VOLT::ε) | (TESLA::ε) | (STERADIAN::ε) | (SQUARE_METRE::ε) | (SIEVERT::ε) | (SIEMENS::ε) | (SECOND::ε) | (RADIAN::ε) | (PASCAL::ε) | (OHM::ε) | (NEWTON::ε) | (MOLE::ε) | (METRE::ε) | (LUX::ε) | (LUMEN::ε) | (KELVIN::ε) | (JOULE::ε) | (HERTZ::ε) | (HENRY::ε) | (GRAY::ε) | (GRAM::ε) | (FARAD::ε) | (DEGREE_CELSIUS::ε) | (CUBIC_METRE::ε) | (COULOMB::ε) | (CANDELA::ε) | (BECQUEREL::ε) | (AMPERE::ε) ;
IfcGeometricProjectionEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ELEVATION_VIEW::ε) | (SECTION_VIEW::ε) | (REFLECTED_PLAN_VIEW::ε) | (PLAN_VIEW::ε) | (MODEL_VIEW::ε) | (SKETCH_VIEW::ε) | (GRAPH_VIEW::ε) ;
IfcFanTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PROPELLORAXIAL::ε) | (VANEAXIAL::ε) | (TUBEAXIAL::ε) | (CENTRIFUGALAIRFOIL::ε) | (CENTRIFUGALBACKWARDINCLINEDCURVED::ε) | (CENTRIFUGALRADIAL::ε) | (CENTRIFUGALFORWARDCURVED::ε) ;
IfcTendonTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (COATED::ε) | (BAR::ε) | (WIRE::ε) | (STRAND::ε) ;
IfcStructuralCurveTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (COMPRESSION_MEMBER::ε) | (TENSION_MEMBER::ε) | (CABLE::ε) | (PIN_JOINED_MEMBER::ε) | (RIGID_JOINED_MEMBER::ε) ;
IfcDuctSegmentTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (FLEXIBLESEGMENT::ε) | (RIGIDSEGMENT::ε) ;
IfcAirTerminalBoxTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (VARIABLEFLOWPRESSUREINDEPENDANT::ε) | (VARIABLEFLOWPRESSUREDEPENDANT::ε) | (CONSTANTFLOW::ε) ;
IfcValveTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (STOPCOCK::ε) | (STEAMTRAP::ε) | (SAFETYCUTOFF::ε) | (REGULATING::ε) | (PRESSURERELIEF::ε) | (PRESSUREREDUCING::ε) | (MIXING::ε) | (ISOLATING::ε) | (GASTAP::ε) | (GASCOCK::ε) | (FLUSHING::ε) | (FAUCET::ε) | (DOUBLEREGULATING::ε) | (DOUBLECHECK::ε) | (DRAWOFFCOCK::ε) | (DIVERTING::ε) | (COMMISSIONING::ε) | (CHECK::ε) | (CHANGEOVER::ε) | (ANTIVACUUM::ε) | (AIRRELEASE::ε) ;
IfcRailingTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (BALUSTRADE::ε) | (GUARDRAIL::ε) | (HANDRAIL::ε) ;
IfcCostScheduleTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SCHEDULEOFRATES::ε) | (UNPRICEDBILLOFQUANTITIES::ε) | (PRICEDBILLOFQUANTITIES::ε) | (TENDER::ε) | (ESTIMATE::ε) | (COSTPLAN::ε) | (BUDGET::ε) ;
IfcConstraintEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ADVISORY::ε) | (SOFT::ε) | (HARD::ε) ;
IfcWorkControlTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PLANNED::ε) | (BASELINE::ε) | (ACTUAL::ε) ;
IfcElectricFlowStorageDeviceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (UPS::ε) | (INDUCTORBANK::ε) | (HARMONICFILTER::ε) | (CAPACITORBANK::ε) | (BATTERY::ε) ;
IfcCableCarrierFittingTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TEE::ε) | (REDUCER::ε) | (CROSS::ε) | (BEND::ε) ;
IfcTextPath ::= (DOWN::ε) | (UP::ε) | (RIGHT::ε) | (LEFT::ε) ;
IfcPropertySourceEnum ::= (NOTKNOWN::ε) | (USERDEFINED::ε) | (MEASURED::ε) | (COMMISSIONING::ε) | (ASBUILT::ε) | (SIMULATED::ε) | (DESIGNMINIMUM::ε) | (DESIGNMAXIMUM::ε) | (DESIGN::ε) ;
IfcElementAssemblyTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TRUSS::ε) | (SLAB_FIELD::ε) | (RIGID_FRAME::ε) | (REINFORCEMENT_UNIT::ε) | (GIRDER::ε) | (BRACED_FRAME::ε) | (BEAM_GRID::ε) | (ARCH::ε) | (ACCESSORY_ASSEMBLY::ε) ;
IfcWindowStyleOperationEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TRIPLE_PANEL_HORIZONTAL::ε) | (TRIPLE_PANEL_RIGHT::ε) | (TRIPLE_PANEL_LEFT::ε) | (TRIPLE_PANEL_TOP::ε) | (TRIPLE_PANEL_BOTTOM::ε) | (TRIPLE_PANEL_VERTICAL::ε) | (DOUBLE_PANEL_HORIZONTAL::ε) | (DOUBLE_PANEL_VERTICAL::ε) | (SINGLE_PANEL::ε) ;
IfcEvaporativeCoolerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (INDIRECTDIRECTCOMBINATION::ε) | (INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER::ε) | (INDIRECTEVAPORATIVEWETCOIL::ε) | (INDIRECTEVAPORATIVEPACKAGEAIRCOOLER::ε) | (DIRECTEVAPORATIVEAIRWASHER::ε) | (DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER::ε) | (DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER::ε) | (DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER::ε) | (DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER::ε) ;
IfcPumpTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (VERTICALTURBINE::ε) | (VERTICALINLINE::ε) | (SPLITCASE::ε) | (ENDSUCTION::ε) | (CIRCULATOR::ε) ;
IfcAddressTypeEnum ::= (USERDEFINED::ε) | (DISTRIBUTIONPOINT::ε) | (HOME::ε) | (SITE::ε) | (OFFICE::ε) ;
IfcLogicalOperatorEnum ::= (LOGICALOR::ε) | (LOGICALAND::ε) ;
IfcPipeFittingTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TRANSITION::ε) | (OBSTRUCTION::ε) | (JUNCTION::ε) | (EXIT::ε) | (ENTRY::ε) | (CONNECTOR::ε) | (BEND::ε) ;
IfcAnalysisTheoryTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (FULL_NONLINEAR_THEORY::ε) | (THIRD_ORDER_THEORY::ε) | (SECOND_ORDER_THEORY::ε) | (FIRST_ORDER_THEORY::ε) ;
IfcReinforcingBarRoleEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (RING::ε) | (EDGE::ε) | (PUNCHING::ε) | (STUD::ε) | (LIGATURE::ε) | (SHEAR::ε) | (MAIN::ε) ;
IfcProtectiveDeviceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (VARISTOR::ε) | (RESIDUALCURRENTSWITCH::ε) | (RESIDUALCURRENTCIRCUITBREAKER::ε) | (EARTHFAILUREDEVICE::ε) | (CIRCUITBREAKER::ε) | (FUSEDISCONNECTOR::ε) ;
IfcConnectionTypeEnum ::= (NOTDEFINED::ε) | (ATEND::ε) | (ATSTART::ε) | (ATPATH::ε) ;
IfcBoilerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (STEAM::ε) | (WATER::ε) ;
IfcAirTerminalTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (LINEARDIFFUSER::ε) | (LINEARGRILLE::ε) | (IRIS::ε) | (EYEBALL::ε) | (DIFFUSER::ε) | (REGISTER::ε) | (GRILLE::ε) ;
IfcSectionTypeEnum ::= (TAPERED::ε) | (UNIFORM::ε) ;
IfcDoorPanelPositionEnum ::= (NOTDEFINED::ε) | (RIGHT::ε) | (MIDDLE::ε) | (LEFT::ε) ;
IfcAheadOrBehind ::= (BEHIND::ε) | (AHEAD::ε) ;
IfcObjectiveEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TRIGGERCONDITION::ε) | (SPECIFICATION::ε) | (REQUIREMENT::ε) | (HEALTHANDSAFETY::ε) | (DESIGNINTENT::ε) | (CODECOMPLIANCE::ε) ;
IfcLightEmissionSourceEnum ::= (NOTDEFINED::ε) | (TUNGSTENFILAMENT::ε) | (METALHALIDE::ε) | (MAINVOLTAGEHALOGEN::ε) | (LOWVOLTAGEHALOGEN::ε) | (LOWPRESSURESODIUM::ε) | (LIGHTEMITTINGDIODE::ε) | (HIGHPRESSURESODIUM::ε) | (HIGHPRESSUREMERCURY::ε) | (FLUORESCENT::ε) | (COMPACTFLUORESCENT::ε) ;
IfcInventoryTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (FURNITUREINVENTORY::ε) | (SPACEINVENTORY::ε) | (ASSETINVENTORY::ε) ;
IfcElectricMotorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SYNCHRONOUS::ε) | (RELUCTANCESYNCHRONOUS::ε) | (POLYPHASE::ε) | (INDUCTION::ε) | (DC::ε) ;
IfcJunctionBoxTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) ;
IfcPileConstructionEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PREFAB_STEEL::ε) | (PRECAST_CONCRETE::ε) | (COMPOSITE::ε) | (CAST_IN_PLACE::ε) ;
IfcResourceConsumptionEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (NOTOCCUPIED::ε) | (PARTIALLYOCCUPIED::ε) | (OCCUPIED::ε) | (NOTCONSUMED::ε) | (PARTIALLYCONSUMED::ε) | (CONSUMED::ε) ;
IfcAlarmTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WHISTLE::ε) | (SIREN::ε) | (MANUALPULLBOX::ε) | (LIGHT::ε) | (BREAKGLASSBUTTON::ε) | (BELL::ε) ;
IfcBSplineCurveForm ::= (UNSPECIFIED::ε) | (HYPERBOLIC_ARC::ε) | (PARABOLIC_ARC::ε) | (ELLIPTIC_ARC::ε) | (CIRCULAR_ARC::ε) | (POLYLINE_FORM::ε) ;
IfcCompressorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TWINSCREW::ε) | (SINGLESCREW::ε) | (ROTARYVANE::ε) | (ROLLINGPISTON::ε) | (WELDEDSHELLHERMETIC::ε) | (SEMIHERMETIC::ε) | (HERMETIC::ε) | (OPENTYPE::ε) | (BOOSTER::ε) | (SINGLESTAGE::ε) | (TROCHOIDAL::ε) | (SCROLL::ε) | (ROTARY::ε) | (RECIPROCATING::ε) | (DYNAMIC::ε) ;
IfcChillerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (HEATRECOVERY::ε) | (WATERCOOLED::ε) | (AIRCOOLED::ε) ;
IfcGlobalOrLocalEnum ::= (LOCAL_COORDS::ε) | (GLOBAL_COORDS::ε) ;
IfcStairTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TWO_CURVED_RUN_STAIR::ε) | (CURVED_RUN_STAIR::ε) | (DOUBLE_RETURN_STAIR::ε) | (SPIRAL_STAIR::ε) | (THREE_QUARTER_TURN_STAIR::ε) | (THREE_QUARTER_WINDING_STAIR::ε) | (TWO_QUARTER_TURN_STAIR::ε) | (TWO_QUARTER_WINDING_STAIR::ε) | (HALF_TURN_STAIR::ε) | (HALF_WINDING_STAIR::ε) | (QUARTER_TURN_STAIR::ε) | (QUARTER_WINDING_STAIR::ε) | (TWO_STRAIGHT_RUN_STAIR::ε) | (STRAIGHT_RUN_STAIR::ε) ;
IfcSlabTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (BASESLAB::ε) | (LANDING::ε) | (ROOF::ε) | (FLOOR::ε) ;
IfcSensorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TEMPERATURESENSOR::ε) | (SOUNDSENSOR::ε) | (SMOKESENSOR::ε) | (PRESSURESENSOR::ε) | (MOVEMENTSENSOR::ε) | (MOISTURESENSOR::ε) | (LIGHTSENSOR::ε) | (HUMIDITYSENSOR::ε) | (HEATSENSOR::ε) | (GASSENSOR::ε) | (FLOWSENSOR::ε) | (FIRESENSOR::ε) | (CO2SENSOR::ε) ;
IfcCurrencyEnum ::= (NOK::ε) | (ZWD::ε) | (ZAR::ε) | (XEU::ε) | (VND::ε) | (VEB::ε) | (USD::ε) | (TWD::ε) | (TTD::ε) | (TRL::ε) | (THB::ε) | (SKP::ε) | (SGD::ε) | (SEK::ε) | (SCR::ε) | (SAR::ε) | (RUR::ε) | (QAR::ε) | (PTN::ε) | (PLN::ε) | (PKR::ε) | (PHP::ε) | (PGK::ε) | (OMR::ε) | (NZD::ε) | (NLG::ε) | (MYR::ε) | (MXN::ε) | (MUR::ε) | (MTL::ε) | (LUF::ε) | (LKR::ε) | (KYD::ε) | (KWD::ε) | (KRW::ε) | (KES::ε) | (JPY::ε) | (JOD::ε) | (JMD::ε) | (ITL::ε) | (IRP::ε) | (INR::ε) | (ILS::ε) | (IDR::ε) | (ICK::ε) | (HUF::ε) | (HKD::ε) | (GRX::ε) | (GMD::ε) | (GIP::ε) | (GBP::ε) | (FRF::ε) | (FKP::ε) | (FJD::ε) | (FIM::ε) | (FAK::ε) | (EUR::ε) | (EST::ε) | (EGL::ε) | (DKK::ε) | (DEM::ε) | (DDP::ε) | (CZK::ε) | (CYS::ε) | (CNY::ε) | (CLP::ε) | (CHF::ε) | (CBD::ε) | (CAD::ε) | (BZD::ε) | (BWP::ε) | (BSD::ε) | (BRL::ε) | (BND::ε) | (BMD::ε) | (BHD::ε) | (BGL::ε) | (BEG::ε) | (BBD::ε) | (AUD::ε) | (ATS::ε) | (AES::ε) | (AED::ε) ;
IfcCableSegmentTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (CONDUCTORSEGMENT::ε) | (CABLESEGMENT::ε) ;
IfcFlowInstrumentTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (VOLTMETER_RMS::ε) | (VOLTMETER_PEAK::ε) | (PHASEANGLEMETER::ε) | (POWERFACTORMETER::ε) | (FREQUENCYMETER::ε) | (AMMETER::ε) | (THERMOMETER::ε) | (PRESSUREGAUGE::ε) ;
IfcElementCompositionEnum ::= (PARTIAL::ε) | (ELEMENT::ε) | (COMPLEX::ε) ;
IfcThermalLoadSourceEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (INFILTRATION::ε) | (RELATIVEHUMIDITY::ε) | (DRYBULBTEMPERATURE::ε) | (AIREXCHANGERATE::ε) | (EXHAUSTAIR::ε) | (RECIRCULATEDAIR::ε) | (VENTILATIONOUTSIDEAIR::ε) | (VENTILATIONINDOORAIR::ε) | (EQUIPMENT::ε) | (LIGHTING::ε) | (PEOPLE::ε) ;
IfcPileTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SUPPORT::ε) | (FRICTION::ε) | (COHESION::ε) ;
IfcLoadGroupTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (LOAD_COMBINATION::ε) | (LOAD_COMBINATION_GROUP::ε) | (LOAD_CASE::ε) | (LOAD_GROUP::ε) ;
IfcFireSuppressionTerminalTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SPRINKLERDEFLECTOR::ε) | (SPRINKLER::ε) | (HOSEREEL::ε) | (FIREHYDRANT::ε) | (BREECHINGINLET::ε) ;
IfcWindowStyleConstructionEnum ::= (NOTDEFINED::ε) | (OTHER_CONSTRUCTION::ε) | (PLASTIC::ε) | (ALUMINIUM_WOOD::ε) | (WOOD::ε) | (STEEL::ε) | (HIGH_GRADE_STEEL::ε) | (ALUMINIUM::ε) ;
IfcCableCarrierSegmentTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (CONDUITSEGMENT::ε) | (CABLETRUNKINGSEGMENT::ε) | (CABLETRAYSEGMENT::ε) | (CABLELADDERSEGMENT::ε) ;
IfcUnitEnum ::= (USERDEFINED::ε) | (VOLUMEUNIT::ε) | (TIMEUNIT::ε) | (THERMODYNAMICTEMPERATUREUNIT::ε) | (SOLIDANGLEUNIT::ε) | (RADIOACTIVITYUNIT::ε) | (PRESSUREUNIT::ε) | (POWERUNIT::ε) | (PLANEANGLEUNIT::ε) | (MASSUNIT::ε) | (MAGNETICFLUXUNIT::ε) | (MAGNETICFLUXDENSITYUNIT::ε) | (LUMINOUSINTENSITYUNIT::ε) | (LUMINOUSFLUXUNIT::ε) | (LENGTHUNIT::ε) | (INDUCTANCEUNIT::ε) | (ILLUMINANCEUNIT::ε) | (FREQUENCYUNIT::ε) | (FORCEUNIT::ε) | (ENERGYUNIT::ε) | (ELECTRICVOLTAGEUNIT::ε) | (ELECTRICRESISTANCEUNIT::ε) | (ELECTRICCURRENTUNIT::ε) | (ELECTRICCONDUCTANCEUNIT::ε) | (ELECTRICCHARGEUNIT::ε) | (ELECTRICCAPACITANCEUNIT::ε) | (DOSEEQUIVALENTUNIT::ε) | (AREAUNIT::ε) | (AMOUNTOFSUBSTANCEUNIT::ε) | (ABSORBEDDOSEUNIT::ε) ;
IfcDoorStyleOperationEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ROLLINGUP::ε) | (REVOLVING::ε) | (DOUBLE_DOOR_FOLDING::ε) | (FOLDING_TO_RIGHT::ε) | (FOLDING_TO_LEFT::ε) | (DOUBLE_DOOR_SLIDING::ε) | (SLIDING_TO_RIGHT::ε) | (SLIDING_TO_LEFT::ε) | (DOUBLE_DOOR_DOUBLE_SWING::ε) | (DOUBLE_SWING_RIGHT::ε) | (DOUBLE_SWING_LEFT::ε) | (DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT::ε) | (DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT::ε) | (DOUBLE_DOOR_SINGLE_SWING::ε) | (SINGLE_SWING_RIGHT::ε) | (SINGLE_SWING_LEFT::ε) ;
IfcElectricGeneratorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) ;
IfcCondenserTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (EVAPORATIVECOOLED::ε) | (AIRCOOLED::ε) | (WATERCOOLEDBRAZEDPLATE::ε) | (WATERCOOLEDTUBEINTUBE::ε) | (WATERCOOLEDSHELLCOIL::ε) | (WATERCOOLEDSHELLTUBE::ε) ;
IfcFootingTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (STRIP_FOOTING::ε) | (PILE_CAP::ε) | (PAD_FOOTING::ε) | (FOOTING_BEAM::ε) ;
IfcDocumentConfidentialityEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PERSONAL::ε) | (CONFIDENTIAL::ε) | (RESTRICTED::ε) | (PUBLIC::ε) ;
IfcReinforcingBarSurfaceEnum ::= (TEXTURED::ε) | (PLAIN::ε) ;
IfcSoundScaleEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (NR::ε) | (NC::ε) | (DBC::ε) | (DBB::ε) | (DBA::ε) ;
IfcProfileTypeEnum ::= (AREA::ε) | (CURVE::ε) ;
IfcRoleEnum ::= (USERDEFINED::ε) | (RESELLER::ε) | (FIELDCONSTRUCTIONMANAGER::ε) | (CONSTRUCTIONMANAGER::ε) | (CONSULTANT::ε) | (OWNER::ε) | (ENGINEER::ε) | (COMISSIONINGENGINEER::ε) | (CIVILENGINEER::ε) | (FACILITIESMANAGER::ε) | (PROJECTMANAGER::ε) | (ELECTRICALENGINEER::ε) | (MECHANICALENGINEER::ε) | (BUILDINGOPERATOR::ε) | (BUILDINGOWNER::ε) | (CLIENT::ε) | (COSTENGINEER::ε) | (STRUCTURALENGINEER::ε) | (ARCHITECT::ε) | (SUBCONTRACTOR::ε) | (CONTRACTOR::ε) | (MANUFACTURER::ε) | (SUPPLIER::ε) ;
IfcControllerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TWOPOSITION::ε) | (TIMEDTWOPOSITION::ε) | (PROPORTIONALINTEGRALDERIVATIVE::ε) | (PROPORTIONALINTEGRAL::ε) | (PROPORTIONAL::ε) | (FLOATING::ε) ;
IfcMemberTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (STUD::ε) | (STRUT::ε) | (STRINGER::ε) | (RAFTER::ε) | (PURLIN::ε) | (POST::ε) | (PLATE::ε) | (MULLION::ε) | (MEMBER::ε) | (COLLAR::ε) | (CHORD::ε) | (BRACE::ε) ;
IfcSanitaryTerminalTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WCSEAT::ε) | (WASHHANDBASIN::ε) | (URINAL::ε) | (TOILETPAN::ε) | (SANITARYFOUNTAIN::ε) | (SINK::ε) | (SHOWER::ε) | (CISTERN::ε) | (BIDET::ε) | (BATH::ε) ;
IfcPipeSegmentTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SPOOL::ε) | (GUTTER::ε) | (RIGIDSEGMENT::ε) | (FLEXIBLESEGMENT::ε) ;
IfcStackTerminalTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (RAINWATERHOPPER::ε) | (COWL::ε) | (BIRDCAGE::ε) ;
IfcBenchmarkEnum ::= (NOTEQUALTO::ε) | (EQUALTO::ε) | (LESSTHANOREQUALTO::ε) | (LESSTHAN::ε) | (GREATERTHANOREQUALTO::ε) | (GREATERTHAN::ε) ;
IfcDirectionSenseEnum ::= (NEGATIVE::ε) | (POSITIVE::ε) ;
IfcLightFixtureTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (DIRECTIONSOURCE::ε) | (POINTSOURCE::ε) ;
IfcRampTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SPIRAL_RAMP::ε) | (HALF_TURN_RAMP::ε) | (TWO_QUARTER_TURN_RAMP::ε) | (QUARTER_TURN_RAMP::ε) | (TWO_STRAIGHT_RUN_RAMP::ε) | (STRAIGHT_RUN_RAMP::ε) ;
IfcInternalOrExternalEnum ::= (NOTDEFINED::ε) | (EXTERNAL::ε) | (INTERNAL::ε) ;
IfcEnergySequenceEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (AUXILIARY::ε) | (TERTIARY::ε) | (SECONDARY::ε) | (PRIMARY::ε) ;
IfcDamperTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (FUMEHOODEXHAUST::ε) | (BALANCINGDAMPER::ε) | (GRAVITYRELIEFDAMPER::ε) | (GRAVITYDAMPER::ε) | (BLASTDAMPER::ε) | (RELIEFDAMPER::ε) | (BACKDRAFTDAMPER::ε) | (FIRESMOKEDAMPER::ε) | (SMOKEDAMPER::ε) | (FIREDAMPER::ε) | (CONTROLDAMPER::ε) ;
IfcFlowDirectionEnum ::= (NOTDEFINED::ε) | (SOURCEANDSINK::ε) | (SINK::ε) | (SOURCE::ε) ;
IfcPlateTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SHEET::ε) | (CURTAIN_PANEL::ε) ;
IfcProjectedOrTrueLengthEnum ::= (TRUE_LENGTH::ε) | (PROJECTED_LENGTH::ε) ;
IfcStructuralSurfaceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SHELL::ε) | (MEMBRANE_ELEMENT::ε) | (BENDING_ELEMENT::ε) ;
IfcElectricApplianceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WATERCOOLER::ε) | (WATERHEATER::ε) | (WASHINGMACHINE::ε) | (VENDINGMACHINE::ε) | (TV::ε) | (TUMBLEDRYER::ε) | (TELEPHONE::ε) | (SCANNER::ε) | (RADIANTHEATER::ε) | (REFRIGERATOR::ε) | (PRINTER::ε) | (PHOTOCOPIER::ε) | (MICROWAVE::ε) | (INDIRECTWATERHEATER::ε) | (HANDDRYER::ε) | (FRIDGE_FREEZER::ε) | (FREEZER::ε) | (FREESTANDINGFAN::ε) | (FACSIMILE::ε) | (ELECTRICHEATER::ε) | (ELECTRICCOOKER::ε) | (DISHWASHER::ε) | (DIRECTWATERHEATER::ε) | (COMPUTER::ε) ;
IfcVibrationIsolatorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SPRING::ε) | (COMPRESSION::ε) ;
IfcLightDistributionCurveEnum ::= (NOTDEFINED::ε) | (TYPE_C::ε) | (TYPE_B::ε) | (TYPE_A::ε) ;
IfcSpaceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) ;
IfcWindowPanelOperationEnum ::= (NOTDEFINED::ε) | (OTHEROPERATION::ε) | (FIXEDCASEMENT::ε) | (REMOVABLECASEMENT::ε) | (SLIDINGVERTICAL::ε) | (SLIDINGHORIZONTAL::ε) | (PIVOTVERTICAL::ε) | (PIVOTHORIZONTAL::ε) | (BOTTOMHUNG::ε) | (TOPHUNG::ε) | (TILTANDTURNLEFTHAND::ε) | (TILTANDTURNRIGHTHAND::ε) | (SIDEHUNGLEFTHAND::ε) | (SIDEHUNGRIGHTHAND::ε) ;
IfcActuatorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (THERMOSTATICACTUATOR::ε) | (PNEUMATICACTUATOR::ε) | (HYDRAULICACTUATOR::ε) | (HANDOPERATEDACTUATOR::ε) | (ELECTRICACTUATOR::ε) ;
IfcFilterTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WATERFILTER::ε) | (STRAINER::ε) | (OILFILTER::ε) | (ODORFILTER::ε) | (AIRPARTICLEFILTER::ε) ;
IfcCooledBeamTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PASSIVE::ε) | (ACTIVE::ε) ;
IfcServiceLifeFactorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (G_MAINTENANCELEVEL::ε) | (F_INUSECONDITIONS::ε) | (E_OUTDOORENVIRONMENT::ε) | (D_INDOORENVIRONMENT::ε) | (C_WORKEXECUTIONLEVEL::ε) | (B_DESIGNLEVEL::ε) | (A_QUALITYOFCOMPONENTS::ε) ;
IfcPermeableCoveringOperationEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SCREEN::ε) | (LOUVER::ε) | (GRILL::ε) ;
IfcActionSourceTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (BRAKES::ε) | (RAIN::ε) | (WAVE::ε) | (CURRENT::ε) | (ICE::ε) | (BUOYANCY::ε) | (LACK_OF_FIT::ε) | (CREEP::ε) | (SHRINKAGE::ε) | (SYSTEM_IMPERFECTION::ε) | (PROPPING::ε) | (ERECTION::ε) | (TRANSPORT::ε) | (IMPACT::ε) | (IMPULSE::ε) | (FIRE::ε) | (EARTHQUAKE_E::ε) | (TEMPERATURE_T::ε) | (SETTLEMENT_U::ε) | (PRESTRESSING_P::ε) | (WIND_W::ε) | (SNOW_S::ε) | (LIVE_LOAD_Q::ε) | (COMPLETION_G1::ε) | (DEAD_LOAD_G::ε) ;
IfcCurtainWallTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) ;
IfcFlowMeterTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WATERMETER::ε) | (OILMETER::ε) | (GASMETER::ε) | (FLOWMETER::ε) | (ENERGYMETER::ε) | (ELECTRICMETER::ε) ;
IfcTimeSeriesDataTypeEnum ::= (NOTDEFINED::ε) | (PIECEWISECONTINUOUS::ε) | (PIECEWISECONSTANT::ε) | (PIECEWISEBINARY::ε) | (DISCRETEBINARY::ε) | (DISCRETE::ε) | (CONTINUOUS::ε) ;
IfcSIPrefix ::= (ATTO::ε) | (FEMTO::ε) | (PICO::ε) | (NANO::ε) | (MICRO::ε) | (MILLI::ε) | (CENTI::ε) | (DECI::ε) | (DECA::ε) | (HECTO::ε) | (KILO::ε) | (MEGA::ε) | (GIGA::ε) | (TERA::ε) | (PETA::ε) | (EXA::ε) ;
IfcTankTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PRESSUREVESSEL::ε) | (EXPANSION::ε) | (SECTIONAL::ε) | (PREFORMED::ε) ;
IfcAirToAirHeatRecoveryTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (THERMOSIPHONCOILTYPEHEATEXCHANGERS::ε) | (THERMOSIPHONSEALEDTUBEHEATEXCHANGERS::ε) | (TWINTOWERENTHALPYRECOVERYLOOPS::ε) | (HEATPIPE::ε) | (RUNAROUNDCOILLOOP::ε) | (ROTARYWHEEL::ε) | (FIXEDPLATEPARALLELFLOWEXCHANGER::ε) | (FIXEDPLATECROSSFLOWEXCHANGER::ε) | (FIXEDPLATECOUNTERFLOWEXCHANGER::ε) ;
IfcGasTerminalTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (GASBURNER::ε) | (GASBOOSTER::ε) | (GASAPPLIANCE::ε) ;
IfcTransitionCode ::= (CONTSAMEGRADIENTSAMECURVATURE::ε) | (CONTSAMEGRADIENT::ε) | (CONTINUOUS::ε) | (DISCONTINUOUS::ε) ;
IfcSequenceEnum ::= (NOTDEFINED::ε) | (FINISH_FINISH::ε) | (FINISH_START::ε) | (START_FINISH::ε) | (START_START::ε) ;
IfcElectricTimeControlTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (RELAY::ε) | (TIMEDELAY::ε) | (TIMECLOCK::ε) ;
IfcProjectOrderRecordTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WORK::ε) | (PURCHASE::ε) | (MOVE::ε) | (MAINTENANCE::ε) | (CHANGE::ε) ;
IfcBooleanOperator ::= (DIFFERENCE::ε) | (INTERSECTION::ε) | (UNION::ε) ;
IfcElectricDistributionPointFunctionEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SWITCHBOARD::ε) | (MOTORCONTROLCENTRE::ε) | (MIMICPANEL::ε) | (INDICATORPANEL::ε) | (GASDETECTORPANEL::ε) | (DISTRIBUTIONBOARD::ε) | (CONTROLPANEL::ε) | (CONSUMERUNIT::ε) | (ALARMPANEL::ε) ;
IfcHumidifierTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ASSISTEDSTEAM::ε) | (ASSISTEDBUTANE::ε) | (ASSISTEDPROPANE::ε) | (ASSISTEDNATURALGAS::ε) | (ASSISTEDELECTRIC::ε) | (ADIABATICCOMPRESSEDAIRNOZZLE::ε) | (ADIABATICRIGIDMEDIA::ε) | (ADIABATICULTRASONIC::ε) | (ADIABATICATOMIZING::ε) | (ADIABATICWETTEDELEMENT::ε) | (ADIABATICPAN::ε) | (ADIABATICAIRWASHER::ε) | (STEAMINJECTION::ε) ;
IfcTimeSeriesScheduleTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (DAILY::ε) | (WEEKLY::ε) | (MONTHLY::ε) | (ANNUAL::ε) ;
IfcDerivedUnitEnum ::= (USERDEFINED::ε) | (WARPINGMOMENTUNIT::ε) | (WARPINGCONSTANTUNIT::ε) | (THERMALEXPANSIONCOEFFICIENTUNIT::ε) | (TEMPERATUREGRADIENTUNIT::ε) | (SOUNDPRESSUREUNIT::ε) | (SOUNDPOWERUNIT::ε) | (SECTIONMODULUSUNIT::ε) | (SECTIONAREAINTEGRALUNIT::ε) | (ROTATIONALMASSUNIT::ε) | (PHUNIT::ε) | (MODULUSOFROTATIONALSUBGRADEREACTIONUNIT::ε) | (MODULUSOFLINEARSUBGRADEREACTIONUNIT::ε) | (MASSPERLENGTHUNIT::ε) | (LUMINOUSINTENSITYDISTRIBUTIONUNIT::ε) | (IONCONCENTRATIONUNIT::ε) | (HEATINGVALUEUNIT::ε) | (CURVATUREUNIT::ε) | (ACCELERATIONUNIT::ε) | (MODULUSOFSUBGRADEREACTIONUNIT::ε) | (ROTATIONALSTIFFNESSUNIT::ε) | (LINEARSTIFFNESSUNIT::ε) | (SHEARMODULUSUNIT::ε) | (MODULUSOFELASTICITYUNIT::ε) | (PLANARFORCEUNIT::ε) | (LINEARFORCEUNIT::ε) | (LINEARMOMENTUNIT::ε) | (MOMENTOFINERTIAUNIT::ε) | (TORQUEUNIT::ε) | (ROTATIONALFREQUENCYUNIT::ε) | (VOLUMETRICFLOWRATEUNIT::ε) | (VAPORPERMEABILITYUNIT::ε) | (THERMALTRANSMITTANCEUNIT::ε) | (THERMALRESISTANCEUNIT::ε) | (THERMALCONDUCTANCEUNIT::ε) | (THERMALADMITTANCEUNIT::ε) | (SPECIFICHEATCAPACITYUNIT::ε) | (MOLECULARWEIGHTUNIT::ε) | (MOISTUREDIFFUSIVITYUNIT::ε) | (MASSFLOWRATEUNIT::ε) | (MASSDENSITYUNIT::ε) | (LINEARVELOCITYUNIT::ε) | (KINEMATICVISCOSITYUNIT::ε) | (ISOTHERMALMOISTURECAPACITYUNIT::ε) | (INTEGERCOUNTRATEUNIT::ε) | (HEATFLUXDENSITYUNIT::ε) | (DYNAMICVISCOSITYUNIT::ε) | (COMPOUNDPLANEANGLEUNIT::ε) | (ANGULARVELOCITYUNIT::ε) ;
IfcAssemblyPlaceEnum ::= (NOTDEFINED::ε) | (FACTORY::ε) | (SITE::ε) ;
IfcEvaporatorTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SHELLANDCOIL::ε) | (FLOODEDSHELLANDTUBE::ε) | (DIRECTEXPANSIONBRAZEDPLATE::ε) | (DIRECTEXPANSIONTUBEINTUBE::ε) | (DIRECTEXPANSIONSHELLANDTUBE::ε) ;
IfcLampTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TUNGSTENFILAMENT::ε) | (METALHALIDE::ε) | (HIGHPRESSURESODIUM::ε) | (HIGHPRESSUREMERCURY::ε) | (FLUORESCENT::ε) | (COMPACTFLUORESCENT::ε) ;
IfcWindowPanelPositionEnum ::= (NOTDEFINED::ε) | (TOP::ε) | (BOTTOM::ε) | (RIGHT::ε) | (MIDDLE::ε) | (LEFT::ε) ;
IfcDimensionExtentUsage ::= (TARGET::ε) | (ORIGIN::ε) ;
IfcColumnTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (COLUMN::ε) ;
IfcSurfaceTextureEnum ::= (NOTDEFINED::ε) | (TRANSPARENCYMAP::ε) | (TEXTURE::ε) | (SPECULAR::ε) | (SHININESS::ε) | (SELFILLUMINATION::ε) | (REFLECTION::ε) | (OPACITY::ε) | (BUMP::ε) ;
IfcRoofTypeEnum ::= (NOTDEFINED::ε) | (FREEFORM::ε) | (DOME_ROOF::ε) | (PAVILION_ROOF::ε) | (BUTTERFLY_ROOF::ε) | (RAINBOW_ROOF::ε) | (BARREL_ROOF::ε) | (MANSARD_ROOF::ε) | (GAMBREL_ROOF::ε) | (HIPPED_GABLE_ROOF::ε) | (HIP_ROOF::ε) | (GABLE_ROOF::ε) | (SHED_ROOF::ε) | (FLAT_ROOF::ε) ;
IfcDuctSilencerTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ROUND::ε) | (RECTANGULAR::ε) | (FLATOVAL::ε) ;
IfcDuctFittingTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TRANSITION::ε) | (OBSTRUCTION::ε) | (JUNCTION::ε) | (EXIT::ε) | (ENTRY::ε) | (CONNECTOR::ε) | (BEND::ε) ;
IfcCoveringTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WRAPPING::ε) | (SLEEVING::ε) | (MEMBRANE::ε) | (INSULATION::ε) | (ROOFING::ε) | (CLADDING::ε) | (FLOORING::ε) | (CEILING::ε) ;
IfcWallTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PLUMBINGWALL::ε) | (ELEMENTEDWALL::ε) | (SHEAR::ε) | (POLYGONAL::ε) | (STANDARD::ε) ;
IfcLayerSetDirectionEnum ::= (AXIS3::ε) | (AXIS2::ε) | (AXIS1::ε) ;
IfcProcedureTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (STARTUP::ε) | (SHUTDOWN::ε) | (DIAGNOSTIC::ε) | (CALIBRATION::ε) | (ADVICE_WARNING::ε) | (ADVICE_NOTE::ε) | (ADVICE_CAUTION::ε) ;
IfcServiceLifeTypeEnum ::= (REFERENCESERVICELIFE::ε) | (PESSIMISTICREFERENCESERVICELIFE::ε) | (OPTIMISTICREFERENCESERVICELIFE::ε) | (EXPECTEDSERVICELIFE::ε) | (ACTUALSERVICELIFE::ε) ;
IfcObjectTypeEnum ::= (NOTDEFINED::ε) | (PROJECT::ε) | (GROUP::ε) | (ACTOR::ε) | (RESOURCE::ε) | (CONTROL::ε) | (PROCESS::ε) | (PRODUCT::ε) ;
IfcOccupantTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (TENANT::ε) | (OWNER::ε) | (LETTINGAGENT::ε) | (LESSOR::ε) | (LESSEE::ε) | (ASSIGNOR::ε) | (ASSIGNEE::ε) ;
IfcTrimmingPreference ::= (UNSPECIFIED::ε) | (PARAMETER::ε) | (CARTESIAN::ε) ;
IfcSpaceHeaterTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (UNITHEATER::ε) | (FINNEDTUBEUNIT::ε) | (BASEBOARDHEATER::ε) | (CONVECTOR::ε) | (TUBULARRADIATOR::ε) | (PANELRADIATOR::ε) | (SECTIONALRADIATOR::ε) ;
IfcDoorPanelOperationEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (ROLLINGUP::ε) | (REVOLVING::ε) | (FOLDING::ε) | (SLIDING::ε) | (DOUBLE_ACTING::ε) | (SWINGING::ε) ;
IfcElectricCurrentEnum ::= (NOTDEFINED::ε) | (DIRECT::ε) | (ALTERNATING::ε) ;
IfcActionTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (EXTRAORDINARY_A::ε) | (VARIABLE_Q::ε) | (PERMANENT_G::ε) ;
IfcProjectOrderTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WORKORDER::ε) | (PURCHASEORDER::ε) | (MOVEORDER::ε) | (MAINTENANCEWORKORDER::ε) | (CHANGEORDER::ε) ;
IfcBeamTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (T_BEAM::ε) | (LINTEL::ε) | (JOIST::ε) | (BEAM::ε) ;
IfcDoorStyleConstructionEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (PLASTIC::ε) | (ALUMINIUM_PLASTIC::ε) | (ALUMINIUM_WOOD::ε) | (WOOD::ε) | (STEEL::ε) | (HIGH_GRADE_STEEL::ε) | (ALUMINIUM::ε) ;
IfcChangeActionEnum ::= (MODIFIEDDELETED::ε) | (MODIFIEDADDED::ε) | (DELETED::ε) | (ADDED::ε) | (MODIFIED::ε) | (NOCHANGE::ε) ;
IfcStateEnum ::= (READONLYLOCKED::ε) | (READWRITELOCKED::ε) | (LOCKED::ε) | (READONLY::ε) | (READWRITE::ε) ;
IfcPhysicalOrVirtualEnum ::= (NOTDEFINED::ε) | (VIRTUAL::ε) | (PHYSICAL::ε) ;
IfcWasteTerminalTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (WASTETRAP::ε) | (WASTEDISPOSALUNIT::ε) | (ROOFDRAIN::ε) | (PETROLINTERCEPTOR::ε) | (OILINTERCEPTOR::ε) | (GREASEINTERCEPTOR::ε) | (GULLYTRAP::ε) | (GULLYSUMP::ε) | (FLOORWASTE::ε) | (FLOORTRAP::ε) ;
IfcReflectanceMethodEnum ::= (NOTDEFINED::ε) | (STRAUSS::ε) | (PLASTIC::ε) | (PHONG::ε) | (MIRROR::ε) | (METAL::ε) | (MATT::ε) | (GLASS::ε) | (FLAT::ε) | (BLINN::ε) ;
IfcMotorConnectionTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (DIRECTDRIVE::ε) | (COUPLING::ε) | (BELTDRIVE::ε) ;
IfcTubeBundleTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (FINNED::ε) ;
IfcBuildingElementProxyTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) ;
IfcRampFlightTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (SPIRAL::ε) | (STRAIGHT::ε) ;
IfcDistributionChamberElementTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (VALVECHAMBER::ε) | (TRENCH::ε) | (SUMP::ε) | (METERCHAMBER::ε) | (MANHOLE::ε) | (INSPECTIONPIT::ε) | (INSPECTIONCHAMBER::ε) | (FORMEDDUCT::ε) ;
IfcAnalysisModelTypeEnum ::= (NOTDEFINED::ε) | (USERDEFINED::ε) | (LOADING_3D::ε) | (OUT_PLANE_LOADING_2D::ε) | (IN_PLANE_LOADING_2D::ε) ;
--------------------metamodels::paperdyne.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (submitted::ε) | (missing::ε) | (notStarted::ε) | (active::ε) | (finished::ε) | (accepted::ε) | (rejected::ε) | (regular::ε) | (invited::ε) | (lowBid::ε) | (-::ε) | (CONFLICT::ε) | (wantNot::ε) | (highBid::ε) | (Yes::ε) | (No::ε) | (Compilers::ε) | (Microarchitecture::ε) | (Systems::ε) | (ForwardLookingIdea::ε) | (Accept::ε) | (Reject::ε) | (Unsure::ε) ;
--------------------metamodels::sbvrEclipse.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::sbvrOMG.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------metamodels::sigkdd.owl.bgf--------------------
Boolean ::= "true" | "false" ;
EEnum ::= (male::ε) | (female::ε) | (high::ε) | (medium::ε) | (low::ε) | (very high::ε) | (1::ε) | (2::ε) | (3::ε) | (4::ε) | (5::ε) | (6::ε) | (7::ε) | (submitted::ε) | (missing::ε) | (notStarted::ε) | (active::ε) | (finished::ε) | (accepted::ε) | (rejected::ε) | (regular::ε) | (invited::ε) | (lowBid::ε) | (-::ε) | (CONFLICT::ε) | (wantNot::ε) | (highBid::ε) | (Yes::ε) | (No::ε) | (Accept::ε) | (Reject::ε) | (Unsure::ε) | (ForwardLookingIdea::ε) | (Compilers::ε) | (Microarchitecture::ε) | (Systems::ε) ;
--------------------metamodels::MiningMart.bgf--------------------
InOut ::= (Input::ε) | (OutPut::ε) ;
Boolean ::= "true" | "false" ;
ParameterType ::= (Value::ε) | (Concept::ε) | (RelationShip::ε) | (FeatureAttribute::ε) ;
--------------------ocl::expressions.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------ocl::operations.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------ocl::types.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------ocl::uml.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------ocl::values.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------slps::bgf-1.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
--------------------slps::bgf-2.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-2.1-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::btf.bgf--------------------
tree ::= (epsilon::ε) | (any::α) | (terminal::terminal) | (nonterminal::(production tree)) | (selectable::(selector::selector tree)) | (value::((int::integer()) | (string::string()))) | (sequence::(tree*)) | (choice::(expression tree)) | (optional::(tree?)) | (plus::(tree+)) | (star::(tree*)) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-3.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::(expression*)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-3.1-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-4.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-4.1-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::(BGFExpression*))) | (choice::(exprs::(BGFExpression*))) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (starsepplus::(expr::BGFExpression sep::BGFExpression)) | (starsepstar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-4.2-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::(BGFExpression*))) | (choice::(exprs::(BGFExpression*))) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (starsepplus::(expr::BGFExpression sep::BGFExpression)) | (starsepstar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-4.3-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-5.0-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (all::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-5.1-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (allof::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-5.2-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-5.3-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (allof::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v1.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
--------------------slps::bgf-v2.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression*)) | (choice::(expression*)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v2.1-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v3.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::(expression*)) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v3.1-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v4.0-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (sequence::(expression+)) | (marked::expression) | (choice::(expression+)) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v4.2-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::(BGFExpression*))) | (choice::(exprs::(BGFExpression*))) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (starsepplus::(expr::BGFExpression sep::BGFExpression)) | (starsepstar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v5.0-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (all::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v5.1-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (allof::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v5.2-xsd.bgf--------------------
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::cbgf-adt.bgf--------------------
CBGFCommand ::= (abridge_detour::(p::BGFProduction)) | (abstractize_concretize::(p::BGFProduction)) | (addH_removeH::(p::BGFProduction)) | (addV_removeV::(p::BGFProduction)) | (anonymize_deanonymize::(p::BGFProduction)) | (appear_disapper::(p::BGFProduction)) | (chain_unchain::(p::BGFProduction)) | (clone_equate::(x::string() y::string() w::XBGFScope)) | (concatT_splitT::(y::string() xs::(string()*) w::XBGFScope)) | (concretize_abstractize::(p::BGFProduction)) | (deanonymize_anonymize::(p::BGFProduction)) | (define_undefine::(ps::(BGFProduction*))) | (designate_unlabel::(p::BGFProduction)) | (detour_abridge::(p::BGFProduction)) | (deyaccify_yaccify::(ps::(BGFProduction*))) | (disappear_appear::(p::BGFProduction)) | (downgrade_upgrade::(p1::BGFProduction p2::BGFProduction)) | (eliminate_introduce::(ps::(BGFProduction*))) | (equate_clone::(x::string() y::string() w::XBGFScope)) | (extract_inline::(p::BGFProduction w::XBGFScope)) | (factor_factor::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (fold_unfold::(x::string() w::XBGFScope)) | (horizontal_vertical::(w::XBGFScope)) | (inject_project::(p::BGFProduction)) | (inline_extract::(p::BGFProduction w::XBGFScope)) | (introduce_eliminate::(ps::(BGFProduction*))) | (iterate_assoc::(p::BGFProduction)) | (assoc_iterate::(p::BGFProduction)) | (massage_massage::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (narrow_widen::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (permute_permute::(p1::BGFProduction p2::BGFProduction)) | (project_inject::(p::BGFProduction)) | (redefine_redefine::(ps1::(BGFProduction*) ps2::(BGFProduction*))) | (removeH_addH::(p::BGFProduction)) | (removeV_addV::(p::BGFProduction)) | (renameL_renameL::(x::string() y::string())) | (renameN_renameN::(x::string() y::string())) | (renameS_renameS::(x::string() y::string() w::XBGFScope)) | (renameT_renameT::(x::string() y::string())) | (replace_replace::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (reroot_reroot::(xs1::(string()*) xs2::(string()*))) | (splitN_unite::(x::string() ps::(BGFProduction*) w::XBGFScope)) | (splitT_concatT::(x::string() ys::(string()*) w::XBGFScope)) | (unchain_chain::(p::BGFProduction)) | (undefine_define::(ps::(BGFProduction*))) | (unfold_fold::(x::string() w::XBGFScope)) | (unite_splitN::(x::string() ps::(BGFProduction*) w::XBGFScope)) | (unlabel_designate::(p::BGFProduction)) | (upgrade_downgrade::(p1::BGFProduction p2::BGFProduction)) | (vertical_horizontal::(w::XBGFScope)) | (widen_narrow::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (yaccify_deyaccify::(ps::(BGFProduction*))) ;
--------------------slps::cbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
rename-rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
increasing-decreasing-transformation ::= add-remove | remove-add | appear-disappear | disappear-appear | widen-narrow | narrow-widen | upgrade-downgrade | downgrade-upgrade | unite-split | split-unite ;
decreasing-transformation ::= remove | disappear | narrow | downgrade | split ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
remove-add ::= (vertical::production) | (horizontal::production) ;
increasing-transformation ::= add | appear | widen | upgrade | unite ;
remove ::= (vertical::production) | (horizontal::production) ;
add ::= (vertical::production) | (horizontal::production) ;
add-remove ::= (vertical::production) | (horizontal::production) ;
--------------------slps::ldf-Readable.bgf--------------------
subsection-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) | (rationale::ε) | (example::ε) | (update::ε) | (subtopic::ε) | (section::ε) ;
section-role ::= (abstract::ε) | (conformance::ε) | (compatibility::ε) | (design-goals::ε) | (document-structure::ε) | (foreword::ε) | (references::ε) | (notation::ε) | (scope::ε) | (what-is-new::ε) | (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) | (top-section::ε) | (lexical-section::ε) ;
section-structure ::= (content::(content-content+)) | (placeholder::α) | (subsection+) ;
type ::= (normative::ε) | (informative::ε) ;
version-or-edition ::= (version::string()) | (edition::string()) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
content-content ::= (para::mixed) | (list::list) | production ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
value ::= (int::ε) | (string::ε) ;
part-role ::= (front-matter::ε) | (core-part::ε) | (back-matter::ε) | (annex::ε) ;
--------------------slps::ldf-v10.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
front-simple-section ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
SimpleTextElement ::= (empty::ε) | (text::mixedType) | (table::SimpleTable) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
StructuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::ListOfInternalLinks) | (subtopic::StructuredSection) ;
front-list ::= (definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
LexicalSection ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
--------------------slps::ldf-v11.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
front-simple-section ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
SimpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::SimpleFigure) | (table::SimpleTable) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
StructuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::ListOfInternalLinks) | (subtopic::StructuredSection) ;
front-list ::= (definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
LexicalSection ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
--------------------slps::ldf-v11.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (clause::simpleSection) | (field::simpleSection) ;
informative ::= (note::simpleSection) | (example::simpleSection) | (informative::simpleSection) ;
normative ::= (purpose::simpleSection) | (description::simpleSection) | (location::simpleSection) | (considerations::simpleSection) | (defaults::simpleSection) | (normative::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::listOfInternalLinks) | (subtopic::structuredSection) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v11.2-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (note::simpleSection) | (example::simpleSection) | (informative::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (clause::simpleSection) | (field::simpleSection) ;
normative ::= (purpose::simpleSection) | (description::simpleSection) | (location::simpleSection) | (considerations::simpleSection) | (defaults::simpleSection) | (normative::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::listOfInternalLinks) | (subtopic::structuredSection) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v12.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (note::simpleSection) | (example::simpleSection) | (informative::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
normative ::= (purpose::simpleSection) | (description::simpleSection) | (location::simpleSection) | (considerations::simpleSection) | (defaults::simpleSection) | (normative::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::listOfInternalLinks) | (subtopic::structuredSection) | (clause::simpleSection) | (field::simpleSection) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v13.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::(production+)) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::listOfInternalLinks) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v13.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::listOfInternalLinks) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v14.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v15.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::string()) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v15.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v16.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
--------------------slps::ldf-v17.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
figureType ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
--------------------slps::ldf-v18.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
figureType ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
--------------------slps::ldf-v18.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
figureType ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
informative ::= (rationale::simpleSection) | (example::simpleSection) | (update::simpleSection) ;
normative ::= (synopsis::simpleSection) | (description::simpleSection) | (syntax::simpleSection) | (constraints::simpleSection) | (relationship::simpleSection) | (semantics::simpleSection) | (default::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
--------------------slps::ldf-v19.0-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | (code::string()) | (text::mixed-type) | (figure::figure) | (table::table) | (list::list) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) | production ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
simple-section-role ::= (abstract::ε) | (conformance::ε) | (compatibility::ε) | (design-goals::ε) | (document-structure::ε) | (foreword::ε) | (normative-references::ε) | (notation::ε) | (scope::ε) | (what-is-new::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list) | (placeholder::placeholder) | (value::(key::string() data::string())) | (element-role simple-section::simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
element-role ::= (normative::normative-role) | (informative::informative-role) | (specific-section::simple-section) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
section ::= (placeholder::placeholder) | (simple-section::simple-section) | (lexical-section::lexical-section) | (structured-section::structured-section) | (composite-section::composite-section) | (list-section::list-section) ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
part-role ::= (front-matter::ε) | (core-part::ε) | (back-matter::ε) | (annex::ε) ;
--------------------slps::ldf-v20.0-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | (code::string()) | (text::mixed-type) | figure | table | (list::list) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) | production ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
simple-section-role ::= (abstract::ε) | (conformance::ε) | (compatibility::ε) | (design-goals::ε) | (document-structure::ε) | (foreword::ε) | (normative-references::ε) | (notation::ε) | (scope::ε) | (what-is-new::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list) | placeholder | (value::(key::string() data::string())) | ((normative-role | informative-role)? simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
part-role ::= (front-matter::ε) | (core-part::ε) | (back-matter::ε) | (annex::ε) ;
--------------------slps::ldf-v20.1-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | (code::string()) | (text::mixed-type) | figure | table | (list::list) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) | production ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
simple-section-role ::= (abstract::ε) | (conformance::ε) | (compatibility::ε) | (design-goals::ε) | (document-structure::ε) | (foreword::ε) | (normative-references::ε) | (notation::ε) | (scope::ε) | (what-is-new::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list) | placeholder | (value::(key::string() data::string())) | ((normative-role | informative-role)? simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
part-role ::= (front-matter::ε) | (core-part::ε) | (back-matter::ε) | (annex::ε) ;
--------------------slps::ldf-v21.0-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | code | (text::mixed-type) | figure | table | (list::list) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) | production ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
simple-section-role ::= (abstract::ε) | (conformance::ε) | (compatibility::ε) | (design-goals::ε) | (document-structure::ε) | (foreword::ε) | (normative-references::ε) | (notation::ε) | (scope::ε) | (what-is-new::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list) | placeholder | (value::(key::string() data::string())) | ((normative-role | informative-role)? simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
part-role ::= (front-matter::ε) | (core-part::ε) | (back-matter::ε) | (annex::ε) ;
--------------------slps::ldf-v21.1-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | code | (text::mixed-type) | figure | table | (list::list) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
simple-section-role ::= (abstract::ε) | (conformance::ε) | (compatibility::ε) | (design-goals::ε) | (document-structure::ε) | (foreword::ε) | (normative-references::ε) | (notation::ε) | (scope::ε) | (what-is-new::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list) | placeholder | (value::(key::string() data::string())) | ((normative-role | informative-role)? simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
status ::= (unknown::ε) | (draft::ε) | (candidate::ε) | (proposed::ε) | (approved::ε) | (revised::ε) | (obsolete::ε) | (withdrawn::ε) | (collection::ε) | (trial::ε) | (errata::ε) | (report::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (iec::ε) | (ietf::ε) | (oasis::ε) | (omg::ε) | (wsa::ε) | (w3c::ε) ;
part-role ::= (front-matter::ε) | (core-part::ε) | (back-matter::ε) | (annex::ε) ;
--------------------slps::ldf-v22.0-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | code | (text::mixed-type) | figure | table | (list::list-type) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list-type) | placeholder | (value::(key::string() data::string())) | ((normative-role | informative-role)? simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
content-content ::= (para::mixed-type) | (list::list-type) | production ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
--------------------slps::ldf-v23.0-xsd.bgf--------------------
list-section-role ::= (abbreviations::ε) | (definitions::ε) | (language-overview::ε) | (normative-references::ε) ;
text-element ::= (empty::ε) | code | (text::mixed-type) | figure | table | (list::list-type) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* source::string())) ;
normative-role ::= (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) ;
structured-section-element ::= (subtopic::structured-section) | (references::list-type) | placeholder | (value::(key::string() data::string())) | ((normative-role | informative-role)? simple-section) ;
informative-role ::= (example::ε) | (rationale::ε) | (update::ε) ;
lexical-section-role ::= (lexical-issue::ε) | (line-continuations::ε) | (literals::ε) | (preprocessor::ε) | (tokens::ε) | (whitespace::ε) ;
content-content ::= (para::mixed-type) | (list::list-type) | production ;
any-section ::= placeholder | simple-section | lexical-section | structured-section | composite-section | list-section ;
figure-type ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
placeholder ::= (index::ε) | (full-grammar::ε) | (list-of-tables::ε) | (list-of-authors::ε) | (list-of-contents::ε) | (list-of-references::ε) ;
--------------------slps::ldf-v3.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
top-section ::= (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) | (core::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::ε) | (whitespace::ε) | (tokens::ε) | (preprocessor::ε) | (literals::ε) | (other::ε) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v4.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
top-section ::= (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v5.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
lexicals ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v6.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
lexicalGroup ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v7.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
lexicalGroup ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::slps-btf.bgf--------------------
tree ::= (epsilon::ε) | (any::α) | (terminal::terminal) | (nonterminal::(production tree)) | (selectable::(selector::selector tree)) | (value::((int::integer()) | (string::string()))) | (sequence::(tree*)) | (choice::(expression tree)) | (optional::(tree?)) | (plus::(tree+)) | (star::(tree*)) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::ldf-v7.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
lexicalGroup ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) | production ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
front-simple-sections ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v8.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
front-simple-section ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) | production ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
front-list ::= (definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v8.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
front-simple-section ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
front-list ::= (definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v9.0-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
front-simple-section ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
insideSimpleText ::= (empty::α) | (text::mixedType) | (table::SimpleTable) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
front-list ::= (definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::ldf-v9.1-xsd.bgf--------------------
generated ::= (index::ε) | (fullgrammar::ε) | (listoftables::ε) | (listofauthors::ε) | (listofcontents::ε) | (listofreferences::ε) ;
front-simple-section ::= (foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection) ;
informative ::= (note::SimpleSection) | (example::SimpleSection) | (informative::SimpleSection) ;
insideSimpleText ::= (empty::α) | (text::mixedType) | (table::SimpleTable) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
normative ::= (purpose::SimpleSection) | (description::SimpleSection) | (location::SimpleSection) | (considerations::SimpleSection) | (defaults::SimpleSection) | (normative::SimpleSection) ;
lexical ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
front-list ::= (definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms) ;
body ::= (ansi::ε) | (ecma::ε) | (ieee::ε) | (iso::ε) | (iso/iet::ε) | (itu::ε) | (ietf::ε) | (iec::ε) | (oasis::ε) | (wsa::ε) | (w3c::ε) ;
status ::= (unknown::ε) | (draft::ε) | (committee draft::ε) | (recommendation::ε) | (international standard::ε) ;
--------------------slps::slps-cbgf-adt.bgf--------------------
CBGFCommand ::= (abridge_detour::(p::BGFProduction)) | (abstractize_concretize::(p::BGFProduction)) | (addH_removeH::(p::BGFProduction)) | (addV_removeV::(p::BGFProduction)) | (anonymize_deanonymize::(p::BGFProduction)) | (appear_disapper::(p::BGFProduction)) | (chain_unchain::(p::BGFProduction)) | (clone_equate::(x::string() y::string() w::XBGFScope)) | (concatT_splitT::(y::string() xs::(string()*) w::XBGFScope)) | (concretize_abstractize::(p::BGFProduction)) | (deanonymize_anonymize::(p::BGFProduction)) | (define_undefine::(ps::(BGFProduction*))) | (designate_unlabel::(p::BGFProduction)) | (detour_abridge::(p::BGFProduction)) | (deyaccify_yaccify::(ps::(BGFProduction*))) | (disappear_appear::(p::BGFProduction)) | (downgrade_upgrade::(p1::BGFProduction p2::BGFProduction)) | (eliminate_introduce::(ps::(BGFProduction*))) | (equate_clone::(x::string() y::string() w::XBGFScope)) | (extract_inline::(p::BGFProduction w::XBGFScope)) | (factor_factor::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (fold_unfold::(x::string() w::XBGFScope)) | (horizontal_vertical::(w::XBGFScope)) | (inject_project::(p::BGFProduction)) | (inline_extract::(p::BGFProduction w::XBGFScope)) | (introduce_eliminate::(ps::(BGFProduction*))) | (iterate_assoc::(p::BGFProduction)) | (assoc_iterate::(p::BGFProduction)) | (massage_massage::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (narrow_widen::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (permute_permute::(p1::BGFProduction p2::BGFProduction)) | (project_inject::(p::BGFProduction)) | (redefine_redefine::(ps1::(BGFProduction*) ps2::(BGFProduction*))) | (removeH_addH::(p::BGFProduction)) | (removeV_addV::(p::BGFProduction)) | (renameL_renameL::(x::string() y::string())) | (renameN_renameN::(x::string() y::string())) | (renameS_renameS::(x::string() y::string() w::XBGFScope)) | (renameT_renameT::(x::string() y::string())) | (replace_replace::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (reroot_reroot::(xs1::(string()*) xs2::(string()*))) | (splitN_unite::(x::string() ps::(BGFProduction*) w::XBGFScope)) | (splitT_concatT::(x::string() ys::(string()*) w::XBGFScope)) | (unchain_chain::(p::BGFProduction)) | (undefine_define::(ps::(BGFProduction*))) | (unfold_fold::(x::string() w::XBGFScope)) | (unite_splitN::(x::string() ps::(BGFProduction*) w::XBGFScope)) | (unlabel_designate::(p::BGFProduction)) | (upgrade_downgrade::(p1::BGFProduction p2::BGFProduction)) | (vertical_horizontal::(w::XBGFScope)) | (widen_narrow::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (yaccify_deyaccify::(ps::(BGFProduction*))) ;
--------------------slps::slps-cbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
rename-rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
increasing-decreasing-transformation ::= add-remove | remove-add | appear-disappear | disappear-appear | widen-narrow | narrow-widen | upgrade-downgrade | downgrade-upgrade | unite-split | split-unite ;
decreasing-transformation ::= remove | disappear | narrow | downgrade | split ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
remove-add ::= (vertical::production) | (horizontal::production) ;
increasing-transformation ::= add | appear | widen | upgrade | unite ;
remove ::= (vertical::production) | (horizontal::production) ;
add ::= (vertical::production) | (horizontal::production) ;
add-remove ::= (vertical::production) | (horizontal::production) ;
--------------------slps::slps-xbgf-adt.bgf--------------------
XBGFScope ::= (globally::ε) | (nowhere::ε) | (inlabel::(l::string())) | (notinlabel::(l::string())) | (innt::(x::string())) | (notinnt::(x::string())) | (comboscope::(w1::XBGFScope w2::XBGFScope)) ;
XBGFCommand ::= (abridge::(p::BGFProduction)) | (abstractize::(p::BGFProduction)) | (addH::(p::BGFProduction)) | (addV::(p::BGFProduction)) | (addC::(p::BGFProduction)) | (anonymize::(p::BGFProduction)) | (appear::(p::BGFProduction)) | (bypass::ε) | (chain::(p::BGFProduction)) | (clone::(x::string() y::string() w::XBGFScope)) | (concatT::(xs::(string()*) y::string() w::XBGFScope)) | (concretize::(p::BGFProduction)) | (deanonymize::(p::BGFProduction)) | (define::(ps::(BGFProduction*))) | (designate::(p::BGFProduction)) | (detour::(p::BGFProduction)) | (deyaccify::(x::string())) | (disappear::(p::BGFProduction)) | (distribute::(w::XBGFScope)) | (downgrade::(p1::BGFProduction p2::BGFProduction)) | (eliminate::(x::string())) | (equate::(x::string() y::string())) | (extract::(p::BGFProduction w::XBGFScope)) | (factor::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (fold::(x::string() w::XBGFScope)) | (horizontal::(w::XBGFScope)) | (importG::(ps::(BGFProduction*))) | (inject::(p::BGFProduction)) | (inline::(x::string())) | (introduce::(ps::(BGFProduction*))) | (iterate::(p::BGFProduction)) | (lassoc::(p::BGFProduction)) | (massage::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (narrow::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (permute::(p::BGFProduction)) | (project::(p::BGFProduction)) | (rassoc::(p::BGFProduction)) | (redefine::(ps::(BGFProduction*))) | (removeH::(p::BGFProduction)) | (removeV::(p::BGFProduction)) | (renameL::(x::string() y::string())) | (renameN::(x::string() y::string())) | (renameS::(x::string() y::string() w::XBGFScope)) | (renameT::(x::string() y::string())) | (replace::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (reroot::(xs::(string()*))) | (splitN::(x::string() ps::(BGFProduction*) w::XBGFScope)) | (splitT::(x::string() ys::(string()*) w::XBGFScope)) | (unchain::(p::BGFProduction)) | (undefine::(xs::(string()*))) | (unfold::(x::string() w::XBGFScope)) | (unite::(x::string() y::string())) | (unlabel::(x::string())) | (upgrade::(p1::BGFProduction p2::BGFProduction)) | (vertical::(w::XBGFScope)) | (widen::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (yaccify::(ps::(BGFProduction*))) | (atomic::(steps::(XBGFCommand*))) | (strip::(a::string())) ;
--------------------slps::slps-xbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
decreasing-transformation ::= remove | disappear | narrow | downgrade | split ;
folding-unfolding-transformation ::= unfold | fold | inline | extract | abridge | detour | unchain | chain ;
concrete-revising-transformation ::= abstractize | concretize | permute ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
increasing-transformation ::= add | appear | widen | upgrade | unite ;
decorative-transformation ::= designate | unlabel | deanonymize | anonymize ;
abstract-revising-transformation ::= define | undefine | redefine | inject | project | replace ;
refactoring-transformation ::= massage | distribute | factor | deyaccify | yaccify | eliminate | introduce | import | vertical | horizontal | equate | rassoc | lassoc | iterate | splitT ;
remove ::= (vertical::production) | (horizontal::production) ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
add ::= (vertical::production) | (horizontal::production) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::slps-xedd.bgf--------------------
step ::= rename | introduce | eliminate ;
metasymbols ::= (terminator::ε) | (defining::ε) | (definition-separator::ε) | (group::ε) | (seplist-plus::ε) | (seplist-star::ε) ;
confixMetasymbols ::= (group::ε) | (seplist-plus::ε) | (seplist-star::ε) ;
--------------------slps::slps-xldf.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
decreasing-transformation ::= remove | disappear | narrow | downgrade | split ;
sectionRole ::= (frontMatter::ε) | (backMatter::ε) | (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) | (rationale::ε) | (example::ε) | (update::ε) | (section::ε) ;
folding-unfolding-transformation ::= unfold | fold | inline | extract | abridge | detour | unchain | chain ;
concrete-revising-transformation ::= abstractize | concretize | permute ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
increasing-transformation ::= add | appear | widen | upgrade | unite ;
refactoring-transformation ::= massage | distribute | factor | deyaccify | yaccify | eliminate | introduce | import | vertical | horizontal | equate | rassoc | lassoc | iterate | splitT ;
abstract-revising-transformation ::= define | undefine | redefine | inject | project | replace ;
decorative-transformation ::= designate | unlabel | deanonymize | anonymize ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
relative ::= (before::((id::string()) | simpleTextElement)) | (after::((id::string()) | simpleTextElement)) | (to::string()) ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
addSubsection ::= topSection | (normative | informative to::string()) ;
remove ::= (vertical::production) | (horizontal::production) ;
addSection ::= frontList | lexicalSection | (placeholder::generated) | (core::structuredSection) | (annex::structuredSection) ;
documentTransformation ::= addFigure | addSection | addSubsection | append | changeRole | combine | drop | extractSubsection | hyperlinkify | insert | importGrammar | importSample | place | retitle | removeSection | transformDocument | transformGrammar ;
add ::= (vertical::production) | (horizontal::production) ;
--------------------slps::slps-xoutcome.bgf--------------------
XBGFOutcome ::= (ok::ε) | (problem::(msg::string())) | (problemXBGF::(msg::string() xbgf::XBGFCommand)) | (problemProd::(msg::string() p::BGFProduction)) | (problemProd2::(msg::string() p1::BGFProduction p2::BGFProduction)) | (problemPinProds::(msg::string() p::BGFProduction ps::(BGFProduction*))) | (problemProds::(msg::string() ps::(BGFProduction*))) | (problemProds2::(msg::string() ps1::(BGFProduction*) ps2::(BGFProduction*))) | (problemExpr::(msg::string() e::BGFExpression)) | (problemExpr2::(msg::string() e1::BGFExpression e2::BGFExpression)) | (problemStr::(msg::string() x::string())) | (problemStr2::(msg::string() x::string() y::string())) | (problemStrs::(msg::string() xs::(string()*))) | (problemScope::(msg::string() w::XBGFScope)) ;
--------------------slps::xbgf-adt.bgf--------------------
XBGFScope ::= (globally::ε) | (nowhere::ε) | (inlabel::(l::string())) | (notinlabel::(l::string())) | (innt::(x::string())) | (notinnt::(x::string())) | (comboscope::(w1::XBGFScope w2::XBGFScope)) ;
XBGFCommand ::= (abridge::(p::BGFProduction)) | (abstractize::(p::BGFProduction)) | (addH::(p::BGFProduction)) | (addV::(p::BGFProduction)) | (addC::(p::BGFProduction)) | (anonymize::(p::BGFProduction)) | (appear::(p::BGFProduction)) | (bypass::ε) | (chain::(p::BGFProduction)) | (clone::(x::string() y::string() w::XBGFScope)) | (concatT::(xs::(string()*) y::string() w::XBGFScope)) | (concretize::(p::BGFProduction)) | (deanonymize::(p::BGFProduction)) | (define::(ps::(BGFProduction*))) | (designate::(p::BGFProduction)) | (detour::(p::BGFProduction)) | (deyaccify::(x::string())) | (disappear::(p::BGFProduction)) | (distribute::(w::XBGFScope)) | (downgrade::(p1::BGFProduction p2::BGFProduction)) | (eliminate::(x::string())) | (equate::(x::string() y::string())) | (extract::(p::BGFProduction w::XBGFScope)) | (factor::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (fold::(x::string() w::XBGFScope)) | (horizontal::(w::XBGFScope)) | (importG::(ps::(BGFProduction*))) | (inject::(p::BGFProduction)) | (inline::(x::string())) | (introduce::(ps::(BGFProduction*))) | (iterate::(p::BGFProduction)) | (lassoc::(p::BGFProduction)) | (massage::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (narrow::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (permute::(p::BGFProduction)) | (project::(p::BGFProduction)) | (rassoc::(p::BGFProduction)) | (redefine::(ps::(BGFProduction*))) | (removeH::(p::BGFProduction)) | (removeV::(p::BGFProduction)) | (renameL::(x::string() y::string())) | (renameN::(x::string() y::string())) | (renameS::(x::string() y::string() w::XBGFScope)) | (renameT::(x::string() y::string())) | (replace::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (reroot::(xs::(string()*))) | (splitN::(x::string() ps::(BGFProduction*) w::XBGFScope)) | (splitT::(x::string() ys::(string()*) w::XBGFScope)) | (unchain::(p::BGFProduction)) | (undefine::(xs::(string()*))) | (unfold::(x::string() w::XBGFScope)) | (unite::(x::string() y::string())) | (unlabel::(x::string())) | (upgrade::(p1::BGFProduction p2::BGFProduction)) | (vertical::(w::XBGFScope)) | (widen::(e1::BGFExpression e2::BGFExpression w::XBGFScope)) | (yaccify::(ps::(BGFProduction*))) | (atomic::(steps::(XBGFCommand*))) | (strip::(a::string())) ;
--------------------slps::xbgf-xsd.bgf--------------------
rename ::= (label::(from::label to::label)) | (nonterminal::(from::nonterminal to::nonterminal)) | (selector::((in::label)? from::selector to::selector)) | (terminal::(from::terminal to::terminal)) ;
decreasing-transformation ::= remove | disappear | narrow | downgrade | split ;
folding-unfolding-transformation ::= unfold | fold | inline | extract | abridge | detour | unchain | chain ;
concrete-revising-transformation ::= abstractize | concretize | permute ;
transformation ::= folding-unfolding-transformation | refactoring-transformation | increasing-transformation | decreasing-transformation | concrete-revising-transformation | abstract-revising-transformation | decorative-transformation | rename | reroot | strip | dump | bypass ;
strip ::= (label::label) | (allLabels::ε) | (selector::selector) | (allSelectors::ε) | (terminal::terminal) | (allTerminals::ε) ;
expression ::= (epsilon::ε) | (empty::ε) | (value::value) | (any::ε) | (terminal::terminal) | (nonterminal::nonterminal) | (selectable::(selector::selector expression)) | (marked::expression) | (sequence::(expression+)) | (choice::(expression+)) | (allof::(expression+)) | (not::expression) | (optional::expression) | (plus::expression) | (star::expression) | (seplistplus::(expression expression)) | (sepliststar::(expression expression)) ;
increasing-transformation ::= add | appear | widen | upgrade | unite ;
decorative-transformation ::= designate | unlabel | deanonymize | anonymize ;
abstract-revising-transformation ::= define | undefine | redefine | inject | project | replace ;
refactoring-transformation ::= massage | distribute | factor | deyaccify | yaccify | eliminate | introduce | import | vertical | horizontal | equate | rassoc | lassoc | iterate | splitT ;
remove ::= (vertical::production) | (horizontal::production) ;
scope ::= (label::label) | (nonterminal::nonterminal) ;
add ::= (vertical::production) | (horizontal::production) ;
value ::= (int::ε) | (string::ε) ;
--------------------slps::bgf-v4.1-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::(BGFExpression*))) | (choice::(exprs::(BGFExpression*))) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (starsepplus::(expr::BGFExpression sep::BGFExpression)) | (starsepstar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v4.3-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v5.3-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (allof::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::bgf-v5.4-adt.bgf--------------------
BGFExpression ::= (epsilon::ε) | (empty::ε) | (val::(v::BGFValue)) | (anything::ε) | (terminal::(t::string())) | (nonterminal::(t::string())) | (selectable::(selector::string() expr::BGFExpression)) | (sequence::(exprs::BGFExprList)) | (choice::(exprs::BGFExprList)) | (allof::(exprs::BGFExprList)) | (marked::(expr::BGFExpression)) | (optional::(expr::BGFExpression)) | (not::(expr::BGFExpression)) | (plus::(expr::BGFExpression)) | (star::(expr::BGFExpression)) | (seplistplus::(expr::BGFExpression sep::BGFExpression)) | (sepliststar::(expr::BGFExpression sep::BGFExpression)) ;
BGFValue ::= (string::ε) | (integer::ε) ;
--------------------slps::xbgf-xoutcome.bgf--------------------
XBGFOutcome ::= (ok::ε) | (problem::(msg::string())) | (problemXBGF::(msg::string() xbgf::XBGFCommand)) | (problemProd::(msg::string() p::BGFProduction)) | (problemProd2::(msg::string() p1::BGFProduction p2::BGFProduction)) | (problemPinProds::(msg::string() p::BGFProduction ps::(BGFProduction*))) | (problemProds::(msg::string() ps::(BGFProduction*))) | (problemProds2::(msg::string() ps1::(BGFProduction*) ps2::(BGFProduction*))) | (problemExpr::(msg::string() e::BGFExpression)) | (problemExpr2::(msg::string() e1::BGFExpression e2::BGFExpression)) | (problemStr::(msg::string() x::string())) | (problemStr2::(msg::string() x::string() y::string())) | (problemStrs::(msg::string() xs::(string()*))) | (problemScope::(msg::string() w::XBGFScope)) ;
--------------------develop::java-project.bgf--------------------
MEMBER_KIND ::= (class::ε) | (enum::ε) | (interface::ε) | (Annotation::ε) ;
--------------------develop::make.bgf--------------------
Boolean ::= "true" | "false" ;
--------------------develop::bugzilla.bgf--------------------
PriorityType ::= (pt_null::ε) | (pt_P1::ε) | (pt_P2::ε) | (pt_P3::ε) | (pt_P4::ε) | (pt_P5::ε) ;
StatusType ::= (st_null::ε) | (st_UNCONFIRMED::ε) | (st_NEW::ε) | (st_ASSIGNED::ε) | (st_REOPENED::ε) | (st_RESOLVED::ε) | (st_VERIFIED::ε) | (st_CLOSED::ε) ;
OperatingSystemType ::= (ost_null::ε) | (ost_all::ε) | (ost_Windows 3.1::ε) | (ost_Windows 95::ε) | (ost_Windows 98::ε) | (ost_Windows ME::ε) | (ost_Windows 2000::ε) | (ost_Windows NT::ε) | (ost_Windows XP::ε) | (ost_Windows Vista::ε) | (ost_Windows Server 2003::ε) | (ost_MacSystem 7::ε) | (ost_MacSystem 7.5::ε) | (ost_MacSystem 7.6.1::ε) | (ost_MacSystem 8.0::ε) | (ost_MacSystem 8.5::ε) | (ost_MacSystem 8.6::ε) | (ost_MacSystem 9.x::ε) | (ost_Mac OS X 10.0::ε) | (ost_Mac OS X 10.1::ε) | (ost_Mac OS X 10.2::ε) | (ost_Mac OS X 10.3::ε) | (ost_Linux::ε) | (ost_BDS/OS::ε) | (ost_FreeBSD::ε) | (ost_NetBSD::ε) | (ost_OpenBSD::ε) | (ost_AIX::ε) | (ost_BeOS::ε) | (ost_HP-UX::ε) | (ost_IRIX::ε) | (ost_Neutrino::ε) | (ost_OpenVMS::ε) | (ost_OS/2::ε) | (ost_OSF/1::ε) | (ost_Solaris::ε) | (ost_SunOS::ε) | (ost_other::ε) ;
Boolean ::= "true" | "false" ;
SeverityType ::= (st_null::ε) | (st_blocker::ε) | (st_critical::ε) | (st_major::ε) | (st_normal::ε) | (st_minor::ε) | (st_trivial::ε) | (st_enhancement::ε) ;
ResolutionType ::= (rt_null::ε) | (rt_FIXED::ε) | (rt_INVALID::ε) | (rt_WONTFIX::ε) | (rt_LATER::ε) | (rt_REMIND::ε) | (rt_DUPLICATE::ε) | (rt_WORKSFORME::ε) | (rt_MOVED::ε) ;
ErrorType ::= (et_null::ε) | (et_NotFound::ε) | (et_NotPermitted::ε) | (et_InvalidBugId::ε) ;
ReportedPlatformType ::= (rpt_null::ε) | (rpt_all::ε) | (rpt_DEC::ε) | (rpt_HP::ε) | (rpt_Macintosh::ε) | (rpt_PC::ε) | (rpt_SGI::ε) | (rpt_Sun::ε) | (rpt_other::ε) ;
--------------------pico::sdf.bgf--------------------
STATEMENT ::= (PICO-ID ":=" EXP) | ("if" EXP "then" (STATEMENT (";" STATEMENT)*)? "else" (STATEMENT (";" STATEMENT)*)? "fi") | ("while" EXP "do" (STATEMENT (";" STATEMENT)*)? "od") ;
EXP ::= PICO-ID | NatCon | StrCon | (EXP "+" EXP) | (EXP "-" EXP) | (EXP "||" EXP) | ("(" EXP ")") ;
TYPE ::= "natural" | "string" | "nil-type" ;
--------------------saf::abstract.bgf--------------------
Spec ::= (attribute::(name::string() strength::integer())) | (behavior::(cond::Cond move::Action fight::Action)) ;
Action ::= (action::(name::string())) | (choose::(actions::(string()*))) ;
Cond ::= (const::(name::string())) | (and::(lhs::Cond rhs::Cond)) | (or::(lhs::Cond rhs::Cond)) ;
