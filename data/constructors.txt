--------------------c::lankamp.bgf--------------------
Specifier ::= [StorageClass] StorageClass ;
 Specifier ::= [TypeQualifier] TypeQualifier ;
 Specifier ::= [TypeSpecifier] TypeSpecifier ;
FunctionDefinition ::= [DefaultFunctionDefinition] specs::(Specifier*) Declarator Declaration* "{" Declaration* Statement* "}" ;
Declaration ::= [DeclarationWithoutInitDecls] specs::(Specifier+) ";" ;
 Declaration ::= [DeclarationWithInitDecls] specs::(Specifier+) initDeclarators::({InitDeclarator ","}+) ";" ;
FunctionPrototype ::= [DefaultFunctionPrototype] specs::(Specifier*) decl::PrototypeDeclarator ";" ;
GlobalDeclaration ::= [GlobalDeclarationWithoutInitDecls] specs::(Specifier+) ";" ;
 GlobalDeclaration ::= [GlobalDeclarationWithInitDecls] specs::(Specifier*) initDeclarators::({InitDeclarator ","}+) ";" ;
StructDeclaration ::= [StructDeclWithoutDecl] specs::(Specifier+) ";" ;
 StructDeclaration ::= [StructDeclWithDecl] specs::(Specifier+) {StructDeclarator ","}+ ";" ;
AbstractDeclarator ::= [Identifier] AnonymousIdentifier ;
 AbstractDeclarator ::= [ArrayDeclarator] decl::AbstractDeclarator "[" exp::(Expression?) "]" ;
 AbstractDeclarator ::= [Bracket] "(" decl::AbstractDeclarator ")" ;
 AbstractDeclarator ::= [FunctionDeclarator] decl::AbstractDeclarator "(" params::(Parameters?) ")" ;
 AbstractDeclarator ::= [PointerDeclarator] "*" qualifiers::(TypeQualifier*) decl::AbstractDeclarator ;
PrototypeDeclarator ::= [FunctionDeclarator] decl::PrototypeDeclarator "(" params::(PrototypeParameters?) ")" ;
 PrototypeDeclarator ::= [Identifier] Identifier ;
 PrototypeDeclarator ::= [Bracket] "(" decl::AbstractDeclarator ")" ;
 PrototypeDeclarator ::= [ArrayDeclarator] decl::PrototypeDeclarator "[" exp::(Expression?) "]" ;
 PrototypeDeclarator ::= [PointerDeclarator] "*" qualifiers::(TypeQualifier*) decl::PrototypeDeclarator ;
Declarator ::= [ArrayDeclarator] decl::Declarator "[" exp::(Expression?) "]" ;
 Declarator ::= [Identifier] Identifier ;
 Declarator ::= [FunctionDeclarator] decl::Declarator "(" params::(Parameters?) ")" ;
 Declarator ::= [Bracket] "(" decl::Declarator ")" ;
 Declarator ::= [PointerDeclarator] "*" qualifiers::(TypeQualifier*) decl::Declarator ;
NonCommaExpression ::= [NonCommaExpression] expr::Expression ;
--------------------java::java-5-landman.bgf--------------------
DimExpr ::= [dim] "[" Expr "]" ;
ImportDec ::= [typeImportOnDemandDec] "import" PackageName "." "*" ";" ;
 ImportDec ::= [typeImportDec] "import" TypeName ";" ;
 ImportDec ::= [staticImportDec] "import" "static" TypeName "." Id ";" ;
 ImportDec ::= [staticImportOnDemandDec] "import" "static" TypeName "." "*" ";" ;
ArrayAccess ::= [arrayAccess] ArraySubscript ;
PackageDec ::= [packageDec] Anno* "package" PackageName ";" ;
VarDec ::= [varDec] VarDecId "=" VarInit ;
 VarDec ::= [varDec] VarDecId ;
Interfaces ::= [implementsDec] "implements" {InterfaceType ","}+ ;
ClassOrInterfaceType ::= [classOrInterfaceType] TypeDecSpec TypeArgs? ;
ConstrDec ::= [constrDec] ConstrHead ConstrBody ;
InterfaceType ::= [interfaceType] TypeDecSpec TypeArgs? ;
TypeVar ::= [typeVar] TypeVarId ;
Block ::= [block] "{" BlockStm* "}" ;
Throws ::= [throwsDec] "throws" {ExceptionType ","}+ ;
ElemValPair ::= [elemValPair] Id "=" ;
CatchClause ::= [catch] "catch" "(" FormalParam ")" Block ;
ArrayInit ::= [arrayInit] "{" {VarInit ","}* "," "}" ;
 ArrayInit ::= [arrayInit] "{" {VarInit ","}* "}" ;
Dim ::= [dim] "[" "]" ;
InstanceInit ::= [instanceInit] Block ;
EnumBody ::= [enumBody] "{" {EnumConst ","}* EnumBodyDecs? "}" ;
 EnumBody ::= [enumBody] "{" {EnumConst ","}* "," EnumBodyDecs? "}" ;
ConstrInv ::= [qSuperConstrInv] Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" ;
 ConstrInv ::= [superConstrInv] TypeArgs? "super" "(" {Expr ","}* ")" ";" ;
 ConstrInv ::= [altConstrInv] TypeArgs? "this" "(" {Expr ","}* ")" ";" ;
IntLiteral ::= [octa] ε ;
 IntLiteral ::= [hexa] ε ;
 IntLiteral ::= [deci] ε ;
FieldAccess ::= [qSuperField] TypeName "." "super" "." Id ;
 FieldAccess ::= [field] "." Id ;
 FieldAccess ::= [superField] "super" "." Id ;
MethodSpec ::= [method] MethodName ;
 MethodSpec ::= [superMethod] "super" "." TypeArgs? Id ;
 MethodSpec ::= [genericMethod] AmbName "." TypeArgs Id ;
 MethodSpec ::= [qSuperMethod] TypeName "." "super" "." TypeArgs? Id ;
 MethodSpec ::= [method] "." TypeArgs? Id ;
Super ::= [superDec] "extends" ClassType ;
TypeArgs ::= [typeArgs] "<" {ActualTypeArg ","}+ ">" ;
AnnoDecHead ::= [annoDecHead] "@" "interface" Id ;
TypeParam ::= [typeParam] TypeVarId TypeBound? ;
FloatLiteral ::= [float] ε ;
PackageName ::= [packageName] {Id "."}+ ;
ConstrBody ::= [constrBody] "{" ConstrInv? BlockStm* "}" ;
Anno ::= [singleElemAnno] "@" TypeName "(" ")" ;
 Anno ::= [anno] "@" TypeName "(" {ElemValPair ","}* ")" ;
 Anno ::= [markerAnno] "@" TypeName ;
ArrayCreationExpr ::= [newArray] "new" ArrayBaseType DimExpr+ ;
 ArrayCreationExpr ::= [newArray] "new" ArrayBaseType ArrayInit ;
FieldDec ::= [fieldDec] Type {VarDec ","}+ ";" ;
CompilationUnit ::= [compilationUnit] PackageDec? ImportDec* TypeDec* ;
LocalVarDecStm ::= [localVarDecStm] LocalVarDec ";" ;
BoolLiteral ::= [false] "false" ;
 BoolLiteral ::= [true] "true" ;
TypeBound ::= [typeBound] "extends" {ClassOrInterfaceType "&"}+ ;
EnumConst ::= [enumConst] Id EnumConstArgs? ClassBody? ;
AmbName ::= [ambName] AmbName "." Id ;
 AmbName ::= [ambName] Id ;
MethodDec ::= [methodDec] MethodDecHead MethodBody ;
MethodDecHead ::= [deprMethodDecHead] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ;
 MethodDecHead ::= [methodDecHead] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ;
ExprName ::= [exprName] Id ;
 ExprName ::= [exprName] AmbName "." Id ;
DefaultVal ::= [defaultVal] "default" ;
AbstractMethodDec ::= [abstractMethodDec] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";" ;
 AbstractMethodDec ::= [deprAbstractMethodDec] TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" ;
FormalParam ::= [varArityParam] Type "..." VarDecId ;
 FormalParam ::= [param] Type VarDecId ;
StaticInit ::= [staticInit] "static" Block ;
Id ::= [id] ε ;
ClassLiteral ::= [voidClass] "void" "." "class" ;
 ClassLiteral ::= [class] Type "." "class" ;
EnumBodyDecs ::= [enumBodyDecs] ";" ClassBodyDec* ;
ExtendsInterfaces ::= [extendsInterfaces] "extends" {InterfaceType ","}+ ;
ClassType ::= [classType] TypeDecSpec TypeArgs? ;
PackageOrTypeName ::= [packageOrTypeName] Id ;
 PackageOrTypeName ::= [packageOrTypeName] PackageOrTypeName "." Id ;
MethodName ::= [methodName] AmbName "." Id ;
 MethodName ::= [methodName] Id ;
InterfaceDecHead ::= [interfaceDecHead] "interface" Id TypeParams? ExtendsInterfaces? ;
IntType ::= [int] "int" ;
 IntType ::= [byte] "byte" ;
 IntType ::= [long] "long" ;
 IntType ::= [short] "short" ;
 IntType ::= [char] "char" ;
WildcardBound ::= [wildcardUpperBound] "extends" RefType ;
 WildcardBound ::= [wildcardLowerBound] "super" RefType ;
EnumDec ::= [enumDec] EnumDecHead EnumBody ;
EnumDecHead ::= [enumDecHead] "enum" Id Interfaces? ;
ConstantDec ::= [constantDec] Type {VarDec ","}+ ";" ;
ClassBody ::= [classBody] "{" ClassBodyDec* "}" ;
SwitchBlock ::= [switchBlock] "{" SwitchGroup* SwitchLabel* "}" ;
FloatType ::= [double] "double" ;
 FloatType ::= [float] "float" ;
ArrayType ::= [arrayType] Type "[" "]" ;
ConstrHead ::= [constrDecHead] TypeParams? Id "(" {FormalParam ","}* ")" Throws? ;
SwitchGroup ::= [switchGroup] SwitchLabel+ BlockStm+ ;
ClassDecHead ::= [classDecHead] "class" Id TypeParams? Super? Interfaces? ;
NullLiteral ::= [null] "null" ;
LocalVarDec ::= [localVarDec] Type {VarDec ","}+ ;
TypeName ::= [typeName] PackageOrTypeName "." Id ;
 TypeName ::= [typeName] Id ;
SwitchLabel ::= [case] "case" Expr ":" ;
 SwitchLabel ::= [default] "default" ":" ;
TypeParams ::= [typeParams] "<" {TypeParam ","}+ ">" ;
--------------------xpath::w3c-xpath1.bgf--------------------
AbbreviatedRelativeLocationPath ::= [NT-AbbreviatedRelativeLocationPath] RelativeLocationPath "//" Step ;
AxisSpecifier ::= [NT-AxisSpecifier] (AxisName "::") | AbbreviatedAxisSpecifier ;
NodeType ::= [NT-NodeType] "comment" | "text" | "processing-instruction" | "node" ;
PrimaryExpr ::= [NT-PrimaryExpr] VariableReference | ("(" Expr ")") | Literal | Number | FunctionCall ;
FunctionCall ::= [NT-FunctionCall] FunctionName "(" (Argument ("," Argument)*)? ")" ;
ExprWhitespace ::= [NT-ExprWhitespace] S ;
AbsoluteLocationPath ::= [NT-AbsoluteLocationPath] ("/" RelativeLocationPath?) | AbbreviatedAbsoluteLocationPath ;
OperatorName ::= [NT-OperatorName] "and" | "or" | "mod" | "div" ;
EqualityExpr ::= [NT-EqualityExpr] RelationalExpr | (EqualityExpr "=" RelationalExpr) | (EqualityExpr "!=" RelationalExpr) ;
FilterExpr ::= [NT-FilterExpr] PrimaryExpr | (FilterExpr Predicate) ;
PredicateExpr ::= [NT-PredicateExpr] Expr ;
AxisName ::= [NT-AxisName] "ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-sibling" | "namespace" | "parent" | "preceding" | "preceding-sibling" | "self" ;
Step ::= [NT-Step] (AxisSpecifier NodeTest Predicate*) | AbbreviatedStep ;
AbbreviatedAbsoluteLocationPath ::= [NT-AbbreviatedAbsoluteLocationPath] "//" RelativeLocationPath ;
Number ::= [NT-Number] (Digits ("." Digits?)?) | ("." Digits) ;
AbbreviatedStep ::= [NT-AbbreviatedStep] "." | ".." ;
UnaryExpr ::= [NT-UnaryExpr] UnionExpr | ("-" UnaryExpr) ;
ExprToken ::= [NT-ExprToken] "(" | ")" | "[" | "]" | "." | ".." | "@" | "," | "::" | NameTest | NodeType | Operator | FunctionName | AxisName | Literal | Number | VariableReference ;
AbbreviatedAxisSpecifier ::= [NT-AbbreviatedAxisSpecifier] "@"? ;
NameTest ::= [NT-NameTest] "*" | (NCName ":" "*") | QName ;
Argument ::= [NT-Argument] Expr ;
RelationalExpr ::= [NT-RelationalExpr] AdditiveExpr | (RelationalExpr "<" AdditiveExpr) | (RelationalExpr ">" AdditiveExpr) | (RelationalExpr "<=" AdditiveExpr) | (RelationalExpr ">=" AdditiveExpr) ;
PathExpr ::= [NT-PathExpr] LocationPath | FilterExpr | (FilterExpr "/" RelativeLocationPath) | (FilterExpr "//" RelativeLocationPath) ;
LocationPath ::= [NT-LocationPath] RelativeLocationPath | AbsoluteLocationPath ;
OrExpr ::= [NT-OrExpr] AndExpr | (OrExpr "or" AndExpr) ;
Predicate ::= [NT-Predicate] "[" PredicateExpr "]" ;
Expr ::= [NT-Expr] OrExpr ;
NodeTest ::= [NT-NodeTest] NameTest | (NodeType "(" ")") | ("processing-instruction" "(" Literal ")") ;
VariableReference ::= [NT-VariableReference] "$" QName ;
AndExpr ::= [NT-AndExpr] EqualityExpr | (AndExpr "and" EqualityExpr) ;
MultiplicativeExpr ::= [NT-MultiplicativeExpr] UnaryExpr | (MultiplicativeExpr MultiplyOperator UnaryExpr) | (MultiplicativeExpr "div" UnaryExpr) | (MultiplicativeExpr "mod" UnaryExpr) ;
MultiplyOperator ::= [NT-MultiplyOperator] "*" ;
Digits ::= [NT-Digits] ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ;
RelativeLocationPath ::= [NT-RelativeLocationPath] Step | (RelativeLocationPath "/" Step) | AbbreviatedRelativeLocationPath ;
UnionExpr ::= [NT-UnionExpr] PathExpr | (UnionExpr "|" PathExpr) ;
Operator ::= [NT-Operator] OperatorName | MultiplyOperator | "/" | "//" | "|" | "+" | "-" | "=" | "!=" | "<" | "<=" | ">" | ">=" ;
AdditiveExpr ::= [NT-AdditiveExpr] MultiplicativeExpr | (AdditiveExpr "+" MultiplicativeExpr) | (AdditiveExpr "-" MultiplicativeExpr) ;
--------------------markup::cnf.bgf--------------------
Disjuncts ::= [numbers] Number+ ;
Line ::= [comment] comment::Comment ;
 Line ::= [disjunct] disjunct::Disjunct ;
--------------------markup::csv-rascal-concrete.bgf--------------------
Table ::= [table] {Record EOL}* ;
Field ::= [quoted] QStr ;
 Field ::= [unquoted] UQStr ;
Record ::= [record] {Field ","}+ ;
--------------------markup::json-rascal-concrete.bgf--------------------
Object ::= [Object] "{" members::({Member ","}*) "}" ;
Member ::= [Member] memberName::StringLiteral ":" memberValue::Value ;
Array ::= [Array] "[" values::({Value ","}*) "]" ;
--------------------markup::wiki-simple.bgf--------------------
WikiText ::= [wss] WikiSymbol* ;
WikiLink ::= [barred] "[[" destination::PageName "|" description::(MWWord+) "]]" ;
 WikiLink ::= [simple] "[[" destination::PageName "]]" ;
WikiSymbol ::= [w] MWWord ;
 WikiSymbol ::= [wl] WikiLink ;
--------------------fl::dcg.bgf--------------------
expr ::= [binary] atom (ops atom)* ;
 expr ::= [apply] name atom+ ;
 expr ::= [ifThenElse] "if" expr "then" expr "else" expr ;
ops ::= [equal] "==" ;
 ops ::= [plus] "+" ;
 ops ::= [minus] "-" ;
--------------------fl::rascal-a.bgf--------------------
FLPrg ::= [prg] fs::(FLFun*) ;
FLFun ::= [fun] f::string() args::(str*) body::FLExpr ;
--------------------fl::rascal-c.bgf--------------------
Function ::= [fun] f::Name args::(Name+) "=" body::Expr ;
Program ::= [prg] functions::({Function "\n"}+) ;
Ops ::= [plus] "+" ;
 Ops ::= [equal] "==" ;
 Ops ::= [minus] "-" ;
--------------------fl::rascal.bgf--------------------
Ops ::= [minus] "-" ;
 Ops ::= [plus] "+" ;
 Ops ::= [equal] "==" ;
--------------------fl::sdf.bgf--------------------
Ops ::= [minus] "-" ;
 Ops ::= [plus] "+" ;
 Ops ::= [equal] "==" ;
--------------------metasyntax::s-expressions.bgf--------------------
SExp ::= [list] List ;
 SExp ::= [string] String ;
SimpleString ::= [raw] Raw ;
 SimpleString ::= [base64] Base64 ;
 SimpleString ::= [hex] HexaDecimal ;
 SimpleString ::= [token] Token ;
 SimpleString ::= [quoted] QuotedString ;
String ::= [display] Display SimpleString ;
 String ::= [simple] SimpleString ;
--------------------metasyntax::aterms-rascal.bgf--------------------
Annotation ::= [Default] "{" {ATerm ","}+ "}" ;
AFun ::= [Quoted] StrCon ;
 AFun ::= [Unquoted] IdCon ;
ATerm ::= [Appl] AFun "(" {ATerm ","}+ ")" ;
 ATerm ::= [Real] RealCon ;
 ATerm ::= [List] "[" {ATerm ","}* "]" ;
 ATerm ::= [Annotated] ATerm Annotation ;
 ATerm ::= [Placeholder] "<" ATerm ">" ;
 ATerm ::= [Int] IntCon ;
 ATerm ::= [Fun] AFun ;
OptExp ::= [Present] "e" IntCon ;
 OptExp ::= [Absent] ε ;
RealCon ::= [RealCon] IntCon "." NatCon OptExp ;
IntCon ::= [Positive] "+" NatCon ;
 IntCon ::= [Natural] NatCon ;
 IntCon ::= [Negative] "-" NatCon ;
--------------------metasyntax::sdf-rascal.bgf--------------------
AFun ::= [Quoted] StrCon ;
 AFun ::= [Unquoted] ε ;
Attribute ::= [Term] ATermAttribute ;
 Attribute ::= [Assoc] Assoc ;
 Attribute ::= [Bracket] "bracket" ;
 Attribute ::= [Id] "id" "(" ModuleName ")" ;
 Attribute ::= [Avoid] "avoid" ;
 Attribute ::= [Prefer] "prefer" ;
 Attribute ::= [Reject] "reject" ;
Renamings ::= [Renamings] "[" Renaming* "]" ;
ModuleName ::= [Parameterized] id::ModuleId "[" actuals::Syms "]" ;
 ModuleName ::= [Unparameterized] ε ;
Prod ::= [Prod] Syms "->" Sym Attrs ;
Assoc ::= [NonAssoc] "non-assoc" ;
 Assoc ::= [Assoc] "assoc" ;
 Assoc ::= [Left] "left" ;
 Assoc ::= [Right] "right" ;
Definition ::= [modules] Module* ;
IntCon ::= [Negative] "-" NatCon ;
 IntCon ::= [Natural] NatCon ;
 IntCon ::= [Positive] "+" NatCon ;
ArgumentIndicator ::= [Default] "<" {NatCon ","}+ ">" ;
Alias ::= [Alias] Sym "->" Sym ;
Restriction ::= [Follow] Syms "-/-" Lookaheads ;
Sym ::= [Empty] "(" ")" ;
 Sym ::= [Lit] StrCon ;
 Sym ::= [Opt] Sym "?" ;
 Sym ::= [Seq] "(" Sym Sym+ ")" ;
 Sym ::= [Bracket] "(" Sym ")" ;
 Sym ::= [CILit] SingleQuotedStrCon ;
 Sym ::= [Varsym] "<" Sym "-VAR" ">" ;
 Sym ::= [Sort] Sort ;
 Sym ::= [Lex] "<" Sym "-LEX" ">" ;
 Sym ::= [Layout] "LAYOUT" ;
 Sym ::= [CF] "<" Sym "-CF" ">" ;
 Sym ::= [ParameterizedSort] Sort "[[" {Sym ","}+ "]]" ;
 Sym ::= [IterStar] Sym "*" ;
 Sym ::= [IterStarSep] "{" Sym Sym "}" "*" ;
 Sym ::= [Iter] Sym "+" ;
 Sym ::= [Class] Class ;
 Sym ::= [IterSep] "{" Sym Sym "}" "+" ;
 Sym ::= [Alt] Sym "|" Sym ;
 Sym ::= [Label] Label ":" Sym ;
RealCon ::= [RealCon] IntCon "." NatCon OptExp ;
FunctionName ::= [QuotedFun] StrCon ;
 FunctionName ::= [UnquotedFun] IdCon ;
Lookahead ::= [Class] class::Class ;
 Lookahead ::= [Seq] class::Class "." las::Lookaheads ;
Group ::= [NonTransitive] Group "." ;
 Group ::= [AssocGroup] "{" Assoc ":" Prods "}" ;
 Group ::= [WithArguments] Group ArgumentIndicator ;
 Group ::= [SimpleGroup] Prod ;
 Group ::= [ProdsGroup] "{" Prods "}" ;
Renaming ::= [production] Prod "=>" Prod ;
 Renaming ::= [Sym] Sym "=>" Sym ;
ImpSection ::= [Imports] "imports" Imports ;
Class ::= [SimpleCharClass] "[" Range* "]" ;
 Class ::= [Bracket] "(" Class ")" ;
 Class ::= [Comp] "~" Class ;
 Class ::= [Diff] Class "/" Class ;
 Class ::= [ISect] Class "/\" Class ;
 Class ::= [Union] Class "\/" Class ;
SDF ::= [Definition] "definition" def::Definition ;
Label ::= [IdCon] ε ;
 Label ::= [Quoted] StrCon ;
Lookaheads ::= [Single] Lookahead ;
 Lookaheads ::= [Alt] Lookaheads "|" Lookaheads ;
 Lookaheads ::= [List] "[[" {Lookahead ","}* "]]" ;
 Lookaheads ::= [Bracket] "(" Lookaheads ")" ;
ATermAttribute ::= [Default] ε ;
Annotation ::= [Default] "{" {ATerm ","}+ "}" ;
ATerm ::= [Real] RealCon ;
 ATerm ::= [Appl] AFun "(" {ATerm ","}+ ")" ;
 ATerm ::= [Annotated] ATerm Annotation ;
 ATerm ::= [Placeholder] "<" ATerm ">" ;
 ATerm ::= [Int] IntCon ;
 ATerm ::= [Fun] AFun ;
 ATerm ::= [List] "[" {ATerm ","}* "]" ;
Module ::= [Module] "module" ModuleName ImpSection* Sections ;
OptExp ::= [Present] "e" IntCon ;
 OptExp ::= [Absent] ε ;
Character ::= [eof] "\EOF" ;
 Character ::= [short] ShortChar ;
 Character ::= [Numeric] NumChar ;
 Character ::= [top] "\TOP" ;
 Character ::= [label_start] "\LABEL_START" ;
 Character ::= [bot] "\BOT" ;
Restrictions ::= [Default] Restriction* ;
Grammar ::= [ContextFreePriorities] "context-free" "priorities" Priorities ;
 Grammar ::= [ImpSection] ImpSection ;
 Grammar ::= [KernalStartSyms] "start-symbols" Syms ;
 Grammar ::= [Aliases] "aliases" Aliases ;
 Grammar ::= [Variables] "variables" Prods ;
 Grammar ::= [ContextFreeSyntax] "context-free" "syntax" Prods ;
 Grammar ::= [LexicalRestrictions] "lexical" "restrictions" Restrictions ;
 Grammar ::= [Sorts] "sorts" Syms ;
 Grammar ::= [ContextFreeStartSyms] "context-free" "start-symbols" Syms ;
 Grammar ::= [Syntax] "syntax" Prods ;
 Grammar ::= [Restrictions] "restrictions" Restrictions ;
 Grammar ::= [Priorities] "priorities" Priorities ;
 Grammar ::= [LexicalStartSyms] "lexical" "start-symbols" Syms ;
 Grammar ::= [LexicalVariables] "lexical" "variables" Prods ;
 Grammar ::= [ContextFreeRestrictions] "context-free" "restrictions" Restrictions ;
 Grammar ::= [LexicalPriorities] "lexical" "priorities" Priorities ;
 Grammar ::= [LexicalSyntax] "lexical" "syntax" Prods ;
Import ::= [Bracket] "(" Import ")" ;
 Import ::= [Module] ModuleName ;
 Import ::= [RenamedModule] ModuleName Renamings ;
Section ::= [Exports] "exports" Grammar* ;
 Section ::= [Hiddens] "hiddens" Grammar* ;
Priority ::= [Chain] {Group ">"}+ ;
 Priority ::= [Assoc] Group Assoc Group ;
Attrs ::= [Attrs] "{" {Attribute ","}* "}" ;
 Attrs ::= [NoAttrs] ε ;
--------------------hats::abs.bgf--------------------
Literal ::= [i] IntLiteral ;
 Literal ::= [s] StringLiteral ;
StringLiteral ::= [s] STRINGLITERAL ;
SqlAtomicRelationRef ::= [r] StringLiteral ;
 SqlAtomicRelationRef ::= [r] VarOrFieldRef ;
SimpleName ::= [id] IDENTIFIER ;
Exp ::= [e] DataExp ;
 Exp ::= [e] EffExp ;
Datatypeparam ::= [id] TYPE_IDENTIFIER ;
Ifname ::= [n] TypeName ;
Delta ::= [id] TYPE_IDENTIFIER ;
SimpleTypeName ::= [id] TYPE_IDENTIFIER ;
Featvar ::= [f] TYPE_IDENTIFIER ;
ABSGoal ::= [cu] CompilationUnit ;
ModuleModifier ::= [m] OoModifier ;
 ModuleModifier ::= [m] FunctionalModifier ;
DeltaId ::= [delta] TYPE_IDENTIFIER ;
IntLiteral ::= [i] INTLITERAL ;
SqlStringLiteral ::= [s] SQLSTRINGLITERAL ;
ExpFunctionDef ::= [ef] DataExp ;
--------------------metamodels::logic-concrete.bgf--------------------
Formula ::= [not] "!" arg::Formula ;
 Formula ::= [true] "true" ;
 Formula ::= [false] "false" ;
 Formula ::= [and] lhs::Formula "&" rhs::Formula ;
 Formula ::= [or] lhs::Formula "|" rhs::Formula ;
 Formula ::= [fi] lhs::Formula "<=" rhs::Formula ;
 Formula ::= [if] lhs::Formula "=>" rhs::Formula ;
 Formula ::= [iff] lhs::Formula "<=>" rhs::Formula ;
 Formula ::= [id] ε ;
--------------------pico::rascal.bgf--------------------
Statement ::= [cond] "if" cond::Expression "then" thenPart::({Statement ";"}*) "else" elsePart::({Statement ";"}*) "fi" ;
 Statement ::= [assign] var::Id ":=" val::Expression ;
 Statement ::= [cond] "if" cond::Expression "then" thenPart::({Statement ";"}*) "fi" ;
 Statement ::= [loop] "while" cond::Expression "do" body::({Statement ";"}*) "od" ;
Type ::= [string] "string" ;
 Type ::= [natural] "natural" ;
 Type ::= [nil] "nil-type" ;
IdType ::= [idtype] id::Id ":" t::Type ;
Program ::= [program] "begin" decls::Declarations body::({Statement ";"}*) "end" ;
--------------------saf::concrete.bgf--------------------
Fighter ::= [fighter] name::Id "{" specs::(Spec*) "}" ;
Spec ::= [behavior] cond::Cond "[" move::Action fight::Action "]" ;
 Spec ::= [attribute] name::Id "=" strength::Number ;
Action ::= [action] Id ;
 Action ::= [choose] "choose" "(" actions::(Id*) ")" ;
Cond ::= [and] lhs::Cond "and" rhs::Cond ;
 Cond ::= [const] Id ;
 Cond ::= [or] lhs::Cond "or" rhs::Cond ;
