--------------------c::cordy-malton-dahn.bgf--------------------
nosemiNL ::= NL ;
--------------------dart::spec-0.01.bgf--------------------
mapLiteralEntry ::= (identifier ":" expression) | (stringLiteral ":" expression) ;
scriptDefinition ::= scriptTag? libraryName? libraryImport* include* resource* topLevelDefinition* ;
argumentList ::= (namedArgument ("," namedArgument)*) | (expressionList ("," namedArgument)*) ;
constantObjectExpression ::= "const" type ("." identifier)? arguments ;
setterSignature ::= "static"? returnType? "set" identifier formalParameterList ;
defaultFormalParameter ::= normalFormalParameter ("=" expression)? ;
typeList ::= type ("," type)* ;
bitwiseOperator ::= "&" | "^" | "|" ;
tryStatement ::= "try" block (catchPart+ finallyPart?) | finallyPart ;
operatorSignature ::= returnType? "operator" operator formalParameterList ;
unaryOperator ::= negateOperator ;
staticFinalDeclarationList ::= staticFinalDeclaration ("," staticFinalDeclaration)* ;
libraryDefinition ::= scriptTag? libraryName libraryImport* include* resource* topLevelDefinition* ;
isOperator ::= "is" "!"? ;
finalVarOrType ::= ("final" type?) | "var" | type ;
postfixExpression ::= (assignableExpression postfixOperator) | (primary selector*) ;
getterSignature ::= "static"? returnType? "get" identifier formalParameterList ;
interfaceDefinition ::= "interface" identifier typeParameters? superinterfaces? factorySpecification? "{" interfaceMemberDefinition* "}" ;
relationalOperator ::= ">=" | ">" | "<=" | "<" ;
classDefinition ::= "class" identifier typeParameters? superclass? interfaces? "{" classMemberDefinition* "}" ;
initializedVariableDeclaration ::= declaredIdentifier ("=" expression)? ("," initializedIdentifier)* ;
simpleFormalParameter ::= declaredIdentifier | identifier ;
compilationUnit ::= topLevelDefinition* EOF ;
booleanLiteral ::= "true" | "false" ;
libraryName ::= "#" "library" "(" stringLiteral ")" ";" ;
interfaceMemberDefinition ::= ("static" "final" type? initializedIdentifierList ";") | (functionSignature ";") | (constantConstructorSignature ";") | (namedConstructorSignature ";") | (getterSignature ";") | (setterSignature ";") | (operatorSignature ";") | (variableDeclaration ";") ;
superCallOrFieldInitializer ::= ("super" arguments) | ("super" "." identifier arguments) | fieldInitializer ;
topLevelDefinition ::= classDefinition | interfaceDefinition | functionTypeAlias | (functionSignature functionBody) | (returnType? getOrSet identifier formalParameterList functionBody) | ("final" type? staticFinalDeclarationList ";") | (variableDeclaration ";") ;
numericLiteral ::= NUMBER | HEX_NUMBER ;
stringLiteral ::= ("@"? MULTI_LINE_STRING) | SINGLE_LINE_STRING ;
constructorSignature ::= (identifier formalParameterList) | namedConstructorSignature ;
variableDeclaration ::= declaredIdentifier ("," identifier)* ;
initializedIdentifierList ::= initializedIdentifier ("," initializedIdentifier)* ;
newExpression ::= "new" type ("." identifier)? arguments ;
methodSignature ::= factoryConstructorSignature | ("static" functionSignature) | getterSignature | setterSignature | operatorSignature | (functionSignature initializers?) | (namedConstructorSignature initializers?) ;
thisExpression ::= "this" ;
expressionList ::= expression ("," expression)* ;
prefixOperator ::= additiveOperator | negateOperator ;
forLoopParts ::= (forInitializerStatement expression? ";" expressionList?) | (declaredIdentifier "in" expression) | (identifier "in" expression) ;
ifStatement ::= "if" "(" expression ")" statement ("else" statement)? ;
functionExpressionBody ::= ("=>" expression) | block ;
scriptTag ::= "#!" α* NEWLINE ;
catchPart ::= "catch" "(" declaredIndentifier ("," declaredIndentifier)? ")" block ;
nonLabelledStatement ::= block | (initializedVariableDeclaration ";") | forStatement | whileStatement | doStatement | switchStatement | ifStatement | tryStatement | breakStatement | continueStatement | returnStatement | throwStatement | expressionStatement | assertStatement | (functionSignature functionBody) ;
prefixExpression ::= prefixOperator unaryExpression ;
getOrSet ::= "get" | "set" ;
assertStatement ::= "assert" "(" conditionalExpression ")" ";" ;
assignableSelector ::= ("[" expression "]") | ("." identifier) ;
shiftOperator ::= "<<" | ">>>" | ">>" ;
logicalAndExpression ::= bitwiseOrExpression ("&&" bitwiseOrExpression)* ;
negateOperator ::= "!" | "~" ;
binaryOperator ::= multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | equalityOperator | bitwiseOperator ;
typeParameters ::= "<" typeParameter ("," typeParameter)* ">" ;
assignableExpression ::= (primary (arguments* assignableSelector)+) | ("super" assignableSelector) | identifier ;
libraryImport ::= "#" "import" "(" stringLiteral ("," "prefix:" stringLiteral)? ")" ";" ;
normalFormalParameters ::= normalFormalParameter ("," normalFormalParameter)* ;
functionSignature ::= returnType? identifier formalParameterList ;
functionTypeAlias ::= "typedef" functionPrefix typeParameters? formalParameterList ";" ;
whileStatement ::= "while" "(" expression ")" statement ;
equalityOperator ::= "==" | "!=" | "===" | "!==" ;
conditionalExpression ::= logicalOrExpression ("?" expression ":" expression)? ;
typeArguments ::= "<" typeList ">" ;
shiftExpression ::= (additiveExpression (shiftOperator additiveExpression)*) | ("super" (shiftOperator additiveExpression)+) ;
postfixOperator ::= incrementOperator ;
formalParameterList ::= ("(" ")") | ("(" normalFormalParameters ("," namedFormalParameters)? ")") | namedFormalParameters ;
expressionStatement ::= expression? ";" ;
namedConstructorSignature ::= identifier "." identifier formalParameterList ;
incrementOperator ::= "++" | "--" ;
mapLiteral ::= "const"? typeArguments? "{" (mapLiteralEntry ("," mapLiteralEntry)* ","?)? "}" ;
equalityExpression ::= (relationalExpression (equalityOperator relationalExpression)?) | ("super" equalityOperator relationalExpression) ;
staticFinalDeclaration ::= identifier "=" expression ;
listLiteral ::= "const"? typeArguments? "[" (expressionList ","?)? "]" ;
breakStatement ::= "break" identifier? ";" ;
bitwiseOrExpression ::= (bitwiseXorExpression ("|" bitwiseXorExpression)*) | ("super" ("|" bitwiseXorExpression)+) ;
throwStatement ::= "throw" expression? ";" ;
nullLiteral ::= "null" ;
unaryExpression ::= prefixExpression | postfixExpression | (unaryOperator "super") | ("-" "super") | (incrementOperator assignableExpression) ;
forStatement ::= "for" "(" forLoopParts ")" statement ;
classMemberDefinition ::= (declaration ";") | (methodSignature functionBody) ;
doStatement ::= "do" statement "while" "(" expression ")" ";" ;
bitwiseXorExpression ::= (bitwiseAndExpression ("^" bitwiseAndExpression)*) | ("super" ("^" bitwiseAndExpression)+) ;
constantConstructorSignature ::= "const" qualified formalParameterList ;
fieldFormalParameter ::= finalVarOrType? "this" "." identifier ;
returnStatement ::= "return" expression? ";" ;
relationalExpression ::= (shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?) | ("super" relationalOperator shiftExpression) ;
bitwiseAndExpression ::= (equalityExpression ("&" equalityExpression)*) | ("super" ("&" equalityExpression)+) ;
initializedIdentifier ::= identifier ("=" expression)? ;
compoundAssignmentOperator ::= "*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | (">" ">" ">" "="?) | ("<" "<" "="?) | "&=" | "^=" | "|=" ;
switchStatement ::= "switch" "(" expression ")" "{" switchCase* defaultCase? "}" ;
multiplicativeOperator ::= "*" | "/" | "%" | "~/" ;
functionBody ::= ("=>" expression ";") | block ;
factorySpecification ::= "factory" identifier typeParameters? ;
finallyPart ::= "finally" block ;
forInitializerStatement ::= (initializedVariableDeclaration ";") | (expression? ";") ;
namedArgument ::= label expression ;
normalFormalParameter ::= functionSignature | fieldFormalParameter | simpleFormalParameter ;
namedFormalParameters ::= "[" defaultFormalParameter ("," defaultFormalParameter)* "]" ;
defaultCase ::= label? ("case" expression ":")* "default" ":" statements ;
assignmentOperator ::= "=" | compoundAssignmentOperator ;
additiveOperator ::= "+" | "-" ;
functionExpression ::= (returnType? identifier)? formalParameterList functionExpressionBody ;
typeParameter ::= identifier ("extends" type)? ;
multiplicativeExpression ::= (unaryExpression (multiplicativeOperator unaryExpression)*) | ("super" (multiplicativeOperator unaryExpression)+) ;
returnType ::= "void" | type ;
functionPrefix ::= returnType? identifier ;
continueStatement ::= "continue" identifier? ";" ;
fieldInitializer ::= ("this" ".")? identifier "=" conditionalExpression ;
factoryConstructorSignature ::= "factory" qualified typeVariables? ("." identifier)? formalParameterList ;
switchCase ::= label? ("case" expression ":")+ statements ;
additiveExpression ::= (multiplicativeExpression (additiveOperator multiplicativeExpression)*) | ("super" (additiveOperator multiplicativeExpression)+) ;
logicalOrExpression ::= logicalAndExpression ("||" logicalAndExpression)* ;
declaredIdentifier ::= finalVarOrType identifier ;
--------------------dart::google.bgf--------------------
mapLiteralEntry ::= STRING ":" expression ;
libraryBody ::= libraryImport? librarySource? ;
userDefinableOperator ::= multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | bitwiseOperator | "==" | "~" | NEGATE | ("[" "]") | ("[" "]" "=") ;
argumentList ::= (namedArgument ("," namedArgument)*) | (expressionList ("," namedArgument)*) ;
constInitializedIdentifier ::= identifier ("=" constantExpression)? ;
defaultFormalParameter ::= normalFormalParameter ("=" constantExpression)? ;
typeList ::= type ("," type)* ;
bitwiseOperator ::= "&" | "^" | "|" ;
tryStatement ::= TRY block (catchPart+ finallyPart?) | finallyPart ;
staticFinalDeclarationList ::= staticFinalDeclaration ("," staticFinalDeclaration)* ;
libraryDefinition ::= LIBRARY "{" libraryBody "}" ;
isOperator ::= IS "!"? ;
finalVarOrType ::= (FINAL type?) | VAR | type ;
postfixExpression ::= (assignableExpression postfixOperator) | (primary selector*) ;
interfaceDefinition ::= INTERFACE identifier typeParameters? superinterfaces? factorySpecification? "{" interfaceMemberDefinition* "}" ;
classDefinition ::= (CLASS identifier typeParameters? superclass? interfaces? "{" classMemberDefinition* "}") | (CLASS identifier typeParameters? interfaces? NATIVE STRING "{" classMemberDefinition* "}") ;
relationalOperator ::= ">=" | ">" | "<=" | "<" ;
initializedVariableDeclaration ::= declaredIdentifier ("=" expression)? ("," initializedIdentifier)* ;
simpleFormalParameter ::= declaredIdentifier | identifier ;
compilationUnit ::= HASHBANG? directive* topLevelDefinition* EOF ;
interfaceMemberDefinition ::= (STATIC FINAL type? initializedIdentifierList ";") | (functionDeclaration ";") | (constantConstructorDeclaration ";") | (namedConstructorDeclaration ";") | (specialSignatureDefinition ";") | (variableDeclaration ";") ;
superCallOrFieldInitializer ::= (SUPER arguments) | (SUPER "." identifier arguments) | fieldInitializer ;
constantConstructorDeclaration ::= CONST qualified formalParameterList ;
topLevelDefinition ::= classDefinition | interfaceDefinition | functionTypeAlias | (functionDeclaration functionBodyOrNative) | (returnType? getOrSet identifier formalParameterList functionBodyOrNative) | (FINAL type? staticFinalDeclarationList ";") | (constInitializedVariableDeclaration ";") ;
primaryNoFE ::= THIS | (SUPER assignableSelector) | literal | identifier | (CONST? typeArguments? compoundLiteral) | (NEW | CONST type ("." identifier)? arguments) | expressionInParentheses ;
libraryUnit ::= libraryDefinition EOF ;
variableDeclaration ::= declaredIdentifier ("," identifier)* ;
constantExpression ::= expression ;
initializedIdentifierList ::= initializedIdentifier ("," initializedIdentifier)* ;
methodDeclaration ::= factoryConstructorDeclaration | (STATIC functionDeclaration) | specialSignatureDefinition | (functionDeclaration initializers?) | (namedConstructorDeclaration initializers?) ;
expressionList ::= expression ("," expression)* ;
prefixOperator ::= additiveOperator | negateOperator ;
forLoopParts ::= (forInitializerStatement expression? ";" expressionList?) | (declaredIdentifier IN expression) | (identifier IN expression) ;
functionExpressionBody ::= ("=>" expression) | block ;
catchPart ::= CATCH "(" declaredIdentifier ("," declaredIdentifier)? ")" block ;
nonLabelledStatement ::= block | (initializedVariableDeclaration ";") | iterationStatement | selectionStatement | tryStatement | (BREAK identifier? ";") | (CONTINUE identifier? ";") | (RETURN expression? ";") | (THROW expression? ";") | (expression? ";") | (ASSERT "(" conditionalExpression ")" ";") | (functionDeclaration functionBody) ;
factoryConstructorDeclaration ::= FACTORY qualified typeParameters? ("." identifier)? formalParameterList ;
getOrSet ::= GET | SET ;
assignableSelector ::= ("[" expression "]") | ("." identifier) ;
shiftOperator ::= "<<" | ">>>" | ">>" ;
negateOperator ::= "!" | "~" ;
logicalAndExpression ::= bitwiseOrExpression ("&&" bitwiseOrExpression)* ;
typeParameters ::= "<" typeParameter ("," typeParameter)* ">" ;
selectionStatement ::= (IF "(" expression ")" statement (ELSE statement)?) | (SWITCH "(" expression ")" "{" switchCase* defaultCase? "}") ;
primaryFE ::= functionExpression | primaryNoFE ;
assignableExpression ::= (primary (arguments* assignableSelector)+) | (SUPER assignableSelector) | identifier ;
libraryImport ::= IMPORT "=" "[" importReferences? "]" ;
functionTypeAlias ::= TYPEDEF functionPrefix typeParameters? formalParameterList ";" ;
equalityOperator ::= "==" | "!=" | "===" | "!==" ;
conditionalExpression ::= logicalOrExpression ("?" expression ":" expression)? ;
expressionInParentheses ::= "(" expression ")" ;
typeArguments ::= "<" typeList ">" ;
shiftExpression ::= (additiveExpression (shiftOperator additiveExpression)*) | (SUPER (shiftOperator additiveExpression)+) ;
namedConstructorDeclaration ::= identifier "." identifier formalParameterList ;
postfixOperator ::= incrementOperator ;
formalParameterList ::= ("(" namedFormalParameters? ")") | ("(" normalFormalParameter normalFormalParameterTail? ")") ;
librarySource ::= SOURCE "=" "[" sourceUrls? "]" ;
incrementOperator ::= "++" | "--" ;
mapLiteral ::= "{" (mapLiteralEntry ("," mapLiteralEntry)* ","?)? "}" ;
staticFinalDeclaration ::= identifier "=" constantExpression ;
specialSignatureDefinition ::= (STATIC? returnType? getOrSet identifier formalParameterList) | (returnType? OPERATOR userDefinableOperator formalParameterList) ;
equalityExpression ::= (relationalExpression (equalityOperator relationalExpression)?) | (SUPER equalityOperator relationalExpression) ;
listLiteral ::= "[" (expressionList ","?)? "]" ;
constInitializedVariableDeclaration ::= declaredIdentifier ("=" constantExpression)? ("," constInitializedIdentifier)* ;
bitwiseOrExpression ::= (bitwiseXorExpression ("|" bitwiseXorExpression)*) | (SUPER ("|" bitwiseXorExpression)+) ;
unaryExpression ::= postfixExpression | (prefixOperator unaryExpression) | (negateOperator SUPER) | ("-" SUPER) | (incrementOperator assignableExpression) ;
importReference ::= (IDENTIFIER ":")? STRING ;
classMemberDefinition ::= (declaration ";") | (constructorDeclaration ";") | (methodDeclaration functionBodyOrNative) | (CONST factoryConstructorDeclaration functionNative) ;
bitwiseXorExpression ::= (bitwiseAndExpression ("^" bitwiseAndExpression)*) | (SUPER ("^" bitwiseAndExpression)+) ;
constructorDeclaration ::= (identifier formalParameterList (redirection | initializers)?) | (namedConstructorDeclaration (redirection | initializers)?) ;
fieldFormalParameter ::= finalVarOrType? THIS "." identifier ;
sourceUrls ::= STRING ("," STRING)* ","? ;
relationalExpression ::= (shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?) | (SUPER relationalOperator shiftExpression) ;
bitwiseAndExpression ::= (equalityExpression ("&" equalityExpression)*) | (SUPER ("&" equalityExpression)+) ;
initializedIdentifier ::= identifier ("=" expression)? ;
functionBody ::= ("=>" expression ";") | block ;
multiplicativeOperator ::= "*" | "/" | "%" | "~/" ;
factorySpecification ::= FACTORY type ;
forInitializerStatement ::= (initializedVariableDeclaration ";") | (expression? ";") ;
finallyPart ::= FINALLY block ;
namedArgument ::= label expression ;
functionBodyOrNative ::= (NATIVE functionBody) | functionNative | functionBody ;
normalFormalParameter ::= functionDeclaration | fieldFormalParameter | simpleFormalParameter ;
iterationStatement ::= (WHILE "(" expression ")" statement) | (DO statement WHILE "(" expression ")" ";") | (FOR "(" forLoopParts ")" statement) ;
namedFormalParameters ::= "[" defaultFormalParameter ("," defaultFormalParameter)* "]" ;
assignmentOperator ::= "=" | "*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | ">>>=" | ">>=" | "&=" | "^=" | "|=" ;
defaultCase ::= label? (CASE expression ":")* DEFAULT ":" statements ;
additiveOperator ::= "+" | "-" ;
functionExpression ::= (returnType? identifier)? formalParameterList functionExpressionBody ;
functionNative ::= NATIVE STRING? ";" ;
typeParameter ::= identifier (EXTENDS type)? ;
multiplicativeExpression ::= (unaryExpression (multiplicativeOperator unaryExpression)*) | (SUPER (multiplicativeOperator unaryExpression)+) ;
importReferences ::= importReference ("," importReference)* ","? ;
functionPrefix ::= returnType? identifier ;
returnType ::= VOID | type ;
fieldInitializer ::= (THIS ".")? identifier "=" conditionalExpression ;
additiveExpression ::= (multiplicativeExpression (additiveOperator multiplicativeExpression)*) | (SUPER (additiveOperator multiplicativeExpression)+) ;
logicalOrExpression ::= logicalAndExpression ("||" logicalAndExpression)* ;
switchCase ::= label? (CASE expression ":")+ statements ;
compoundLiteral ::= listLiteral | mapLiteral ;
normalFormalParameterTail ::= ("," namedFormalParameters) | ("," normalFormalParameter normalFormalParameterTail?) ;
declaredIdentifier ::= (FINAL type? identifier) | (VAR identifier) | (type identifier) ;
functionDeclaration ::= returnType? identifier formalParameterList ;
--------------------dart::spec-0.05.bgf--------------------
mapLiteralEntry ::= (identifier ":" expression) | (stringLiteral ":" expression) ;
scriptDefinition ::= scriptTag? libraryName? import* include* resource* topLevelDefinition* ;
argumentList ::= (namedArgument ("," namedArgument)*) | (expressionList ("," namedArgument)*) ;
setterSignature ::= "static"? returnType? "set" identifier formalParameterList ;
defaultFormalParameter ::= normalFormalParameter ("=" constantExpression)? ;
typeList ::= type ("," type)* ;
bitwiseOperator ::= "&" | "^" | "|" ;
tryStatement ::= "try" block (catchPart+ finallyPart?) | finallyPart ;
operatorSignature ::= returnType? operator operator formalParameterList ;
unaryOperator ::= negateOperator ;
staticFinalDeclarationList ::= staticFinalDeclaration ("," staticFinalDeclaration)* ;
libraryDefinition ::= scriptTag? libraryName import* include* resource* topLevelDefinition* ;
isOperator ::= "is" "!"? ;
finalVarOrType ::= ("final" type?) | "var" | type ;
postfixExpression ::= (assignableExpression postfixOperator) | (primary selector*) ;
getterSignature ::= "static"? returnType? "get" identifier formalParameterList ;
interfaceDefinition ::= "interface" identifier typeParameters? superinterfaces? factorySpecification? "{" interfaceMemberDefinition* "}" ;
relationalOperator ::= ">=" | ">" | "<=" | "<" ;
classDefinition ::= "class" identifier typeParameters? superclass? interfaces? "{" classMemberDefinition* "}" ;
initializedVariableDeclaration ::= declaredIdentifier ("=" expression)? ("," initializedIdentifier)* ;
simpleFormalParameter ::= declaredIdentifier | identifier ;
compilationUnit ::= topLevelDefinition* EOF ;
booleanLiteral ::= "true" | "false" ;
libraryName ::= "#" "library" "(" stringLiteral ")" ";" ;
interfaceMemberDefinition ::= ("static" "final" type? initializedIdentifierList ";") | (functionSignature ";") | (constantConstructorSignature ";") | (namedConstructorSignature ";") | (getterSignature ";") | (setterSignature ";") | (operatorSignature ";") | (variableDeclaration ";") ;
superCallOrFieldInitializer ::= ("super" arguments) | ("super" "." identifier arguments) | fieldInitializer ;
topLevelDefinition ::= classDefinition | interfaceDefinition | functionTypeAlias | (functionSignature functionBody) | (returnType? getOrSet identifier formalParameterList functionBody) | ("final" type? staticFinalDeclarationList ";") | (variableDeclaration ";") ;
numericLiteral ::= NUMBER | HEX_NUMBER ;
stringLiteral ::= ("@"? MULTI_LINE_STRING) | SINGLE_LINE_STRING ;
constructorSignature ::= (identifier formalParameterList) | namedConstructorSignature ;
variableDeclaration ::= declaredIdentifier ("," identifier)* ;
newExpression ::= "new" type ("." identifier)? arguments ;
methodSignature ::= factoryConstructorSignature | ("static" functionSignature) | getterSignature | setterSignature | operatorSignature | (functionSignature initializers?) | (namedConstructorSignature initializers?) ;
thisExpression ::= "this" ;
expressionList ::= expression ("," expression)* ;
prefixOperator ::= "-" | negateOperator ;
forLoopParts ::= (forInitializerStatement expression? ";" expressionList?) | (declaredIdentifier "in" expression) | (identifier "in" expression) ;
ifStatement ::= "if" "(" expression ")" statement ("else" statement)? ;
functionExpressionBody ::= ("=>" expression) | block ;
scriptTag ::= "#!" ("~" NEWLINE)* NEWLINE ;
catchPart ::= "catch" "(" simpleFormalParameter ("," simpleFormalParameter)? ")" block ;
nonLabelledStatement ::= block | (initializedVariableDeclaration ";") | forStatement | whileStatement | doStatement | switchStatement | ifStatement | tryStatement | breakStatement | continueStatement | returnStatement | throwStatement | expressionStatement | assertStatement | (functionSignature functionBody) ;
getOrSet ::= "get" | "set" ;
assertStatement ::= "assert" "(" conditionalExpression ")" ";" ;
assignableSelector ::= ("[" expression "]") | ("." identifier) ;
shiftOperator ::= "<<" | ">>>" | ">>" ;
logicalAndExpression ::= bitwiseOrExpression ("&&" bitwiseOrExpression)* ;
negateOperator ::= "!" | "~" ;
binaryOperator ::= multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | equalityOperator | bitwiseOperator ;
typeParameters ::= "<" typeParameter ("," typeParameter)* ">" ;
assignableExpression ::= (primary (arguments* assignableSelector)+) | ("super" assignableSelector) | identifier ;
normalFormalParameters ::= normalFormalParameter ("," normalFormalParameter)* ;
functionSignature ::= returnType? identifier formalParameterList ;
functionTypeAlias ::= "typedef" functionPrefix typeParameters? formalParameterList ";" ;
whileStatement ::= "while" "(" expression ")" statement ;
equalityOperator ::= "==" | "!=" | "===" | "!==" ;
conditionalExpression ::= logicalOrExpression ("?" expression ":" expression)? ;
typeArguments ::= "<" typeList ">" ;
shiftExpression ::= (additiveExpression (shiftOperator additiveExpression)*) | ("super" (shiftOperator additiveExpression)+) ;
constObjectExpression ::= "const" type ("." identifier)? arguments ;
postfixOperator ::= incrementOperator ;
formalParameterList ::= ("(" ")") | ("(" normalFormalParameters ("," namedFormalParameters)? ")") | ("(" namedFormalParameters ")") ;
expressionStatement ::= expression? ";" ;
namedConstructorSignature ::= identifier "." identifier formalParameterList ;
incrementOperator ::= "++" | "--" ;
mapLiteral ::= "const"? typeArguments? "{" (mapLiteralEntry ("," mapLiteralEntry)* ","?)? "}" ;
equalityExpression ::= (relationalExpression (equalityOperator relationalExpression)?) | ("super" equalityOperator relationalExpression) ;
listLiteral ::= "const"? typeArguments? "[" (expressionList ","?)? "]" ;
breakStatement ::= "break" identifier? ";" ;
bitwiseOrExpression ::= (bitwiseXorExpression ("|" bitwiseXorExpression)*) | ("super" ("|" bitwiseXorExpression)+) ;
throwStatement ::= "throw" expression? ";" ;
nullLiteral ::= "null" ;
unaryExpression ::= (prefixOperator unaryExpression) | postfixExpression | (unaryOperator "super") | ("-" "super") | (incrementOperator assignableExpression) ;
forStatement ::= "for" "(" forLoopParts ")" statement ;
classMemberDefinition ::= (declaration ";") | (methodSignature functionBody) ;
doStatement ::= "do" statement "while" "(" expression ")" ";" ;
bitwiseXorExpression ::= (bitwiseAndExpression ("^" bitwiseAndExpression)*) | ("super" ("^" bitwiseAndExpression)+) ;
constantConstructorSignature ::= "const" qualified formalParameterList ;
fieldFormalParameter ::= finalVarOrType? "this" "." identifier ;
returnStatement ::= "return" expression? ";" ;
relationalExpression ::= (shiftExpression ((isOperator type) | (relationalOperator shiftExpression))?) | ("super" relationalOperator shiftExpression) ;
bitwiseAndExpression ::= (equalityExpression ("&" equalityExpression)*) | ("super" ("&" equalityExpression)+) ;
initializedIdentifier ::= identifier ("=" expression)? ;
compoundAssignmentOperator ::= "*=" | "/=" | "~/=" | "%=" | "+=" | "-=" | "<<=" | ">>>=" | ">>=" | "&=" | "^=" | "|=" ;
switchStatement ::= "switch" "(" expression ")" "{" switchCase* defaultCase? "}" ;
multiplicativeOperator ::= "*" | "/" | "%" | "~/" ;
functionBody ::= ("=>" expression ";") | block ;
factorySpecification ::= "factory" qualified typeParameters? ;
finallyPart ::= "finally" block ;
forInitializerStatement ::= (initializedVariableDeclaration ";") | (expression? ";") ;
namedArgument ::= label expression ;
normalFormalParameter ::= functionSignature | fieldFormalParameter | simpleFormalParameter ;
namedFormalParameters ::= "[" defaultFormalParameter ("," defaultFormalParameter)* "]" ;
defaultCase ::= label? ("case" expression ":")* "default" ":" statements ;
assignmentOperator ::= "=" | compoundAssignmentOperator ;
additiveOperator ::= "+" | "-" ;
functionExpression ::= (returnType? identifier)? formalParameterList functionExpressionBody ;
typeParameter ::= identifier ("extends" type)? ;
multiplicativeExpression ::= (unaryExpression (multiplicativeOperator unaryExpression)*) | ("super" (multiplicativeOperator unaryExpression)+) ;
functionPrefix ::= returnType? identifier ;
returnType ::= "void" | type ;
continueStatement ::= "continue" identifier? ";" ;
fieldInitializer ::= ("this" ".")? identifier "=" conditionalExpression ;
factoryConstructorSignature ::= "factory" qualified typeParameters? ("." identifier)? formalParameterList ;
switchCase ::= label? ("case" expression ":")+ statements ;
additiveExpression ::= (multiplicativeExpression (additiveOperator multiplicativeExpression)*) | ("super" (additiveOperator multiplicativeExpression)+) ;
logicalOrExpression ::= logicalAndExpression ("||" logicalAndExpression)* ;
declaredIdentifier ::= finalVarOrType identifier ;
--------------------java::java-5-habelitz.bgf--------------------
annotationDefaultValue ::= DEFAULT annotationElementValue ;
interfaceBody ::= LCURLY interfaceScopeDeclarations* RCURLY ;
forInit ::= localVariableDeclaration | expressionList | ε ;
typeList ::= type (COMMA type)* ;
genericTypeParameter ::= IDENT bound? ;
enumClassScopeDeclarations ::= SEMI classScopeDeclarations* ;
interfaceScopeDeclarations ::= (modifierList (genericTypeParameterList? (type IDENT formalParameterList arrayDeclaratorList? throwsClause? SEMI) | (VOID IDENT formalParameterList throwsClause? SEMI)) | (type interfaceFieldDeclaratorList SEMI)) | typeDeclaration | SEMI ;
parenthesizedExpression ::= LPAREN expression RPAREN ;
localVariableDeclaration ::= localModifierList type classFieldDeclaratorList ;
qualifiedIdentList ::= qualifiedIdentifier (COMMA qualifiedIdentifier)* ;
annotationBody ::= LCURLY annotationScopeDeclarations* RCURLY ;
classFieldDeclaratorList ::= classFieldDeclarator (COMMA classFieldDeclarator)* ;
typeDecls ::= typeDeclaration | SEMI ;
annotationList ::= annotation* ;
qualifiedIdentExpression ::= qualifiedIdentifier ((arrayDeclarator+ DOT CLASS) | arguments | (outerDot::DOT CLASS | (genericTypeArgumentListSimplified (Super::SUPER arguments) | (SUPER innerDot::DOT IDENT arguments) | (IDENT arguments)) | THIS | (Super::SUPER arguments) | innerNewExpression))? ;
arrayDeclarator ::= LBRACK RBRACK ;
interfaceTypeDeclaration ::= INTERFACE IDENT genericTypeParameterList? interfaceExtendsClause? interfaceBody ;
inclusiveOrExpression ::= exclusiveOrExpression (OR exclusiveOrExpression)* ;
compilationUnit ::= annotationList packageDeclaration? importDeclaration* typeDecls* ;
qualifiedIdentifier ::= IDENT (DOT ident::IDENT)* ;
localModifier ::= FINAL | annotation ;
blockStatement ::= (localVariableDeclaration SEMI) | typeDeclaration | statement ;
typeDeclaration ::= modifierList classTypeDeclaration | interfaceTypeDeclaration | enumTypeDeclaration | annotationTypeDeclaration ;
annotationInit ::= LPAREN annotationInitializers RPAREN ;
javaSource ::= compilationUnit ;
annotationElementValueExpression ::= conditionalExpression ;
newExpression ::= NEW (primitiveType newArrayConstruction) | (genericTypeArgumentListSimplified? qualifiedTypeIdentSimplified newArrayConstruction | (arguments classBody?)) ;
expressionList ::= expression (COMMA expression)* ;
typeIdent ::= IDENT genericTypeArgumentList? ;
packageDeclaration ::= PACKAGE qualifiedIdentifier SEMI ;
finallyClause ::= FINALLY block ;
forCondition ::= expression? ;
interfaceFieldDeclarator ::= variableDeclaratorId ASSIGN variableInitializer ;
switchCaseLabel ::= CASE expression COLON blockStatement* ;
classExtendsClause ::= EXTENDS type ;
andExpression ::= equalityExpression (AND equalityExpression)* ;
enumConstants ::= enumConstant (COMMA enumConstant)* ;
typeIdentSimplified ::= IDENT genericTypeArgumentListSimplified? ;
genericTypeArgumentList ::= LESS_THAN genericTypeArgument (COMMA genericTypeArgument)* genericTypeListClosing ;
arrayInitializer ::= LCURLY (variableInitializer (COMMA variableInitializer)* COMMA?)? RCURLY ;
classTypeDeclaration ::= CLASS IDENT genericTypeParameterList? classExtendsClause? implementsClause? classBody ;
variableDeclaratorId ::= IDENT arrayDeclaratorList? ;
genericTypeListClosing ::= GREATER_THAN | SHIFT_RIGHT | BIT_SHIFT_RIGHT | ε ;
variableInitializer ::= arrayInitializer | expression ;
logicalAndExpression ::= inclusiveOrExpression (LOGICAL_AND inclusiveOrExpression)* ;
enumConstant ::= annotationList IDENT arguments? classBody? ;
assignmentExpression ::= conditionalExpression (ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | SHIFT_LEFT_ASSIGN | SHIFT_RIGHT_ASSIGN | BIT_SHIFT_RIGHT_ASSIGN assignmentExpression)? ;
genericTypeArgumentListSimplified ::= LESS_THAN genericTypeArgumentSimplified (COMMA genericTypeArgumentSimplified)* genericTypeListClosing ;
enumBody ::= LCURLY enumScopeDeclarations RCURLY ;
primitiveType ::= BOOLEAN | CHAR | BYTE | SHORT | INT | LONG | FLOAT | DOUBLE ;
forUpdater ::= expressionList? ;
implementsClause ::= IMPLEMENTS typeList ;
annotationScopeDeclarations ::= (modifierList type (IDENT LPAREN RPAREN annotationDefaultValue? SEMI) | (classFieldDeclaratorList SEMI)) | typeDeclaration ;
conditionalExpression ::= logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
classBody ::= LCURLY classScopeDeclarations* RCURLY ;
primaryExpression ::= parenthesizedExpression | literal | newExpression | qualifiedIdentExpression | (genericTypeArgumentListSimplified (SUPER arguments | (DOT IDENT arguments)) | (IDENT arguments) | (THIS arguments)) | (THIS arguments?) | (SUPER arguments) | (SUPER DOT IDENT arguments | ε) | (primitiveType arrayDeclarator* DOT CLASS) | (VOID DOT CLASS) ;
shiftExpression ::= additiveExpression (BIT_SHIFT_RIGHT | SHIFT_RIGHT | SHIFT_LEFT additiveExpression)* ;
formalParameterList ::= LPAREN (formalParameterStandardDecl (COMMA formalParameterStandardDecl)* (COMMA formalParameterVarArgDecl)?) | formalParameterVarArgDecl | ε RPAREN ;
genericTypeParameterList ::= LESS_THAN genericTypeParameter (COMMA genericTypeParameter)* genericTypeListClosing ;
classFieldDeclarator ::= variableDeclaratorId (ASSIGN variableInitializer)? ;
annotationInitializer ::= IDENT ASSIGN annotationElementValue ;
equalityExpression ::= instanceOfExpression (EQUAL | NOT_EQUAL instanceOfExpression)* ;
annotationTypeDeclaration ::= AT INTERFACE IDENT annotationBody ;
interfaceExtendsClause ::= EXTENDS typeList ;
enumScopeDeclarations ::= enumConstants COMMA? enumClassScopeDeclarations? ;
unaryExpressionNotPlusMinus ::= (NOT unaryExpression) | (LOGICAL_NOT unaryExpression) | (LPAREN type RPAREN unaryExpression) | postfixedExpression ;
arrayDeclaratorList ::= arrayDeclarator+ ;
unaryExpression ::= (PLUS unaryExpression) | (MINUS unaryExpression) | (INC postfixedExpression) | (DEC postfixedExpression) | unaryExpressionNotPlusMinus ;
annotationElementValue ::= annotationElementValueExpression | annotation | annotationElementValueArrayInitializer ;
switchCaseLabels ::= switchCaseLabel* ;
innerNewExpression ::= NEW genericTypeArgumentListSimplified? IDENT arguments classBody? ;
formalParameterStandardDecl ::= localModifierList type variableDeclaratorId ;
localModifierList ::= localModifier* ;
annotationInitializers ::= (annotationInitializer (COMMA annotationInitializer)*) | annotationElementValue ;
enumTypeDeclaration ::= ENUM IDENT implementsClause? enumBody ;
relationalExpression ::= shiftExpression (LESS_OR_EQUAL | GREATER_OR_EQUAL | LESS_THAN | GREATER_THAN shiftExpression)* ;
throwsClause ::= THROWS qualifiedIdentList ;
qualifiedTypeIdent ::= typeIdent (DOT typeIdent)* ;
objectType ::= qualifiedTypeIdent arrayDeclaratorList? ;
exclusiveOrExpression ::= andExpression (XOR andExpression)* ;
switchBlockLabels ::= switchCaseLabels switchDefaultLabel? switchCaseLabels ;
importDeclaration ::= IMPORT STATIC? qualifiedIdentifier DOTSTAR? SEMI ;
modifierList ::= modifier* ;
classScopeDeclarations ::= block | (STATIC block) | (modifierList (genericTypeParameterList? (type IDENT formalParameterList arrayDeclaratorList? throwsClause? block | SEMI) | (VOID IDENT formalParameterList throwsClause? block | SEMI) | (ident::IDENT formalParameterList throwsClause? block)) | (type classFieldDeclaratorList SEMI)) | typeDeclaration | SEMI ;
formalParameterVarArgDecl ::= localModifierList type ELLIPSIS variableDeclaratorId ;
qualifiedTypeIdentSimplified ::= typeIdentSimplified (DOT typeIdentSimplified)* ;
interfaceFieldDeclaratorList ::= interfaceFieldDeclarator (COMMA interfaceFieldDeclarator)* ;
genericTypeArgument ::= type | (QUESTION genericWildcardBoundType?) ;
multiplicativeExpression ::= unaryExpression (STAR | DIV | MOD unaryExpression)* ;
annotationElementValueArrayInitializer ::= LCURLY (annotationElementValue (COMMA annotationElementValue)*)? COMMA? RCURLY ;
simpleType ::= primitiveType arrayDeclaratorList? ;
postfixedExpression ::= primaryExpression ((outerDot::DOT (genericTypeArgumentListSimplified? IDENT arguments?) | THIS | (Super::SUPER arguments) | (SUPER innerDot::DOT IDENT arguments?) | innerNewExpression) | (LBRACK expression RBRACK))* (INC | DEC)? ;
catchClause ::= CATCH LPAREN formalParameterStandardDecl RPAREN block ;
newArrayConstruction ::= (arrayDeclaratorList arrayInitializer) | (LBRACK expression RBRACK (LBRACK expression RBRACK)* arrayDeclaratorList?) ;
switchDefaultLabel ::= DEFAULT COLON blockStatement* ;
genericWildcardBoundType ::= EXTENDS | SUPER type ;
genericTypeArgumentSimplified ::= type | QUESTION ;
logicalOrExpression ::= logicalAndExpression (LOGICAL_OR logicalAndExpression)* ;
instanceOfExpression ::= relationalExpression (INSTANCEOF type)? ;
additiveExpression ::= multiplicativeExpression (PLUS | MINUS multiplicativeExpression)* ;
--------------------java::java-5-parr.bgf--------------------
interfaceBodyDeclaration ::= (modifiers interfaceMemberDecl) | ";" ;
interfaceMemberDecl ::= interfaceMethodOrFieldDecl | interfaceGenericMethodDecl | ("void" Identifier voidInterfaceMethodDeclaratorRest) | interfaceDeclaration | classDeclaration ;
interfaceBody ::= "{" interfaceBodyDeclaration* "}" ;
formalParameter ::= variableModifiers type variableDeclaratorId ;
forInit ::= localVariableDeclaration | expressionList ;
typeList ::= type ("," type)* ;
innerCreator ::= nonWildcardTypeArguments? Identifier classCreatorRest ;
constantDeclarator ::= Identifier constantDeclaratorRest ;
classOrInterfaceModifier ::= annotation | "public" | "protected" | "private" | "abstract" | "static" | "final" | "strictfp" ;
variableModifier ::= "final" | annotation ;
localVariableDeclaration ::= variableModifiers type variableDeclarators ;
explicitGenericInvocation ::= nonWildcardTypeArguments Identifier arguments ;
forUpdate ::= expressionList ;
interfaceMethodOrFieldRest ::= (constantDeclaratorsRest ";") | interfaceMethodDeclaratorRest ;
enumConstantName ::= Identifier ;
enhancedForControl ::= variableModifiers type Identifier ":" expression ;
switchBlockStatementGroup ::= switchLabel+ blockStatement* ;
constantDeclaratorRest ::= ("[" "]")* "=" variableInitializer ;
normalClassDeclaration ::= "class" Identifier typeParameters? ("extends" type)? ("implements" typeList)? classBody ;
conditionalAndExpression ::= inclusiveOrExpression ("&&" inclusiveOrExpression)* ;
relationalOp ::= (t1::"<" t2::("="?)) | (t1::">" t2::("="?)) | "<" | ">" ;
booleanLiteral ::= "true" | "false" ;
statementExpression ::= expression ;
annotationConstantRest ::= variableDeclarators ;
inclusiveOrExpression ::= exclusiveOrExpression ("|" exclusiveOrExpression)* ;
compilationUnit ::= (annotations (packageDeclaration importDeclaration* typeDeclaration*) | (classOrInterfaceDeclaration typeDeclaration*)) | (packageDeclaration? importDeclaration* typeDeclaration*) ;
methodDeclaratorRest ::= formalParameters ("[" "]")* ("throws" qualifiedNameList)? methodBody | ";" ;
memberDecl ::= genericMethodOrConstructorDecl | memberDeclaration | ("void" Identifier voidMethodDeclaratorRest) | (Identifier constructorDeclaratorRest) | interfaceDeclaration | classDeclaration ;
annotationMethodRest ::= Identifier "(" ")" defaultValue? ;
typeBound ::= type ("&" type)* ;
classDeclaration ::= normalClassDeclaration | enumDeclaration ;
blockStatement ::= localVariableDeclarationStatement | classOrInterfaceDeclaration | statement ;
typeDeclaration ::= classOrInterfaceDeclaration | ";" ;
variableModifiers ::= variableModifier* ;
classBodyDeclaration ::= ";" | ("static"? block) | (modifiers memberDecl) ;
constantExpression ::= expression ;
identifierSuffix ::= (("[" "]")+ "." "class") | (("[" expression "]")+) | arguments | ("." "class") | ("." explicitGenericInvocation) | ("." "this") | ("." "super" arguments) | ("." "new" innerCreator) ;
annotationName ::= Identifier ("." Identifier)* ;
methodDeclaration ::= Identifier methodDeclaratorRest ;
classOrInterfaceType ::= Identifier typeArguments? ("." Identifier typeArguments?)* ;
explicitConstructorInvocation ::= (nonWildcardTypeArguments? "this" | "super" arguments ";") | (primary "." nonWildcardTypeArguments? "super" arguments ";") ;
expressionList ::= expression ("," expression)* ;
elementValue ::= conditionalExpression | annotation | elementValueArrayInitializer ;
packageDeclaration ::= "package" qualifiedName ";" ;
forControl ::= enhancedForControl | (forInit? ";" expression? ";" forUpdate?) ;
genericMethodOrConstructorRest ::= (type | "void" Identifier methodDeclaratorRest) | (Identifier constructorDeclaratorRest) ;
andExpression ::= equalityExpression ("&" equalityExpression)* ;
elementValuePair ::= Identifier "=" elementValue ;
enumConstants ::= enumConstant ("," enumConstant)* ;
variableDeclarator ::= variableDeclaratorId ("=" variableInitializer)? ;
annotationTypeBody ::= "{" annotationTypeElementDeclaration* "}" ;
arrayInitializer ::= "{" (variableInitializer ("," variableInitializer)* ","?)? "}" ;
variableDeclaratorId ::= Identifier ("[" "]")* ;
annotationTypeElementDeclaration ::= modifiers annotationTypeElementRest ;
qualifiedName ::= Identifier ("." Identifier)* ;
interfaceMethodOrFieldDecl ::= type Identifier interfaceMethodOrFieldRest ;
variableInitializer ::= arrayInitializer | expression ;
variableDeclarators ::= variableDeclarator ("," variableDeclarator)* ;
enumConstant ::= annotations? Identifier arguments? classBody? ;
typeParameters ::= "<" typeParameter ("," typeParameter)* ">" ;
enumBody ::= "{" enumConstants? ","? enumBodyDeclarations? "}" ;
primitiveType ::= "boolean" | "char" | "byte" | "short" | "int" | "long" | "float" | "double" ;
constructorDeclaratorRest ::= formalParameters ("throws" qualifiedNameList)? constructorBody ;
interfaceMethodDeclaratorRest ::= formalParameters ("[" "]")* ("throws" qualifiedNameList)? ";" ;
elementValueArrayInitializer ::= "{" (elementValue ("," elementValue)*)? ","? "}" ;
conditionalExpression ::= conditionalOrExpression ("?" expression ":" expression)? ;
constructorBody ::= "{" explicitConstructorInvocation? blockStatement* "}" ;
localVariableDeclarationStatement ::= localVariableDeclaration ";" ;
typeArguments ::= "<" typeArgument ("," typeArgument)* ">" ;
classBody ::= "{" classBodyDeclaration* "}" ;
shiftExpression ::= additiveExpression (shiftOp additiveExpression)* ;
formalParameters ::= "(" formalParameterDecls? ")" ;
enumDeclaration ::= ENUM Identifier ("implements" typeList)? enumBody ;
castExpression ::= ("(" primitiveType ")" unaryExpression) | ("(" type | expression ")" unaryExpressionNotPlusMinus) ;
nonWildcardTypeArguments ::= "<" typeList ">" ;
equalityExpression ::= instanceOfExpression ("==" | "!=" instanceOfExpression)* ;
annotationTypeDeclaration ::= "@" "interface" Identifier annotationTypeBody ;
defaultValue ::= "default" elementValue ;
formalParameterDecls ::= variableModifiers type formalParameterDeclsRest ;
superSuffix ::= arguments | ("." Identifier arguments?) ;
annotationMethodOrConstantRest ::= annotationMethodRest | annotationConstantRest ;
switchBlockStatementGroups ::= switchBlockStatementGroup* ;
unaryExpressionNotPlusMinus ::= ("~" unaryExpression) | ("!" unaryExpression) | castExpression | (primary selector* ("++" | "--")?) ;
genericMethodOrConstructorDecl ::= typeParameters genericMethodOrConstructorRest ;
interfaceGenericMethodDecl ::= typeParameters type | "void" Identifier interfaceMethodDeclaratorRest ;
annotationTypeElementRest ::= (type annotationMethodOrConstantRest ";") | (normalClassDeclaration ";"?) | (normalInterfaceDeclaration ";"?) | (enumDeclaration ";"?) | (annotationTypeDeclaration ";"?) ;
unaryExpression ::= ("+" unaryExpression) | ("-" unaryExpression) | ("++" unaryExpression) | ("--" unaryExpression) | unaryExpressionNotPlusMinus ;
methodBody ::= block ;
formalParameterDeclsRest ::= (variableDeclaratorId ("," formalParameterDecls)?) | ("..." variableDeclaratorId) ;
fieldDeclaration ::= variableDeclarators ";" ;
switchLabel ::= ("case" constantExpression ":") | ("case" enumConstantName ":") | ("default" ":") ;
relationalExpression ::= shiftExpression (relationalOp shiftExpression)* ;
classOrInterfaceModifiers ::= classOrInterfaceModifier* ;
enumBodyDeclarations ::= ";" classBodyDeclaration* ;
classOrInterfaceDeclaration ::= classOrInterfaceModifiers classDeclaration | interfaceDeclaration ;
voidMethodDeclaratorRest ::= formalParameters ("throws" qualifiedNameList)? methodBody | ";" ;
parExpression ::= "(" expression ")" ;
exclusiveOrExpression ::= andExpression ("^" andExpression)* ;
typeArgument ::= type | ("?" ("extends" | "super" type)?) ;
importDeclaration ::= "import" "static"? qualifiedName ("." "*")? ";" ;
createdName ::= classOrInterfaceType | primitiveType ;
constantDeclaratorsRest ::= constantDeclaratorRest ("," constantDeclarator)* ;
integerLiteral ::= HexLiteral | OctalLiteral | DecimalLiteral ;
assignmentOperator ::= "=" | "+=" | "-=" | "*=" | "/=" | "&=" | "|=" | "^=" | "%=" | (t1::"<" t2::"<" t3::"=") | (t1::">" t2::">" t3::">" t4::("="?)) | (t1::">" t2::">" t3::"=") ;
typeParameter ::= Identifier ("extends" typeBound)? ;
multiplicativeExpression ::= unaryExpression ("*" | "/" | "%" unaryExpression)* ;
voidInterfaceMethodDeclaratorRest ::= formalParameters ("throws" qualifiedNameList)? ";" ;
catchClause ::= "catch" "(" formalParameter ")" block ;
normalInterfaceDeclaration ::= "interface" Identifier typeParameters? ("extends" typeList)? interfaceBody ;
classCreatorRest ::= arguments classBody? ;
arrayCreatorRest ::= "[" ("]" ("[" "]")* arrayInitializer) | (expression "]" ("[" expression "]")* ("[" "]")*) ;
qualifiedNameList ::= qualifiedName ("," qualifiedName)* ;
additiveExpression ::= multiplicativeExpression ("+" | "-" multiplicativeExpression)* ;
instanceOfExpression ::= relationalExpression ("instanceof" type)? ;
elementValuePairs ::= elementValuePair ("," elementValuePair)* ;
shiftOp ::= (t1::"<" t2::("<"?)) | (t1::">" t2::">" t3::">") | (t1::">" t2::(">"?)) ;
interfaceDeclaration ::= normalInterfaceDeclaration | annotationTypeDeclaration ;
conditionalOrExpression ::= conditionalAndExpression ("||" conditionalAndExpression)* ;
memberDeclaration ::= type methodDeclaration | fieldDeclaration ;
--------------------java::java-5-stahl.bgf--------------------
typeArgumentsEnd ::= GT | SR | BSR ;
casesGroup ::= aCase+ caseSList ;
forInit ::= (declaration | expressionList)? ;
builtInTypeSpec ::= builtInType (lb::LBRACK RBRACK)* ;
classBlock ::= LCURLY (classField | SEMI)* RCURLY ;
identPrimary ::= ta1::typeArguments IDENT ((DOT ta2::typeArguments IDENT) | ε)* ((lp::LPAREN argList RPAREN) | ((lbc::LBRACK RBRACK)+))? ;
postfixExpression ::= primaryExpression ((DOT "this") | (DOT ta1::typeArguments (IDENT (lp::LPAREN argList RPAREN)?) | ("super" (lp3::LPAREN argList RPAREN) | (DOT ta2::typeArguments IDENT (lps::LPAREN argList RPAREN)?))) | (DOT newExpression) | (lb::LBRACK expression RBRACK))* ((in::INC) | (de::DEC))? ;
interfaceDefinition ::= "interface" IDENT tp::typeParameters ie::interfaceExtends ib::interfaceBlock ;
classDefinition ::= "class" IDENT tp::typeParameters sc::superClassClause ic::implementsClause cb::classBlock ;
inclusiveOrExpression ::= exclusiveOrExpression (BOR exclusiveOrExpression)* ;
compilationUnit ::= packageDefinition | ε importDefinition* typeDefinition* ;
variableDefinitions ::= variableDeclarator (COMMA variableDeclarator)* ;
enumConst ::= annotations IDENT enumConstInit classBlock? ;
classField ::= (mods::modifiers (it::innerTypeDef) | (tp::typeParameters (h::ctorHead s::constructorBody) | (md::memberDef))) | ("static" s3::compoundStatement) | (s4::compoundStatement) ;
caseSList ::= statement* ;
annotationInit ::= (lp::LPAREN (annotationMemberInit (COMMA annotationMemberInit)*) | annotationMemberValue | ε RPAREN) | ε ;
annotationMemberInit ::= IDENT ASSIGN annotationMemberValue ;
importDefinition ::= i::"import" "static"? identifierStar SEMI ;
newExpression ::= "new" typeArguments type (LPAREN argList RPAREN classBlock?) | (newArrayDeclarator arrayInitializer?) ;
classOrInterfaceType ::= IDENT typeArguments (DOT IDENT typeArguments)* ;
explicitConstructorInvocation ::= typeArguments ("this" lp1::LPAREN argList RPAREN SEMI) | ("super" lp2::LPAREN argList RPAREN SEMI) ;
expressionList ::= expression (COMMA expression)* ;
interfaceBlock ::= LCURLY (interfaceField | SEMI)* RCURLY ;
finallyClause ::= "finally" compoundStatement ;
parameterDeclarationList ::= (parameterDeclaration (COMMA parameterDeclaration)*)? ;
andExpression ::= equalityExpression (BAND equalityExpression)* ;
variableDeclarator ::= id::IDENT d::declaratorBrackets v::varInitializer ;
arrayInitializer ::= lc::LCURLY (initializer (COMMA initializer)*)? COMMA? RCURLY ;
annotationMemberValue ::= annotation | conditionalExpression | annotationMemberArrayInitializer ;
logicalAndExpression ::= inclusiveOrExpression (LAND inclusiveOrExpression)* ;
assignmentExpression ::= conditionalExpression (ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | SR_ASSIGN | BSR_ASSIGN | SL_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN assignmentExpression)? ;
typeParameters ::= (lt::LT typeParameter (COMMA typeParameter)* typeArgumentsEnd?) | ε ;
interfaceField ::= mods::modifiers (it::innerTypeDef) | (tp::typeParameters md::memberDef) ;
implementsClause ::= (i::"implements" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
conditionalExpression ::= logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
constructorBody ::= lc::LCURLY explicitConstructorInvocation? statement* RCURLY ;
annotationTypeDefinition ::= AT "interface" IDENT ab::annotationBlock ;
typeArguments ::= (lt::LT typeArgument (COMMA typeArgument)* typeArgumentsEnd?) | ε ;
varInitializer ::= (ASSIGN initializer)? ;
primaryExpression ::= (identPrimary (DOT "class")?) | constant | "true" | "false" | "null" | newExpression | "this" | "super" | (LPAREN assignmentExpression RPAREN) | (builtInType (lbt::LBRACK RBRACK)* DOT "class") ;
shiftExpression ::= additiveExpression (SL | SR | BSR additiveExpression)* ;
packageDefinition ::= annotations p::"package" identifier SEMI ;
innerTypeDef ::= (ed::enumDefinition) | (cd::classDefinition) | (id::interfaceDefinition) | (ad::annotationTypeDefinition) ;
enumDefinition ::= ENUM IDENT ic::implementsClause eb::enumBlock ;
equalityExpression ::= relationalExpression (NOT_EQUAL | EQUAL relationalExpression)* ;
aCase ::= ("case" expression) | "default" COLON ;
defaultValue ::= ("default" annotationMemberValue)? ;
typeDefinition ::= (m::modifiers classDefinition | enumDefinition | interfaceDefinition | annotationTypeDefinition) | SEMI ;
classTypeSpec ::= classOrInterfaceType (lb::LBRACK RBRACK)* ;
newArrayDeclarator ::= (lb::LBRACK expression? RBRACK)+ ;
unaryExpressionNotPlusMinus ::= (BNOT unaryExpression) | (LNOT unaryExpression) | (lpb::LPAREN builtInTypeSpec RPAREN unaryExpression) | (lp::LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus) | postfixExpression ;
unaryExpression ::= (INC unaryExpression) | (DEC unaryExpression) | (MINUS unaryExpression) | (PLUS unaryExpression) | unaryExpressionNotPlusMinus ;
parameterModifier ::= ("final" | annotation)* ;
interfaceExtends ::= (e::"extends" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
relationalExpression ::= shiftExpression ((LT | GT | LE | GE shiftExpression)*) | ("instanceof" typeSpec) ;
annotationBlock ::= LCURLY (annotationField | SEMI)* RCURLY ;
builtInType ::= "void" | "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" ;
throwsClause ::= "throws" identifier (COMMA identifier)* ;
declaratorBrackets ::= (lb::LBRACK RBRACK)* ;
identifierStar ::= IDENT (DOT IDENT)* (DOT STAR)? ;
exclusiveOrExpression ::= andExpression (BXOR andExpression)* ;
typeArgument ::= (q::QUESTION (("extends" referenceTypeSpec) | ("super" referenceTypeSpec))?) | referenceTypeSpec ;
typeSpec ::= classTypeSpec | builtInTypeSpec ;
ctorHead ::= IDENT LPAREN parameterDeclarationList RPAREN throwsClause? ;
argList ::= expressionList | ε ;
annotationMemberArrayInitializer ::= lc::LCURLY (annotationMemberValue (COMMA annotationMemberValue)*)? COMMA? RCURLY ;
tryBlock ::= "try" compoundStatement handler* finallyClause? ;
enumConstInit ::= (lp::LPAREN argList RPAREN) | ε ;
parameterDeclaration ::= pm::parameterModifier t::typeSpec (el::ELLIPSIS)? id::IDENT pd::declaratorBrackets ;
typeParameter ::= IDENT ("extends" classOrInterfaceType (BAND classOrInterfaceType)*)? ;
arrayTypeSpec ::= builtInType (lb::LBRACK RBRACK)+ ;
multiplicativeExpression ::= unaryExpression (STAR | DIV | MOD unaryExpression)* ;
superClassClause ::= ("extends" classOrInterfaceType)? ;
enumBlock ::= LCURLY (enumConst (COMMA enumConst)*)? COMMA? (SEMI (classField | SEMI)*)? RCURLY ;
annotationField ::= mods::modifiers (it::innerTypeDef) | (ts::typeSpec (i::IDENT LPAREN RPAREN dv::defaultValue SEMI) | (v::variableDefinitions SEMI)) ;
forCond ::= expression? ;
memberDef ::= t::typeSpec (IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets (tc::throwsClause)? SEMI | (s2::compoundStatement)) | (v::variableDefinitions SEMI) ;
compoundStatement ::= lc::LCURLY statement* RCURLY ;
additiveExpression ::= multiplicativeExpression (PLUS | MINUS multiplicativeExpression)* ;
logicalOrExpression ::= logicalAndExpression (LOR logicalAndExpression)* ;
forIter ::= expressionList? ;
referenceTypeSpec ::= classTypeSpec | arrayTypeSpec ;
--------------------java::java-5-studman.bgf--------------------
casesGroup ::= aCase+ caseSList ;
annotationMemberValueInitializer ::= conditionalExpression | annotation | annotationMemberArrayInitializer ;
forEachClause ::= p::parameterDeclaration COLON expression ;
forInit ::= (declaration | expressionList)? ;
builtInTypeSpec ::= builtInType (lb::LBRACK RBRACK)* ;
classBlock ::= LCURLY (classField | SEMI)* RCURLY ;
typeArgumentSpec ::= classTypeSpec | builtInTypeArraySpec ;
identPrimary ::= (ta1::typeArguments)? IDENT ((DOT (ta2::typeArguments)? IDENT) | ε)* ((lp::LPAREN argList RPAREN) | ((lbc::LBRACK RBRACK)+))? ;
postfixExpression ::= primaryExpression ((DOT typeArguments? (IDENT (lp::LPAREN argList RPAREN)?) | ("super" (lp3::LPAREN argList RPAREN) | (DOT typeArguments? IDENT (lps::LPAREN argList RPAREN)?))) | (DOT "this") | (DOT newExpression) | (lb::LBRACK expression RBRACK))* ((in::INC) | (de::DEC))? ;
interfaceDefinition ::= "interface" IDENT (tp::typeParameters)? ie::interfaceExtends ib::interfaceBlock ;
classDefinition ::= "class" IDENT (tp::typeParameters)? sc::superClassClause ic::implementsClause cb::classBlock ;
inclusiveOrExpression ::= exclusiveOrExpression (BOR exclusiveOrExpression)* ;
annotationArguments ::= annotationMemberValueInitializer | anntotationMemberValuePairs ;
compilationUnit ::= packageDefinition | ε importDefinition* typeDefinition* ;
variableDefinitions ::= variableDeclarator (COMMA variableDeclarator)* ;
annotationDefinition ::= AT "interface" IDENT ab::annotationBlock ;
classField ::= (mods::modifiers (td::typeDefinitionInternal) | ((tp::typeParameters)? (h::ctorHead s::constructorBody) | (t::typeSpec (IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets (tc::throwsClause)? (s2::compoundStatement) | SEMI) | (v::variableDefinitions SEMI)))) | ("static" s3::compoundStatement) | (s4::compoundStatement) ;
caseSList ::= statement* ;
anntotationMemberValuePairs ::= annotationMemberValuePair (COMMA annotationMemberValuePair)* ;
importDefinition ::= i::"import" "static"? identifierStar SEMI ;
newExpression ::= "new" typeArguments? type (LPAREN argList RPAREN classBlock?) | (newArrayDeclarator arrayInitializer?) ;
classOrInterfaceType ::= IDENT typeArguments? (DOT IDENT typeArguments?)* ;
explicitConstructorInvocation ::= typeArguments? ("this" lp1::LPAREN argList RPAREN SEMI) | ("super" lp2::LPAREN argList RPAREN SEMI) ;
expressionList ::= expression (COMMA expression)* ;
interfaceBlock ::= LCURLY (interfaceField | SEMI)* RCURLY ;
finallyClause ::= "finally" compoundStatement ;
parameterDeclarationList ::= ((parameterDeclaration (COMMA parameterDeclaration)* (COMMA variableLengthParameterDeclaration)?) | variableLengthParameterDeclaration)? ;
andExpression ::= equalityExpression (BAND equalityExpression)* ;
variableDeclarator ::= id::IDENT d::declaratorBrackets v::varInitializer ;
arrayInitializer ::= lc::LCURLY (initializer (COMMA initializer)* COMMA?)? RCURLY ;
enumConstantBlock ::= LCURLY (enumConstantField | SEMI)* RCURLY ;
logicalAndExpression ::= inclusiveOrExpression (LAND inclusiveOrExpression)* ;
enumConstant ::= an::annotations i::IDENT (LPAREN a::argList RPAREN)? (b::enumConstantBlock)? ;
assignmentExpression ::= conditionalExpression (ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | SR_ASSIGN | BSR_ASSIGN | SL_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN assignmentExpression)? ;
typeParameters ::= LT typeParameter (COMMA typeParameter)* typeArgumentsOrParametersEnd? ;
annotationMemberValuePair ::= i::IDENT ASSIGN v::annotationMemberValueInitializer ;
interfaceField ::= mods::modifiers (td::typeDefinitionInternal) | ((tp::typeParameters)? t::typeSpec (IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets (tc::throwsClause)? SEMI) | (v::variableDefinitions SEMI)) ;
implementsClause ::= (i::"implements" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
conditionalExpression ::= logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
constructorBody ::= lc::LCURLY explicitConstructorInvocation? statement* RCURLY ;
typeArguments ::= LT typeArgument (COMMA typeArgument)* typeArgumentsOrParametersEnd? ;
varInitializer ::= (ASSIGN initializer)? ;
shiftExpression ::= additiveExpression (SL | SR | BSR additiveExpression)* ;
primaryExpression ::= (identPrimary (DOT "class")?) | constant | "true" | "false" | "null" | newExpression | "this" | "super" | (LPAREN assignmentExpression RPAREN) | (builtInType (lbt::LBRACK RBRACK)* DOT "class") ;
packageDefinition ::= annotations p::"package" identifier SEMI ;
enumConstantField ::= (mods::modifiers (td::typeDefinitionInternal) | ((tp::typeParameters)? t::typeSpec (IDENT LPAREN param::parameterDeclarationList RPAREN rt::declaratorBrackets (tc::throwsClause)? (s2::compoundStatement) | SEMI) | (v::variableDefinitions SEMI))) | (s4::compoundStatement) ;
enumDefinition ::= "enum" IDENT ic::implementsClause eb::enumBlock ;
wildcardType ::= q::QUESTION typeArgumentBounds? ;
variableLengthParameterDeclaration ::= pm::parameterModifier t::typeSpec TRIPLE_DOT id::IDENT pd::declaratorBrackets ;
equalityExpression ::= relationalExpression (NOT_EQUAL | EQUAL relationalExpression)* ;
aCase ::= ("case" expression) | "default" COLON ;
traditionalForClause ::= forInit SEMI forCond SEMI forIter ;
typeDefinition ::= (m::modifiers typeDefinitionInternal) | SEMI ;
classTypeSpec ::= classOrInterfaceType (lb::LBRACK RBRACK)* ;
typeArgumentBounds ::= "extends" | "super" classOrInterfaceType ;
newArrayDeclarator ::= (lb::LBRACK expression? RBRACK)+ ;
unaryExpressionNotPlusMinus ::= (BNOT unaryExpression) | (LNOT unaryExpression) | (lpb::LPAREN builtInTypeSpec RPAREN unaryExpression) | (lp::LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus) | postfixExpression ;
unaryExpression ::= (INC unaryExpression) | (DEC unaryExpression) | (MINUS unaryExpression) | (PLUS unaryExpression) | unaryExpressionNotPlusMinus ;
forStatement ::= f::"for" LPAREN traditionalForClause | forEachClause RPAREN statement ;
typeParameterBounds ::= "extends" classOrInterfaceType (BAND classOrInterfaceType)* ;
parameterModifier ::= annotation* (f::"final")? annotation* ;
interfaceExtends ::= (e::"extends" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
relationalExpression ::= shiftExpression ((LT | GT | LE | GE shiftExpression)*) | ("instanceof" typeSpec) ;
annotationBlock ::= LCURLY (annotationField | SEMI)* RCURLY ;
builtInType ::= "void" | "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" ;
throwsClause ::= "throws" identifier (COMMA identifier)* ;
declaratorBrackets ::= (lb::LBRACK RBRACK)* ;
identifierStar ::= IDENT (DOT IDENT)* (DOT STAR)? ;
exclusiveOrExpression ::= andExpression (BXOR andExpression)* ;
builtInTypeArraySpec ::= builtInType (lb::LBRACK RBRACK)+ ;
typeArgument ::= typeArgumentSpec | wildcardType ;
typeSpec ::= classTypeSpec | builtInTypeSpec ;
ctorHead ::= IDENT LPAREN parameterDeclarationList RPAREN throwsClause? ;
argList ::= expressionList | ε ;
annotationMemberArrayInitializer ::= lc::LCURLY (annotationMemberArrayValueInitializer (COMMA annotationMemberArrayValueInitializer)* COMMA?)? RCURLY ;
tryBlock ::= "try" compoundStatement handler* finallyClause? ;
typeArgumentsOrParametersEnd ::= GT | SR | BSR ;
parameterDeclaration ::= pm::parameterModifier t::typeSpec id::IDENT pd::declaratorBrackets ;
typeParameter ::= id::IDENT typeParameterBounds? ;
multiplicativeExpression ::= unaryExpression (STAR | DIV | MOD unaryExpression)* ;
enumBlock ::= LCURLY (enumConstant (COMMA enumConstant)* COMMA?)? (SEMI (classField | SEMI)*)? RCURLY ;
superClassClause ::= ("extends" c::classOrInterfaceType)? ;
annotationField ::= mods::modifiers (td::typeDefinitionInternal) | (t::typeSpec (i::IDENT LPAREN RPAREN rt::declaratorBrackets ("default" amvi::annotationMemberValueInitializer)? SEMI) | (v::variableDefinitions SEMI)) ;
forCond ::= expression? ;
typeDefinitionInternal ::= classDefinition | interfaceDefinition | enumDefinition | annotationDefinition ;
compoundStatement ::= lc::LCURLY statement* RCURLY ;
additiveExpression ::= multiplicativeExpression (PLUS | MINUS multiplicativeExpression)* ;
logicalOrExpression ::= logicalAndExpression (LOR logicalAndExpression)* ;
annotationMemberArrayValueInitializer ::= conditionalExpression | annotation ;
forIter ::= expressionList? ;
--------------------odf::opendoc-1.0-strict.bgf--------------------
positiveLength ::= string() ;
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
styleNameRefs ::= string()* ;
nonNegativeInteger ::= integer() ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
borderWidths ::= positiveLength positiveLength positiveLength ;
cellRangeAddress ::= string() ;
lineMode ::= "continuous" | "skip-white-space" ;
cellRangeAddressList ::= string() ;
fontVariant ::= "normal" | "small-caps" ;
sectionAttr ::= (text:style-name::styleNameRef)? ;
 sectionAttr ::= text:name::string ;
 sectionAttr ::= (text:protected::boolean)? ;
 sectionAttr ::= (text:protection-key::string)? ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
cellAddress ::= string() ;
fontPitch ::= "fixed" | "variable" ;
pathData ::= string() ;
anyAttListOrElements ::= string()* anyElements ;
dateOrDateTime ::= string() ;
nonNegativeLength ::= string() ;
variableName ::= string() ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
languageCode ::= string() ;
countryCode ::= string() ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
anyURI ::= string() ;
textEncoding ::= string() ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
styleName ::= string() ;
dateTime ::= string() ;
styleNameRef ::= string() | ε ;
relativeLength ::= string() ;
namespacedToken ::= string() ;
mathMarkup ::= (α | string() | mathMarkup)* ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
timeOrDateTime ::= string() ;
nonNegativePixelLength ::= string() ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
positiveInteger ::= integer() ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
anyElements ::= (string()? anyAttListOrElements string()?)* ;
--------------------odf::opendoc-1.0.bgf--------------------
positiveLength ::= string() ;
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
styleNameRefs ::= string()* ;
nonNegativeInteger ::= integer() ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
borderWidths ::= positiveLength positiveLength positiveLength ;
cellRangeAddress ::= string() ;
lineMode ::= "continuous" | "skip-white-space" ;
cellRangeAddressList ::= string() ;
fontVariant ::= "normal" | "small-caps" ;
sectionAttr ::= (text:style-name::styleNameRef)? ;
 sectionAttr ::= text:name::string ;
 sectionAttr ::= (text:protected::boolean)? ;
 sectionAttr ::= (text:protection-key::string)? ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
cellAddress ::= string() ;
fontPitch ::= "fixed" | "variable" ;
pathData ::= string() ;
anyAttListOrElements ::= string()* anyElements ;
dateOrDateTime ::= string() ;
nonNegativeLength ::= string() ;
variableName ::= string() ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
languageCode ::= string() ;
countryCode ::= string() ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
anyURI ::= string() ;
textEncoding ::= string() ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
styleName ::= string() ;
dateTime ::= string() ;
styleNameRef ::= string() | ε ;
relativeLength ::= string() ;
namespacedToken ::= string() ;
mathMarkup ::= (α | string() | mathMarkup)* ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
timeOrDateTime ::= string() ;
nonNegativePixelLength ::= string() ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
positiveInteger ::= integer() ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
anyElements ::= (string()? anyAttListOrElements string()?)* ;
--------------------odf::opendoc-1.1-strict.bgf--------------------
positiveLength ::= string() ;
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
styleNameRefs ::= string()* ;
nonNegativeInteger ::= integer() ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
borderWidths ::= positiveLength positiveLength positiveLength ;
cellRangeAddress ::= string() ;
lineMode ::= "continuous" | "skip-white-space" ;
cellRangeAddressList ::= string() ;
fontVariant ::= "normal" | "small-caps" ;
sectionAttr ::= (text:style-name::styleNameRef)? ;
 sectionAttr ::= text:name::string ;
 sectionAttr ::= (text:protected::boolean)? ;
 sectionAttr ::= (text:protection-key::string)? ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
cellAddress ::= string() ;
fontPitch ::= "fixed" | "variable" ;
pathData ::= string() ;
anyAttListOrElements ::= string()* anyElements ;
dateOrDateTime ::= string() ;
nonNegativeLength ::= string() ;
variableName ::= string() ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
languageCode ::= string() ;
countryCode ::= string() ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
anyURI ::= string() ;
textEncoding ::= string() ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
styleName ::= string() ;
dateTime ::= string() ;
styleNameRef ::= string() | ε ;
relativeLength ::= string() ;
namespacedToken ::= string() ;
mathMarkup ::= (α | string() | mathMarkup)* ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
timeOrDateTime ::= string() ;
nonNegativePixelLength ::= string() ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
positiveInteger ::= integer() ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
anyElements ::= (string()? anyAttListOrElements string()?)* ;
--------------------odf::opendoc-1.1.bgf--------------------
positiveLength ::= string() ;
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
styleNameRefs ::= string()* ;
nonNegativeInteger ::= integer() ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
borderWidths ::= positiveLength positiveLength positiveLength ;
cellRangeAddress ::= string() ;
lineMode ::= "continuous" | "skip-white-space" ;
cellRangeAddressList ::= string() ;
fontVariant ::= "normal" | "small-caps" ;
sectionAttr ::= (text:style-name::styleNameRef)? ;
 sectionAttr ::= text:name::string ;
 sectionAttr ::= (text:protected::boolean)? ;
 sectionAttr ::= (text:protection-key::string)? ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "dash" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
cellAddress ::= string() ;
fontPitch ::= "fixed" | "variable" ;
pathData ::= string() ;
anyAttListOrElements ::= string()* anyElements ;
dateOrDateTime ::= string() ;
nonNegativeLength ::= string() ;
variableName ::= string() ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
languageCode ::= string() ;
countryCode ::= string() ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
anyURI ::= string() ;
textEncoding ::= string() ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
styleName ::= string() ;
dateTime ::= string() ;
styleNameRef ::= string() | ε ;
relativeLength ::= string() ;
namespacedToken ::= string() ;
mathMarkup ::= (α | string() | mathMarkup)* ;
horiBackPos ::= "left" | "center" | "right" ;
lineType ::= "none" | "single" | "double" ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
timeOrDateTime ::= string() ;
nonNegativePixelLength ::= string() ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
positiveInteger ::= integer() ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
anyElements ::= (string()? anyAttListOrElements string()?)* ;
--------------------odf::opendoc-1.2-dsig.bgf--------------------
dsMarkup ::= (α | string() | dsMarkup)* ;
--------------------odf::opendoc-1.2-manifest.bgf--------------------
anyAttListOrElements ::= string()* anyElements ;
nonNegativeInteger ::= integer() ;
anyElements ::= (string()? anyAttListOrElements string()?)* ;
anyURI ::= string() ;
namespacedToken ::= string() ;
--------------------odf::opendoc-1.2.bgf--------------------
positiveLength ::= string() ;
presentationEffectDirections ::= "none" | "from-left" | "from-top" | "from-right" | "from-bottom" | "from-center" | "from-upper-left" | "from-upper-right" | "from-lower-left" | "from-lower-right" | "to-left" | "to-top" | "to-right" | "to-bottom" | "to-upper-left" | "to-upper-right" | "to-lower-right" | "to-lower-left" | "path" | "spiral-inward-left" | "spiral-inward-right" | "spiral-outward-left" | "spiral-outward-right" | "vertical" | "horizontal" | "to-center" | "clockwise" | "counter-clockwise" ;
styleNameRefs ::= string()* ;
nonNegativeInteger ::= integer() ;
vertBackPos ::= "top" | "center" | "bottom" ;
shadowType ::= "none" | string ;
borderWidths ::= positiveLength positiveLength positiveLength ;
cellRangeAddress ::= string() ;
lineMode ::= "continuous" | "skip-white-space" ;
cellRangeAddressList ::= string() ;
fontVariant ::= "normal" | "small-caps" ;
lineWidth ::= "auto" | "normal" | "bold" | "thin" | "medium" | "thick" | positiveInteger | percent | positiveLength ;
cellAddress ::= string() ;
clipShape ::= string() ;
fontPitch ::= "fixed" | "variable" ;
pathData ::= string() ;
zeroToOneDecimal ::= integer() ;
anyAttListOrElements ::= string()* anyElements ;
dateOrDateTime ::= string() ;
nonNegativeLength ::= string() ;
variableName ::= string() ;
fontWeight ::= "normal" | "bold" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" ;
languageCode ::= string() ;
countryCode ::= string() ;
rowOrCol ::= "row" | "column" ;
fontStyle ::= "normal" | "italic" | "oblique" ;
anyURI ::= string() ;
textEncoding ::= string() ;
extrusionOrigin ::= string() ;
lineStyle ::= "none" | "solid" | "dotted" | "dash" | "long-dash" | "dot-dash" | "dot-dot-dash" | "wave" ;
styleName ::= string() ;
dateTime ::= string() ;
zeroToHundredPercent ::= string() ;
scriptCode ::= string() ;
styleNameRef ::= string() | ε ;
signedZeroToHundredPercent ::= string() ;
labelPositions ::= "avoid-overlap" | "center" | "top" | "top-right" | "right" | "bottom-right" | "bottom" | "bottom-left" | "left" | "top-left" | "inside" | "outside" | "near-origin" ;
anyIRI ::= string() ;
relativeLength ::= string() ;
namespacedToken ::= string() ;
mathMarkup ::= (α | string() | mathMarkup)* ;
horiBackPos ::= "left" | "center" | "right" ;
nonNegativeDecimal ::= integer() ;
lineType ::= "none" | "single" | "double" ;
valueType ::= "float" | "time" | "date" | "percentage" | "currency" | "boolean" | "string" ;
timeOrDateTime ::= string() ;
nonNegativePixelLength ::= string() ;
presentationEffects ::= "none" | "fade" | "move" | "stripes" | "open" | "close" | "dissolve" | "wavyline" | "random" | "lines" | "laser" | "appear" | "hide" | "move-short" | "checkerboard" | "rotate" | "stretch" ;
targetFrameName ::= "_self" | "_blank" | "_parent" | "_top" | string ;
presentationSpeeds ::= "slow" | "medium" | "fast" ;
positiveInteger ::= integer() ;
fontFamilyGeneric ::= "roman" | "swiss" | "modern" | "decorative" | "script" | "system" ;
anyElements ::= (string()? anyAttListOrElements string()?)* ;
--------------------pascal::object.bgf--------------------
variantType ::= "variant" | "olevariant" ;
setType ::= "set" "of" ordinalType ;
enumeratedType ::= "(" {decl_name ","}* ")" ;
objectType ::= "object" object_heritage? object_field_list? method_list? "end" ;
realType ::= "real48" | "real" | "single" | "double" | "extended" | "currency" | "comp" ;
pointerType ::= "^" typeId ;
subrangeType ::= expression ".." expression ;
fileType ::= "file" "of" typeId ;
typeId ::= ref_name | predefinedType ;
restrictedType ::= objectType | classType | interfaceType ;
endNameTag ::= SPOFF SP "</" "UID" ">" SPON ;
interfaceType ::= "interface" interface_heritage? class_method_list? class_property_list? "end" ;
arrayType ::= array_word square_ordinalType? "of" type ;
classType ::= "class" class_heritage? IN NL class_element_list? vis_spec_element_list* EX NL "end"? ;
labelId ::= "label" number+ ";" NL ;
structType ::= (arrayType "packed"?) | (setType "packed"?) | (fileType "packed"?) | (recordType "packed"?) ;
startNameTag ::= SPOFF SP "<" "UID" SP "name" "=" stringlit ">" SPON ;
procedureType ::= proc_or_func_heading of_object? ;
simpleType ::= ordinalType | realType ;
recordType ::= "record" field_list "end" ;
stringType ::= "string" | "ansistring" | "widestring" | ("string" "[" expression "]") ;
ordinalType ::= subrangeType | enumeratedType | ordinal_identifier ;
implementsTypeId ::= "implements" typeId ;
predefinedType ::= "integer" | "real" | "boolean" | "char" | "byte" ;
--------------------markup::pnml-anyElement.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-ext-inhibitor.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-ext-reset.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-ext-resetinhibitor.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-highlevelnet.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-hlpng.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-pnmlcoremodel.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-ptnet.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------markup::pnml-symmetricnet.bgf--------------------
anyElement ::= (α | string() | anyElement)* ;
--------------------fl::antlr.bgf--------------------
ifThenElse ::= "if" c::expr "then" e1::expr "else" e2::expr ;
--------------------fl::python.bgf--------------------
ifThenElse ::= _IF expr _THEN expr _ELSE expr ;
--------------------metasyntax::txl.bgf--------------------
ruleApplications ::= IN IN commentNL* ruleApplication+ EX EX ruleoptNL? ;
eachArgs ::= SP "each" varidOrLiteral* ;
formatCue ::= "[" formatId "]" ;
functionStatement ::= ("function" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "replace" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX "by" NL IN replacement EX EX "end" "function" NL NL) | ("function" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "match" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX EX "end" "function" NL NL) ;
formatCues ::= IN IN formatCue+ EX EX optNL? ;
ruleoptNL ::= NL ;
tokensStatement ::= "tokens" NL IN tokenPattern* EX "end" "tokens" NL NL ;
ruleApplication ::= (SP "[" ruleid varidOrLiteral* eachArgs? "]" commentNL*) | (SP lengthrule varidOrLiteral* eachArgs? "]" commentNL*) ;
defineStatement ::= "define" typeid NL IN IN literalOrType* NL barLiteralsAndTypes* EX EX "end" "define" NL NL RESET ;
formatId ::= "NL" | ("IN" IN) | ("EX" EX) ;
typeModifier ::= "opt" | "repeat" | "list" | "attr" | "see" | "not" | "push" | "pop" | ":" | "~" | ">" | "<" ;
optNL ::= NL ;
commentConvention ::= (literal SP literal NL) | (literal NL) ;
typeidOrQuotedLiteral ::= typeid | quotedLiteral ;
unquotedLiteral ::= (SP "'") | token ;
dollarStar ::= (SP "$") | (SP "*") ;
varidOrLiteral ::= (SP varid) | (SP literal) ;
literalOrExpression ::= (literal SP) | (expression SP) ;
dotDotDotBar ::= "..." EX NL "|" TAB IN ;
quotedLiteral ::= ("'" unquotedLiteral) | ("'" key) ;
compoundsStatement ::= "compounds" NL IN compound* EX NL "end" "compounds" NL NL ;
includeStatement ::= "include" stringlit NL ;
externalStatement ::= ("external" "rule" ruleid formalArgument* NL NL) | ("external" "function" ruleid formalArgument* NL NL) ;
typeRepeater ::= "+" | "*" | "?" | "," | ",+" ;
redefineStatement ::= "redefine" typeid NL IN IN dotDotDotBar? literalOrType* NL barLiteralsAndTypes* barDotDotDot? EX EX "end" redefineOrDefine NL NL RESET ;
constructDeconstructImportExportOrCondition ::= constructor | deconstructor | condition | importer | exporter | (EX comment NL IN) ;
commentNL ::= SP SP comment NEWoptNL? ;
commentsStatement ::= "comments" NL IN commentConvention* EX "end" "comments" NL NL ;
keysStatement ::= "keys" NL IN keyword* EX NL "end" "keys" NL NL ;
barLiteralsAndTypes ::= EX "|" TAB IN literalOrType* NL ;
tokenPattern ::= (typeid TAB_24 stringlit NL) | (TAB_16 "|" TAB_24 stringlit NL) | (typeid TAB_16 "..."? "|" TAB_24 stringlit NL) | (typeid TAB_16 "+" TAB_24 stringlit NL) | (comment NL) ;
barDotDotDot ::= EX "|" TAB IN "..." NL ;
typeSpec ::= (typeModifier? typeid typeRepeater?) | "!" ;
ruleStatement ::= ("rule" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "replace" dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX "by" NL IN replacement EX EX "end" "rule" NL NL) | ("rule" ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? "match" dollarStar? SP type NL IN pattern EX EX constructDeconstructImportExportOrCondition* "end" "rule" NL NL) ;
literalOrVariable ::= (literal SP) | (varid SP type SP) | (varid SP) ;
formalArgument ::= varid SP type commentNL* ;
literalOrType ::= (type SP) | (literal SP) ;
redefineOrDefine ::= "redefine" | "define" ;
skippingType ::= "skipping" SP type commentNL* ;
--------------------metasyntax::yacc-txl.bgf--------------------
plusOrStar ::= "+" | "*" ;
unquotedLiteral ::= yac_id | charlit | stringlit | number | key ;
tokenDefinition ::= yac_tokenDefinition | ("define" yac_id NL IN yac_tokenDefinition EX "end" "define" NL NL) ;
literalOrType ::= literal | type | prec | Ccode ;
productionDefinition ::= (yac_id ":" NL IN SP SP literalsAndTypes barLiteralsAndTypes* ";"? NL EX) | ("define" yac_id NL IN SP SP literalsAndTypes NL barLiteralsAndTypes* EX "end" "define" NL NL) ;
endSection ::= "%%" NL NL ;
barLiteralsAndTypes ::= ("|" SP literalsAndTypes NL) | (SP bar_yac_literals NL) ;
productionDefinitions ::= productionDefinition* ;
tokenDefinitions ::= tokenDefinition* endSection? ;
quotedLiteral ::= SP "'" unquotedLiteral SP ;
literalsAndTypes ::= literalOrType* ;
--------------------metasyntax::xsd-tennison.bgf--------------------
complexTypeModel ::= simpleContent | ((mixed::("true" | "false"))? complexContent | (typeDefParticle? attrDecls)) ;
complexRestriction ::= restriction::(annotated base::string() typeDefParticle? attrDecls) ;
identityConstraint ::= unique | key | keyref ;
minInclusive ::= minInclusive::rangeFacet ;
rangeFacet ::= facet value::(integer() | string() | "UNKNOWN data") ;
simpleRestriction ::= restriction::(annotated simpleRestrictionModel attrDecls) ;
rangeFacets ::= (minExclusive | minInclusive)? (maxExclusive | maxInclusive)? ;
openAttrs ::= string()* ;
importOptionalNamespace ::= import::(import (namespace::string())?) ;
attributeType ::= ε | (type::string()) | localSimpleType ;
schemaTop ::= redefinable | topLevelElement | topLevelAttribute | notation ;
localAttribute ::= attribute::(annotated (use::("optional" | "prohibited" | "required"))? fixedOrDefault (ref::string()) | (name::string() (form::formChoice)? attributeType)) ;
complexExtension ::= extension::(extensionType typeDefParticle? attrDecls) ;
anyContent ::= (string() | (α* anyContent))* ;
simpleExtension ::= extension::(extensionType attrDecls) ;
topLevelAttribute ::= attribute::(annotated name::string() fixedOrDefault attributeType) ;
minExclusive ::= minExclusive::rangeFacet ;
explicitGroup ::= annotated occurs nestedParticle* ;
derivationSet ::= "#all" | reducedDerivationControl ;
whiteSpaceCollapse ::= whiteSpace::(facet value::"collapse") ;
maxLength ::= maxLength::numFacet ;
appinfoContent ::= anyContent ;
digitFacets ::= totalDigits? fractionDigits? ;
complexContent ::= complexContent::(annotated (mixed::("true" | "false"))? complexRestriction | complexExtension) ;
maxInclusive ::= maxInclusive::rangeFacet ;
whiteSpaceReplaceOrCollapse ::= whiteSpace::(facet value::("replace" | "collapse")) ;
commonFacets ::= enumeration* whiteSpaceCollapse? pattern* ;
simpleContent ::= simpleContent::(annotated simpleRestriction | simpleExtension) ;
lengthFacets ::= length | (minLength? maxLength?) ;
documentationContent ::= anyContent ;
localComplexType ::= complexType::complexType ;
whiteSpace ::= whiteSpace::(facet value::("preserve" | "replace" | "collapse")) ;
nestedParticle ::= localElement | groupRef | choice | sequence | any ;
namedAttributeGroup ::= attributeGroup::(annotated name::string() attrDecls) ;
topLevelSimpleType ::= simpleType::(simpleType name::string() (final::simpleDerivationSet)?) ;
topLevelComplexType ::= complexType::(complexType name::string() ((abstract::("true" | "false")) | (block::derivationSet) | (final::derivationSet))*) ;
maxExclusive ::= maxExclusive::rangeFacet ;
simpleDerivationSet ::= "#all" | (("list" | "union" | "restriction")*) ;
simpleExplicitGroup ::= annotated nestedParticle* ;
extensionType ::= annotated base::string() ;
minLength ::= minLength::numFacet ;
attrDecls ::= (localAttribute | attributeGroupRef)* anyAttribute? ;
localSimpleType ::= simpleType::simpleType ;
importRequiredNamespace ::= import::(import namespace::string()) ;
blockSet ::= "#all" | (("extension" | "restriction" | "substitution")*) ;
groupRef ::= group::(annotated occurs ref::string()) ;
numFacet ::= facet value::integer() ;
localElement ::= element::(occurs (ref::string()) | (element name::string() (form::formChoice)?)) ;
typeDefParticle ::= groupRef | all | choice | sequence ;
attributeGroupRef ::= attributeGroup::(annotated ref::string()) ;
anyAttribute ::= anyAttribute::wildcard ;
simpleRestrictionModel ::= (base::"xs:anySimpleType" rangeFacets digitFacets lengthFacets whiteSpace? enumeration* pattern*) | (base::"xs:string" lengthFacets whiteSpace? enumeration* pattern*) | (base::"xs:normalizedString" lengthFacets whiteSpaceReplaceOrCollapse? enumeration* pattern*) | (base::("xs:token" | "xs:language" | "xs:Name" | "xs:NCName" | "xs:ID" | "xs:IDREF" | "xs:IDREFS" | "xs:NMTOKEN" | "xs:NMTOKENS" | "xs:ENTITY" | "xs:ENTITIES" | "xs:hexBinary" | "xs:base64Binary" | "xs:anyURI" | "xs:QName" | "xs:NOTATION") lengthFacets commonFacets) | (base::"xs:boolean" whiteSpaceCollapse? pattern*) | (base::("xs:decimal" | "xs:integer" | "xs:nonPositiveInteger" | "xs:nonNegativeInteger" | "xs:positiveInteger" | "xs:negativeInteger" | "xs:unsignedLong" | "xs:unsignedInt" | "xs:unsignedShort" | "xs:unsignedByte" | "xs:long" | "xs:int" | "xs:short" | "xs:byte") digitFacets rangeFacets commonFacets) | (base::("xs:float" | "xs:double" | "xs:duration" | "xs:dateTime" | "xs:time" | "xs:date" | "xs:gYearMonth" | "xs:gYear" | "xs:gMonthDay" | "xs:gMonth" | "xs:gDay") rangeFacets commonFacets) | ((base::string()) | localSimpleType rangeFacets digitFacets lengthFacets whiteSpace? enumeration* pattern*) ;
topLevelElement ::= element::(element name::string() ((substitutionGroup::string()) | (abstract::("true" | "false")) | (final::derivationSet))*) ;
simpleType ::= annotated simpleDerivation ;
totalDigits ::= totalDigits::(facet value::integer()) ;
complexType ::= annotated complexTypeModel ;
fixedOrDefault ::= ε | (fixed::string()) | (default::string()) ;
simpleDerivation ::= simpleRestriction | list | union ;
fractionDigits ::= fractionDigits::numFacet ;
allModel ::= annotated (element::(((minOccurs::("0" | "1")) | (maxOccurs::("0" | "1")))* (ref::string()) | (element name::string() (form::formChoice)?)))* ;
reducedDerivationControl ::= ("extension" | "restriction")* ;
allNNI ::= integer() | "unbounded" ;
namedGroup ::= group::(annotated name::string() (all::allModel) | (choice::simpleExplicitGroup) | (sequence::simpleExplicitGroup)) ;
formChoice ::= "qualified" | "unqualified" ;
noFixedFacet ::= annotated value::string() ;
--------------------tescol::00001.bgf--------------------
boolExpr ::= andExpr (DISJ andExpr)* ;
constDec ::= CONST CID COLON types ASSI expr ;
andExpr ::= compExpr (CONJ compExpr)* ;
procDec ::= PROC ID OPAR paramlist CPAR COLON types ASSI statement ;
varDec ::= VAR id COLON types ;
multExpr ::= expExp (MULTI | DIV expExp)* ;
compExpr ::= plusexpr (GT | LT | GTE | LTE | EQ | NEQ plusexpr)? ;
expExp ::= atom (EXP atom)* ;
--------------------tescol::00010.bgf--------------------
arithmeticExpr ::= exprLevel1 (PLUS | MINUS exprLevel1)* ;
booleanExpr ::= conjunctionExpr (OR conjunctionExpr)* ;
mainStat ::= CHECKOUT stat DONE SEMI ;
constDecl ::= CONST CONST_ID COLON type DEFINED_AS arithmeticExpr SEMI ;
booleanOperator ::= EQUAL | NOT_EQUAL | GREATER | GREATER_EQUAL | LESS | LESS_EQUAL ;
bracketedExpr ::= condExpr | arithmeticExpr ;
conjunctionExpr ::= booleanAtom (AND booleanAtom)* ;
booleanAtom ::= (arithmeticExpr booleanOperator arithmeticExpr) | (LPAR booleanExpr RPAR) ;
procApply ::= VAR_ID LPAR args? RPAR ;
condExpr ::= testPart e1::arithmeticExpr COLON e2::arithmeticExpr ;
testPart ::= booleanExpr CONDITION ;
unaryExpr ::= (MINUS atom) | (PLUS atom) | atom ;
expExpr ::= unaryExpr (EXPONENTIATE unaryExpr)* ;
varDecl ::= VAR VAR_ID COLON type SEMI ;
procDecl ::= PROC VAR_ID LPAR parameter? RPAR COLON type DEFINED_AS stat ;
--------------------tescol::00100.bgf--------------------
procedureApp ::= ID LPAREN realParameters? RPAREN ;
expOperand ::= EXPONENTIATION ;
multOperand ::= MULTIPLICATION | DIVISION ;
realParameters ::= aritExpr (COMMA aritExpr)* ;
addOperand ::= ADDITION | SUBTRACTION ;
condExpr ::= booleanDisj (QUESTION aritExpr COLON aritExpr)? ;
multExpr ::= orderExpr (multOperand orderExpr)* ;
booleanDisj ::= booleanConj (DISJUNCTION booleanConj)* ;
orderExpr ::= sign (expOperand sign)? ;
ifStat ::= IF expression THEN statements ELSE statements ;
aritExpr ::= multExpr (addOperand multExpr)* ;
groupStatement ::= LBRACE statement+ RBRACE SEMI ;
booleanConj ::= booleanExpression (CONJUNCTION booleanExpression)* ;
booleanExpression ::= aritExpr (relational aritExpr)? ;
--------------------tescol::00110.bgf--------------------
whileStatement ::= WHILE expression DO statement ;
variableDeclaration ::= VAR VAR_ID COLON TYPE SEMI ;
procedureApplication ::= VAR_ID LEFT_PAREN p::procedureParams RIGHT_PAREN ;
procedureParams ::= expression (COMMA expression)* ;
procedureDeclaration ::= PROC VAR_ID LEFT_PAREN parameters RIGHT_PAREN COLON TYPE DEFINE_AS statement ;
condExpr ::= add (Q_MARK add COLON add)? ;
constantDeclaration ::= CONST CONST_ID COLON TYPE DEFINE_AS add SEMI ;
ifStatement ::= IF expression THEN s1::statement ELSE s2::statement ;
assignmentStatement ::= VAR_ID DEFINE_AS expression SEMI ;
skipStatement ::= SKIP SEMI ;
--------------------tescol::00111.bgf--------------------
arithEx ::= expr | procedureApplication ;
booleanExpr ::= arithEx (EQUALITY | NON_EQUALITY | LESS | LESS_EQUAL | GREATER | GREATER_EQUAL arithEx)? ;
procedureApplication ::= identifier LPAREN commaSeparatedArithEx RPAREN ;
prodExpr ::= exponentialExpr (MULTIPLICATION | DIVISION exponentialExpr)* ;
conditionalExpr ::= disjBooleanExpr (QUESTION conditionalExpr COLON conditionalExpr)? ;
exponentialExpr ::= unary (EXPONENTIATION unary)? ;
parameterList ::= firstID::identifier COLON firstType::type (COMMA followID::identifier COLON followType::type)* ;
constDeclaration ::= CONST CID COLON type COLON_EQUALS arithEx ;
conjBooleanExpr ::= booleanExpr (CONJUNCTION booleanExpr)* ;
compoundStatement ::= (LBRACE statement (SEMI statement)* RBRACE) | statement ;
procDeclaration ::= PROC identifier LPAREN parameterList? RPAREN COLON type COLON_EQUALS compoundStatement ;
commaSeparatedArithEx ::= (arithEx (COMMA arithEx)*)? ;
varDeclaration ::= VAR identifier COLON type ;
disjBooleanExpr ::= conjBooleanExpr (DISJUNCTION conjBooleanExpr)* ;
--------------------tescol::01000.bgf--------------------
multiExpr ::= expExpr (MULT | DIV expExpr)* ;
andExpr ::= comparExpr (CONJ comparExpr)* ;
orExpr ::= andExpr (DISJ andExpr)* ;
comparExpr ::= arithExpr (comparOps arithExpr)* ;
expExpr ::= atom (EXP atom)* ;
comparOps ::= EQ | NEQ | LT | GT | LTE | GTE ;
arithExpr ::= multiExpr (ADD | SUB multiExpr)* ;
--------------------tescol::01100.bgf--------------------
condExp ::= disjunct (QUESTIONMARK exp1::condExp COLON exp2::condExp) | ε ;
booleanSymbols ::= EQUALITY | NONEQUALITY | DIFFERENTOREQUAL | STRICTLYDIFFERENT ;
--------------------tescol::01101.bgf--------------------
conIDs ::= CID ;
varIDs ::= CID | ID ;
--------------------tescol::01110.bgf--------------------
constDec ::= CONST name::CID COLON t::type COLON_EQUALS c::mixFix SEMI ;
procDec ::= PROC name::ID LPAREN (a::ID COLON a_t::type (COMMA b::ID COLON b_t::type)*)? RPAREN COLON r_t::type COLON_EQUALS c::statement ;
varDec ::= VAR name::ID COLON t::type SEMI ;
checkoutStat ::= CHECKOUT statement DONE SEMI ;
mixFix ::= (a::conjDisjunExpr QUESTION b::conjDisjunExpr COLON c::conjDisjunExpr) | conjDisjunExpr ;
loopStat ::= WHILE a::mixFix DO b::statement ;
expoExpr ::= unary (EXPONENTIATION unary)* ;
multDivExpr ::= expoExpr (MULTIPLICATION | DIVISION expoExpr)* ;
startStat ::= TROLLEY CID CONTAINS ;
addSubExpr ::= multDivExpr (ADDITION | SUBTRACTION multDivExpr)* ;
procCall ::= (name::ID) | (name::CID) LPAREN (a::mixFix (COMMA b::mixFix)*)? RPAREN ;
skipStat ::= SKIP SEMI ;
conjDisjunExpr ::= relation (CONJUNCTION | DISJUNCTION relation)* ;
ifStat ::= (IF a::mixFix THEN b::statement ELSE c::statement) | (IF a::mixFix THEN b::statement) ;
--------------------tescol::01111.bgf--------------------
boolExpr ::= subExpr (operations subExpr)? ;
constDec ::= c::CONSTID COLON number DEFINEDAS arithmeticExpression ;
varDec ::= v::VARANDPROCID COLON number ;
conditionalStat ::= IF boolExpr THEN stat ELSE stat ;
mulExpr ::= divExpr (MULTIPLICATION divExpr)* ;
loopStat ::= WHILE boolExpr DO stat ;
progTree ::= TROLLEY CONSTID CONTAINS declarations* CHECKOUT stat DONE SEMI ;
addExpr ::= mulExpr (ADDITION mulExpr)* ;
subExpr ::= addExpr (SUBTRACTION addExpr)* ;
subExprList ::= arithmeticExpression (COMMA arithmeticExpression)* ;
conjBool ::= boolExpr (CONJUNCTION boolExpr)* ;
expExpr ::= atom (EXPONENTION atom)* ;
procDec ::= p::VARANDPROCID OPAR paramList? CPAR COLON number DEFINEDAS stat ;
paramList ::= varDec (COMMA varDec)* ;
divExpr ::= expExpr (DIVISION expExpr)* ;
disjBool ::= conjBool (DISJUNCTION conjBool)* ;
applyProc ::= VARANDPROCID OPAR subExprList CPAR ;
assignStat ::= VARANDPROCID DEFINEDAS arithmeticExpression ;
arithmeticExpression ::= disjBool (QUESTION arithmeticExpression COLON arithmeticExpression)? ;
--------------------tescol::10000.bgf--------------------
boolExpr ::= andExpr (DISJUNCTION andExpr)* ;
andExpr ::= compExpr (CONJUNCTION compExpr)* ;
expoExpr ::= atom EXPONENTIATION? ;
condExpr ::= boolExpr (QUESTION condExpr COLON condExpr)? ;
multExpr ::= expoExpr (MULTIPLICATION | DIVISION expoExpr)* ;
compExpr ::= expr (GREATER_EQUAL | LESS_EQUAL | EQUALITY | NON_EQUALITY | GREATER | LESS expr)? ;
multStat ::= LBRACE NEWLINE* stat (SEMI NEWLINE* stat)* NEWLINE* RBRACE SEMI ;
--------------------tescol::10001.bgf--------------------
boolExpr ::= andExpr (DISJUNCTION andExpr)* ;
andExpr ::= compExpr (CONJUNCTION compExpr)* ;
condExpr ::= boolExpr (QUESTION condExpr COLON condExpr)? ;
multExpr ::= atom (MULTIPLICATION | DIVISION | EXPONENTIATION atom)* ;
compExpr ::= expr (GREATER_EQUAL | LESS_EQUAL | EQUALITY | NON_EQUALITY | LESS | GREATER expr)? ;
--------------------tescol::10010.bgf--------------------
arithmeticOperator ::= ADD | SUBTRACT | DIVIDE | MULTIPLY | EXPON ;
conditionalExpression ::= booleanExpression (QUESTION conditional COLON conditional)? ;
statementList ::= CLPAREN statement SEMI (statement SEMI)* CRPAREN ;
procedureApplication ::= arithmetic (ID LPAREN expressionList RPAREN)? ;
relationalOperator ::= EQUAL | NOTEQUAL | MORETHAN | LESSTHAN | MORETHANEQUAL | LESSTHANEQUAL ;
parameterList ::= ID COLON type (COMMA ID COLON type)* ;
expressionList ::= arithmeticExpression (COMMA arithmeticExpression)* ;
disjExpression ::= expression (relationalOperator expression)? ;
arithmeticExpression ::= procedureApplication (conditionalExpression QUESTION arithmeticExpression COLON arithmeticExpression)? ;
conjExpression ::= disjExpression (DISJUNC disjExpression)* ;
booleanExpression ::= conjExpression (CONJUNC conjExpression)* ;
--------------------tescol::10011.bgf--------------------
multExpr ::= expon (MULT | DIV expon)* ;
--------------------tescol::10100.bgf--------------------
andExpression ::= orExpression (CONJUNCTION orExpression)* ;
relationalExpression ::= addExpression (GREATER_EQUAL | GREATER | LESS_EQUAL | LESS | EQUALITY | NON_EQUALITY addExpression)? ;
condStatement ::= IF expression THEN statement ELSE statement ;
statementList ::= LBRACE statement (SEMI statement NEWLINE*)* RBRACE ;
orExpression ::= relationalExpression (DISJUNCTION relationalExpression)* ;
addExpression ::= multExpression (ADDITION | SUBTRACTION multExpression)* ;
multExpression ::= atom (DIVISION | MULTIPLICATION | EXPONENTIATION atom)* ;
--------------------tescol::10101.bgf--------------------
boolExpr ::= andExpr (DISJUNCTION andExpr)* ;
andExpr ::= compExpr (CONJUNCTION compExpr)* ;
condExpr ::= boolExpr (MIXFIX condExpr COLON condExpr)? ;
multExpr ::= exponExpr (MULTIPLICATION | DIVISION exponExpr)* ;
compExpr ::= expr (GREATEREQUAL | LESSEQUAL | GREATER | LESS | EQUALITY | NONEQUALITY expr)* ;
procedureList ::= ID PARENOPEN id1::condExpr (COMMA id2::condExpr)* PARENCLOSE ;
exponExpr ::= unaryneg EXPONENTIATION* ;
--------------------tescol::10110.bgf--------------------
boolExpr ::= andExpr (DISJ andExpr)* ;
andExpr ::= compExpr (CONJ compExpr)* ;
powerExpr ::= atom (EXPONENTIATION atom)* ;
condExpr ::= boolExpr (QUESTION condExpr COLON condExpr)? ;
multExpr ::= powerExpr (MULTIPLY | DIVIDE powerExpr)* ;
compExpr ::= expr (comparator expr)? ;
--------------------tescol::10111.bgf--------------------
integerNum ::= (SYM_ADD | SYM_SUB)? INT ;
doubleNum ::= (SYM_ADD | SYM_SUB)? DOUBLE ;
--------------------tescol::11010.bgf--------------------
boolExpr ::= andExpr (DISJUNCTION andExpr)* ;
constDec ::= CONSTID COLON type DEFINEDAS subExpr ;
varDec ::= v1::smallId COLON type ;
conditionalStat ::= IF boolExpr THEN stat ELSE stat ;
mulExpr ::= divExpr (MULTIPLY divExpr)* ;
loopStat ::= WHILE boolExpr DO stat ;
progTree ::= TROLLEY CONSTID CONTAINS declarations* CHECKOUT stat DONE SEMI ;
condExpr ::= boolExpr (QUESTION condExpr COLON condExpr)? ;
addExpr ::= mulExpr (PLUS mulExpr)* ;
subExpr ::= addExpr (MINUS addExpr)* ;
exprList ::= compExpr (COMMA compExpr)* ;
expExpr ::= atom (EXPONENTIATION atom)* ;
andExpr ::= compExpr (CONJUNCTION compExpr)* ;
procDec ::= p1::smallId LEFTPAR paramList RIGHTPAR COLON type DEFINEDAS stat ;
paramList ::= varDec (COMMA varDec)* ;
divExpr ::= expExpr (DIVIDE expExpr)* ;
applyProc ::= smallId LEFTPAR exprList RIGHTPAR ;
compExpr ::= subExpr (EQUALITY | NOTEQUAL | LESSTHAN | LESSTHANEQUAL | MORETHAN | MORETHANEQUAL subExpr)? ;
assignStat ::= smallId DEFINEDAS condExpr ;
smallId ::= CONSTID | ID ;
--------------------tescol::11110.bgf--------------------
relationalExpression ::= addtExpr (LESS_EQUAL | GREATER_EQUAL | LESS | GREATER addtExpr)? ;
arithmeticExpr ::= conditionalExpr | (a::applyProcedure) ;
booleanExpr ::= conjunctionExpression (DISJUNCTION conjunctionExpression)* ;
conditionalExpr ::= booleanExpr (QUESTION conditionalExpr COLON conditionalExpr)? ;
listofStatement ::= "{" singleStatement (SEMI s::singleStatement)+ "}" ;
constDeclaration ::= CONST CONSTID COLON t::type COLON_EQUALS ar::arithmeticExpr SEMI ;
expressionList ::= arithmeticExpr ("," arithmeticExpr)* ;
parameterElement ::= id::ID COLON t::type ;
varDeclaration ::= VAR ID COLON t::type SEMI ;
equalityExpression ::= relationalExpression (EQUALITY | NON_EQUALITY relationalExpression)? ;
conjunctionExpression ::= equalityExpression (CONJUNCTION equalityExpression)* ;
skipStm ::= SKIP ;
proDeclaration ::= PROC ID LPAREN p1::parameterList RPAREN COLON t::type COLON_EQUALS s1::statement SEMI ;
condStm ::= IF LPAREN? a::booleanExpr RPAREN? THEN? b::statement (ELSE c::statement)? ;
addtExpr ::= multExpr (ADDITION | SUBTRACTION multExpr)* ;
loopStm ::= WHILE LPAREN? e::booleanExpr RPAREN? DO? s::statement ;
parameterList ::= parameterElement ("," parameterElement)* ;
singleStatement ::= skipStm | loopStm | condStm | (a::assgStm) ;
compilationUnit ::= TROLLEY CONSTID CONTAINS de::declarations CHECKOUT s::statement SEMI DONE SEMI ;
assgStm ::= ID COLON_EQUALS a1::arithmeticExpr ;
multExpr ::= unaryExpr (MULTIPLICATION | DIVISION | EXPONENTIATION unaryExpr)* ;
applyProcedure ::= ID LPAREN expressionList RPAREN ;
unaryExpr ::= ("-" atom) | atom ;
--------------------tescol::reference.bgf--------------------
appList ::= ε | (e::expression (COMMA f::expression)*) ;
constDecl ::= CONST CONSTID COLON t::type DEFAS e::expression ;
paramElem ::= ID COLON type ;
paramList ::= ε | (p::paramElem (COMMA q::paramElem)*) ;
procApp ::= ε | (LPAR appList RPAR) ;
stmtElem ::= SKIP | assign | condSt | loop ;
stmtList ::= LBRACE s::stmtElem (SEMI t::stmtElem)* RBRACE ;
condSt ::= IF e::expression THEN statement ELSE statement ;
varDecl ::= VAR (a::ID) | (a::CONSTID) COLON t::type ;
procDecl ::= PROC (a::ID) | (a::CONSTID) LPAR p::paramList RPAR COLON t::type DEFAS st::statement ;
--------------------metamodels::BPEL.bgf--------------------
messagepropertiesQuery ::= queryLanguage::EString value::EString ;
--------------------metamodels::XUL-Interactorl.bgf--------------------
onClick ::= (functionCallParameters::Parameter)+ functionCalledName::String name::String ;
--------------------slps::cbgf-xsd.bgf--------------------
splitT ::= terminal::terminal into::((terminal::terminal)+) (in::scope)? ;
--------------------slps::ldf-v1.0-xsd.bgf--------------------
sectionType ::= title::string() content::contentType ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? ;
mixedType ::= (α | string())* ;
sampleType ::= ε ;
contentType ::= ((text::mixedType) | (grammar::(α language::string() (version::string())?)) | (sample::sampleType) | (runnable::runnableType))* (section::sectionType)* ;
--------------------slps::ldf-v10.0-xsd.bgf--------------------
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v11.0-xsd.bgf--------------------
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v11.1-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (clause::simpleSection) | (field::simpleSection) ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
tableRow ::= (cell::simpleText)+ ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::listOfInternalLinks) | (subtopic::structuredSection) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
listOfInternalLinks ::= (link::(text::string() (linkText::string())? reference::string()))+ ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v11.2-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
tableRow ::= (cell::simpleText)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (clause::simpleSection) | (field::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::listOfInternalLinks) | (subtopic::structuredSection) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
listOfInternalLinks ::= (link::(text::string() (linkText::string())? reference::string()))+ ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v12.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (relationship::listOfInternalLinks) | (subtopic::structuredSection) | (clause::simpleSection) | (field::simpleSection) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
listOfInternalLinks ::= (link::(text::string() (linkText::string())? reference::string()))+ ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v13.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::listOfInternalLinks) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
listOfInternalLinks ::= (link::(text::string() (linkText::string())? reference::string()))+ ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v13.1-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::listOfInternalLinks) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
listOfInternalLinks ::= (link::(text::string() (linkText::string())? reference::string()))+ ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v14.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::string()) | (sample::string()) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v15.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::string()) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
anyMath ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v15.1-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
frontSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
anyMath ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
--------------------slps::ldf-v16.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
tableRow ::= (cell::simpleText)+ ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
simpleFigure ::= caption::string() type::string() file::string() (id::string())? ;
mixedType ::= (α | string())* ;
anyMath ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
simpleList ::= (item::mixedType)+ ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
--------------------slps::ldf-v17.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
figureType ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
simpleFigure ::= (shortcaption::string())? caption::string() (source::(type::figureType (localfile::string()) | (url::string())))+ (id::string())? ;
mixedType ::= (α | string())* ;
anyMath ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
simpleList ::= (item::mixedType)+ ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
tableRow ::= (cell::simpleText)+ ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v18.0-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
figureType ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
simpleFigure ::= (shortcaption::string())? caption::string() (source::(type::figureType (localfile::string()) | (url::string())))+ (id::string())? ;
mixedType ::= (α | string())* ;
anyMath ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
simpleList ::= (item::mixedType)+ ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
tableRow ::= (cell::simpleText)+ ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v18.1-xsd.bgf--------------------
simpleText ::= simpleTextElement+ ;
figureType ::= (PDF::ε) | (PostScript::ε) | (SVG::ε) | (PNG::ε) | (GIF::ε) | (JPEG::ε) ;
simpleTextElement ::= (empty::ε) | (text::mixedType) | (figure::simpleFigure) | (table::simpleTable) | (list::simpleList) | (formula::(((math::anyMath) | (mfenced::anyMath) | (mtext::anyMath) | (msub::anyMath) | (msup::anyMath) | (mrow::anyMath) | (mi::anyMath) | (mo::anyMath) | (varepsilon::α))+)) | (sample::((α | string())* src::string())) | production ;
simpleTable ::= (header::tableRow)* (row::tableRow)+ ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
simpleFigure ::= (shortcaption::string())? caption::string() (source::(type::figureType (localfile::string()) | (url::string())))+ (id::string())? ;
mixedType ::= (α | string())* ;
anyMath ::= (α | string())* ;
structuredSection ::= title::string() (author::string())* structuredSectionElement+ (id::string())? ;
simpleSection ::= (title::string())? (author::string())* content::simpleText (id::string())? ;
listOfTerms ::= (title::string())? (author::string())* (term::(name::string() definition::simpleText))+ (id::string())? ;
simpleList ::= (item::mixedType)+ ;
topSection ::= (foreword::simpleSection) | (designGoals::simpleSection) | (scope::simpleSection) | (conformance::simpleSection) | (compliance::simpleSection) | (compatibility::simpleSection) | (notation::simpleSection) | (normativeReferences::simpleSection) | (documentStructure::simpleSection) | (whatsnew::simpleSection) | (placeholder::generated) ;
tableRow ::= (cell::simpleText)+ ;
structuredSectionElement ::= (placeholder::generated) | normative | informative | production | (references::simpleList) | (section::simpleSection) | (subtopic::structuredSection) | (value::(key::string() data::string())) ;
frontList ::= (definitions::listOfTerms) | (abbreviations::listOfTerms) | (languageOverview::listOfTerms) ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
lexicalSection ::= (lineContinuations::simpleSection) | (whitespace::simpleSection) | (tokens::simpleSection) | (preprocessor::simpleSection) | (literals::simpleSection) | (lexical::simpleSection) ;
--------------------slps::ldf-v19.0-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v2.0-xsd.bgf--------------------
sectionType ::= title::string() content::contentType ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? ;
mixedType ::= (α | string())* ;
sampleType ::= ε ;
contentType ::= ((text::mixedType) | (grammar::(α language::string() (version::string())?)) | (sample::sampleType) | (runnable::runnableType))* (section::sectionType)* ;
--------------------slps::ldf-v2.1-xsd.bgf--------------------
sectionType ::= title::string() content::contentType ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
mixedType ::= (α | string())* ;
sampleType ::= ε ;
contentType ::= ((text::mixedType) | (grammar::(α language::string() (version::string())?)) | (sample::sampleType) | (runnable::runnableType))* (section::sectionType)* ;
--------------------slps::ldf-v20.0-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v20.1-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v21.0-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v21.1-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v22.0-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v23.0-xsd.bgf--------------------
anyMath ::= (α | string())* ;
--------------------slps::ldf-v3.0-xsd.bgf--------------------
frontMatter ::= foreword::SimpleText designGoals::SimpleList top-section+ normativeReferences::SimpleList (definitions::ListOfTerms)? (abbreviations::ListOfTerms)? documentStructure::TopSection whatsnew::SimpleList ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v4.0-xsd.bgf--------------------
frontMatter ::= foreword::SimpleText designGoals::SimpleList top-section+ normativeReferences::SimpleList (definitions::ListOfTerms)? (abbreviations::ListOfTerms)? documentStructure::SimpleSection whatsnew::SimpleList ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v5.0-xsd.bgf--------------------
frontLists ::= (((definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms))+)? ;
frontMatter ::= ((foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection))+ ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v6.0-xsd.bgf--------------------
frontLists ::= (((definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms))+)? ;
lexicalGroup ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
frontMatter ::= ((foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection))+ ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v7.0-xsd.bgf--------------------
frontLists ::= (((definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms))+)? ;
lexicalGroup ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) ;
frontMatter ::= ((foreword::SimpleSection) | (designGoals::SimpleSection) | (scope::SimpleSection) | (conformance::SimpleSection) | (compliance::SimpleSection) | (compatibility::SimpleSection) | (notation::SimpleSection) | (normativeReferences::SimpleSection) | (documentStructure::SimpleSection) | (whatsnew::SimpleSection) | (clause::SimpleSection) | (field::SimpleSection))+ ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v7.1-xsd.bgf--------------------
frontLists ::= (((definitions::ListOfTerms) | (abbreviations::ListOfTerms) | (languageOverview::ListOfTerms))+)? ;
lexicalGroup ::= (lineContinuations::SimpleSection) | (whitespace::SimpleSection) | (tokens::SimpleSection) | (preprocessor::SimpleSection) | (literals::SimpleSection) | (lexical::SimpleSection) ;
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) | production ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v8.0-xsd.bgf--------------------
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) | production ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v8.1-xsd.bgf--------------------
insideSimpleText ::= (p::string()) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v9.0-xsd.bgf--------------------
insideSimpleText ::= (empty::α) | (text::mixedType) | (table::SimpleTable) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::ldf-v9.1-xsd.bgf--------------------
insideSimpleText ::= (empty::α) | (text::mixedType) | (table::SimpleTable) | (list::SimpleList) | (formula::string()) | (sample::string()) | production ;
runnableType ::= context::string() main::string() (argument::string())* yields::string() language::string() (version::string())? (id::string())? ;
titlePage ::= (body::body number::integer()) | ((author::string())+) topic::string() (version::string()) | (edition::string()) status::status date::string() ;
mixedType ::= (α | string())* ;
--------------------slps::slps-cbgf-xsd.bgf--------------------
splitT ::= terminal::terminal into::((terminal::terminal)+) (in::scope)? ;
--------------------slps::slps-xbgf-xsd.bgf--------------------
splitT ::= terminal::terminal into::((terminal::terminal)+) (in::scope)? ;
--------------------slps::slps-xedd.bgf--------------------
confixMetasymbols ::= (group::ε) | (seplist-plus::ε) | (seplist-star::ε) ;
--------------------slps::slps-xldf.bgf--------------------
importSample ::= target::string() file::string() (prettyprinter::string())? ;
evolutionSequence ::= documentTransformation* ;
transformGrammar ::= target::string() transformation+ (context::string())* ;
sectionRole ::= (frontMatter::ε) | (backMatter::ε) | (synopsis::ε) | (description::ε) | (syntax::ε) | (constraints::ε) | (relationship::ε) | (semantics::ε) | (default::ε) | (rationale::ε) | (example::ε) | (update::ε) | (section::ε) ;
splitT ::= terminal::terminal into::((terminal::terminal)+) (in::scope)? ;
transformDocument ::= file::string() ;
extractSubsection ::= from::string() content::simpleText title::string() id::string() (to::string())? (role::sectionRole)? ;
changeRole ::= scope::string() from::sectionRole to::sectionRole ;
addSubsection ::= topSection | (normative | informative to::string()) ;
addFigure ::= figure::simpleFigure to::string() ;
addSection ::= frontList | lexicalSection | (placeholder::generated) | (core::structuredSection) | (annex::structuredSection) ;
documentTransformation ::= addFigure | addSection | addSubsection | append | changeRole | combine | drop | extractSubsection | hyperlinkify | insert | importGrammar | importSample | place | retitle | removeSection | transformDocument | transformGrammar ;
importGrammar ::= target::string() file::string() ;
removeSection ::= id::string() (from::string())? ;
--------------------slps::xbgf-xsd.bgf--------------------
splitT ::= terminal::terminal into::((terminal::terminal)+) (in::scope)? ;
