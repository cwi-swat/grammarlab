@contributor{Generated by meta::Glue, do not edit manually!}
module grammarlab::language::GlueGrammar
// import util::IDE; // needed only for advanced IDE support
import String; import IO;
import grammarlab::language::Grammar;
import grammarlab::io::Grammar;
import grammarlab::lib::Sizes;
start syntax GlueGrammarGrammar = GlueGrammarProduction*;
syntax GlueGrammarProduction = GlueGrammarNonterminal "::=" {GlueGrammarDefinition "|"}+ ";\n";
syntax GlueGrammarDefinition = GlueGrammarSymbol+;
syntax GlueGrammarSymbol
 = @category="Identifier" nonterminal: GlueGrammarNonterminal
 | @category="Constant" terminal: GlueGrammarTerminal
 | group: "(" {GlueGrammarDefinition "|"}+ ")"
 | optional: GlueGrammarSymbol "?"
 | star: GlueGrammarSymbol "*"
 | plus: GlueGrammarSymbol "+"
 | sepliststar: "{" GlueGrammarSymbol GlueGrammarSymbol "}*"
 | seplistplus: "{" GlueGrammarSymbol GlueGrammarSymbol "}+";
lexical GlueGrammarTerminal = "\"" GlueGrammarTerminalSymbols name "\"";
lexical GlueGrammarTerminalSymbols = ![\"]* !>> ![\"];
lexical GlueGrammarNonterminal =  GlueGrammarNonterminalSymbols name ;
lexical GlueGrammarNonterminalSymbols = [A-Za-z_01-9]+ !>> [A-Za-z_01-9];
layout GlueGrammarLayoutList = GlueGrammarLayout* !>> [\t-\n \r \  ] !>> "//";
lexical GlueGrammarLayout = [\t-\n \r \  ] | GlueGrammarComment ;
lexical GlueGrammarComment = @category="Comment" "//" ![\n]* [\n];

//Tree getGlueGrammar(str s,loc z) = parse(#GlueGrammarGrammar,z);
//public void registerGlueGrammar() = registerLanguage("GlueGrammar","gluegrammar",getGlueGrammar);

Tree parseGlueGrammar(loc z) = parse(#GlueGrammarGrammar, trim(readFile(z)));
GGrammar mapG((GlueGrammarGrammar)`<GlueGrammarProduction* ps>`)
{
	GProdList ps2 = []; list[str] nts = [];
	for(p <- ps){p2 = mapP(p); if(p.lhs notin nts)nts+=p.lhs; ps2+=p2;}
	return grammar(nts, [], ps2);
}
GProd mapP((GlueGrammarProduction)`<GlueGrammarNonterminal lhs>::=<{GlueGrammarDefinition "|"}+ rhds>;`) = production("<lhs>",mapDs(rhds));
GExpr mapDs({GlueGrammarDefinition "|"}+ ds)
{
	GExprList es = [mapE(d) | GlueGrammarDefinition d <- ds];
	return (len(es)==1) ? es[0] : choice(es);
}
GExpr mapE((GlueGrammarDefinition)`<GlueGrammarSymbol s>`) = mapS(s);
default GExpr mapE((GlueGrammarDefinition)`<GlueGrammarSymbol+ ss>`) = sequence([mapS(s) | GlueGrammarSymbol s <- ss]);
GExpr mapS((GlueGrammarSymbol)`<GlueGrammarNonterminal n>`) = nonterminal("<n.name >");
GExpr mapS((GlueGrammarSymbol)`<GlueGrammarTerminal t>`) = terminal("<t.name>");
GExpr mapS((GlueGrammarSymbol)`(<{GlueGrammarDefinition "|"}+ ds>)`) = mapIDs(ds);
GExpr mapIDs({GlueGrammarDefinition "|"}+ ds)
{
	GExprList es = [mapE(d) | GlueGrammarDefinition d <- ds];
	return (len(es)==1) ? es[0] : choice(es);
}
public void main(list[str] args)
	= (len(args)==2)
	? writeBGF(mapG(parse(#GlueGrammarGrammar, trim(readFile(|cwd:///|+args[0])))), |cwd:///|+args[1])
	: println("Please provide two arguments: input and output.");
